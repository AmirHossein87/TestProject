-- <Migration ID="8b447dd9-50a4-4b98-a69d-5273e36a3bec" />
GO

PRINT N'Creating role ApiCallers'
GO
CREATE ROLE [ApiCallers]
AUTHORIZATION [dbo]
GO
PRINT N'Creating schemas'
GO
CREATE SCHEMA [DatabaseVersioning]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [SQLCop]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [api]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [const]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dsp]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dspAuth]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dspInboxMessage]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dspRequest]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dspconst]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dsperr]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dspstr]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dsptUtil]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [dsptest]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [err]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [request]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [str]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [syn]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [tClass]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [tCodeQuality]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [tSQLt]
AUTHORIZATION [dbo]
GO
CREATE SCHEMA [tUtil]
AUTHORIZATION [dbo]
GO
PRINT N'Creating CLR assemblies'
GO
--Assembly tsqltclr, version=1.0.5873.27393, culture=neutral, publickeytoken=7722217d36028e4c, processorarchitecture=msil
CREATE ASSEMBLY [tSQLtCLR]
AUTHORIZATION [dbo]
FROM 0x4d5a90000300000004000000ffff0000b800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000e1fba0e00b409cd21b8014ccd21546869732070726f6772616d2063616e6e6f742062652072756e20696e20444f53206d6f64652e0d0d0a2400000000000000\
504500004c0103005219ad560000000000000000e00002210b010b00004a000000060000000000001e68000000200000008000000000001000200000000200000400000000000000040000000000000000c00000000200001f550000030040850000100000100000000010000010000000000000100000000000000000000000\
c86700005300000000800000f80300000000000000000000000000000000000000a000000c000000906600001c0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002e74657874000000\
2448000000200000004a000000020000000000000000000000000000200000602e72737263000000f80300000080000000040000004c0000000000000000000000000000400000402e72656c6f6300000c00000000a0000000020000005000000000000000000000000000004000004200000000000000000000000000000000\
006800000000000048000000020005003c3500005431000009000000000000000000000000000000502000008000000000000000000000000000000000000000000000000000000000000000000000009d63a517ced9d2ce805b163a00868e987936f818709cd02ee31f21244d8c9ba69ecf06878608961fbe7e9c5b009e4c7a\
cf794fe36c51e8c75909b8e31cfa047713754986e739d088652adf79832925307b3f8f9953d425c7a3f29b7334245e5f0e98ea299d08d952730f071dd02a73df0b645a801a953787753ca8109df47e6a1b3002006d00000001000011140a18730f00000a0b28020000060c08731000000a0a066f1100000a731200000a0d0906\
6f1300000a090f01fe16080000016f1400000a6f1500000a096f1600000a26de0a072c06076f1700000adcde0f13047201000070110473060000067ade0a062c06066f1800000adc2a00000001280000020009003c45000a00000000000002004f51000f32000001020002006062000a00000000133003004e00000002000011\
73400000060a066f450000060b066f460000060c731900000a0d0972b6000070076f1a00000a0972ce000070178c350000016f1a00000a0972f6000070086f1a00000a096f1b00000a130411042a1e02281c00000a2a1e02281e00000a2a220203281f00000a2a26020304282000000a2a26020304282100000a2a3a02281c00\
000a02037d010000042a7a0203280b000006027b01000004027b010000046f420000066f4b0000062a220203280b0000062a0000133002001400000003000011027b01000004036f470000060a066f2200000a2a6a282500000a6f2600000a6f2700000a6f1400000a282800000a2a56282500000a6f2600000a6f2900000a28\
2a00000a2a0000001330040032000000040000117216010070282c00000a0a1200fe16400000016f1400000a723a010070723e0100706f2d00000a282e00000a282800000a2a00001b3005002b020000050000110f00282f00000a2c0b7240010070731f00000a7a0f01282f00000a2c0c723e010070282800000a10010f0228\
2f00000a2c0c723e010070282800000a100273400000060a0f000f0128150000060b0607282800000a6f470000060c080428160000060d16130409166f3000000a8e698d420000011305096f3100000a13102b3b1210283200000a13061613072b1f110511071105110794110611079a6f3300000a283400000a9e1107175813\
07110711068e6932d91104175813041210283500000a2dbcde0e1210fe160200001b6f1700000adc1613082b1a110511081105110894209b000000283600000a9e110817581308110811058e6932de161309110513111613122b161111111294130a110917110a58581309111217581312111211118e6932e211091758130911\
09110417585a130917130b1109733700000a130c096f3100000a131338b00000001213283200000a130d110b2d08110c6f3800000a2616130e2b2c110c72760100706f3900000a110d110e9a28140000061105110e9428130000066f3900000a26110e1758130e110e110d8e6932cc110c72760100706f3900000a26110b2c51\
16130b110c6f3800000a2616130f2b2c110c727a0100706f3900000a26110c110c6f3a00000a723a0100701105110f946f3b00000a26110f1758130f110f110d8e6932cc110c727a0100706f3900000a261213283500000a3a44ffffffde0e1213fe160200001b6f1700000adc110c6f1400000a282800000a733c00000a2a00\
011c000002007e0048c6000e0000000002004801c30b020e000000001330050039000000060000110228120000060a727e010070733d00000a0b070f00fe16080000016f1400000a72e201007017066f3e00000a0c08282800000a733c00000a2a327e04000004026f3f00000a2a000013300200fe000000070000110f00fe16\
080000016f1400000a6f4000000a0a150b160c160d16130438cd0000000813051105450600000005000000330000003f00000053000000760000008c00000038a00000000611049328110000063a92000000061104931f2d3307170c3883000000061104931f2f3304190c2b7711040b2b72061104931f2d336a180c2b660611\
04931f0d2e08061104931f0a3356160c2b52061104931f2a33081a0c0917580d2b42091631041a0c2b3a7200020070731f00000a7a061104931f2a33021b0c061104931f2f331d190c2b19061104931f2f330f0917590d092d04160c2b061a0c2b021a0c1104175813041104068e692f0707163f25ffffff072a920273410000\
0a16721a02007003026f3300000a59283b00000a6f1400000a282e00000a2ad2026f3300000a209b000000312502161f4b6f4200000a721e02007002026f3300000a1f4b591f4b6f4200000a284300000a2a022a133003004500000008000011722a02007002fe16080000016f1400000a282e00000a0a03fe16080000016f14\
00000a6f3300000a16311806724802007003fe16080000016f1400000a284300000a0a062a000000133004009202000009000011026f4400000a0a734500000a0b066f4600000a6f4700000a0c0f01fe16080000016f1400000a723e0100706f4800000a2c47088d410000010d1613042b2a066f4600000a11046f4900000a13\
050911041105725e0200706f4a00000a6f1400000aa211041758130411040832d107096f4b00000a380c0200000f0128170000061306734c00000a13071106130c16130d2b2e110c110d9a130811086f3300000a2c18110711087274020070727a0200706f2d00000a6f4d00000a110d1758130d110d110c8e6932ca0711076f\
4e00000a6f4b00000a38ab010000088d41000001130916130a388601000002110a6f4f00000a2c0f1109110a727e020070a23867010000066f4600000a110a6f4900000a728c0200706f4a00000aa549000001130b110b130e110e1f0f3024110e1a59450400000078000000bc000000da00000000010000110e1f0f2e563809\
010000110e1f13594503000000df000000f3000000df000000110e1f1f59450400000005000000d9000000590000006d00000038d40000001109110a02110a6f5000000a285100000a2819000006a238ca0000001109110a02110a6f5000000a285100000a281b000006a238ae0000001109110a02110a6f5000000a28510000\
0a281a000006a238920000001109110a02110a6f5000000a281c000006a22b7e1109110a02110a6f5200000a281d000006a22b6a1109110a02110a6f5300000a130f120ffe164a0000016f1400000aa22b4c1109110a02110a6f5400000a13101210285500000a1311121172a6020070285600000aa22b261109110a02110a6f\
5700000a281e000006a22b121109110a02110a6f5800000a6f1400000aa2110a1758130a110a026f5900000a3f6dfeffff0711096f4b00000a026f5a00000a3a4afeffff072a000013300300280000000a00001172d002007002fe16080000016f1400000a72d6020070284300000a72dc020070285b00000a0a062a820272e8\
020070723e0100706f2d00000a727a020070723e0100706f2d00000a2a5e72ec0200700f00285c00000a8c11000001285d00000a2a5e720a0300700f00285c00000a8c11000001285d00000a2a5e72420300700f00285c00000a8c11000001285d00000a2a72726c0300700f00285e00000a735f00000a8c11000001285d0000\
0a2a4672ac030070028c12000001285d00000a2a13300300440000000b000011734100000a72f4030070283900000a0a0f00286000000a0c160d2b1b0809910b06120172fa030070286100000a6f3900000a260917580d09088e6932df066f1400000a2a2e7200040070731f00000a7a2e7200040070731f00000a7a2e720004\
0070731f00000a7a2e7200040070731f00000a7a1a736200000a7a1a736200000a7a000013300300430000000c000011736300000a0a061f20176f6400000a061f0a176f6400000a061f0d176f6400000a061f09176f6400000a061f0c176f6400000a061f0b176f6400000a0680040000042a1e02281e00000a2a220203281f\
00000a2a26020304282000000a2a26020304282100000a2a3a02281c00000a02037d0c0000042a001b300300340000000d0000110203282c0000060a0204282c0000060b027b0c00000406076f49000006de140c027b0c000004086f6500000a6f4a000006de002a01100000000000001f1f0014070000021b30020037000000\
0e000011140a027b0c000004036f470000060a066f5a00000a260306282e0000060b0307282f0000060728300000060cde0706282d000006dc082a0001100000020002002c2e0007000000002a022c06026f2200000a2a001b3003002f0000000f000011036f4400000a0bde240a72740400700f00fe16080000016f1400000a\
7290040070284300000a0673280000067a072a00011000000000000009090024020000019a032d2272740400700f00fe16080000016f1400000a72d8040070284300000a73270000067a2a001b3004000f01000010000011723e0100700a026f4600000a6f6600000a0d38d5000000096f6700000a741b0000010b0772140500\
706f4a00000a6f1400000a7226050070286800000a39aa0000000672e8020070282e00000a0a026f6900000a6f6600000a13042b6311046f6700000a74160000010c0828310000062c4e0613051c8d0100000113061106161105a21106177230050070a2110618086f6a00000aa21106197234050070a211061a07086f6a0000\
0a6f4a00000aa211061b7238050070a21106286b00000a0a11046f6c00000a2d94de1511047507000001130711072c0711076f1700000adc06727a020070282e00000a0a096f6c00000a3a20ffffffde14097507000001130811082c0711086f1700000adc062a00011c000002005b0070cb00150000000002001200e7f90014\
00000000aa026f6a00000a723c0500701b6f6d00000a2d15026f6a00000a72420500701b6f6d00000a16fe012a162a3a02281c00000a02037d0d0000042a000013300300a50000001100001102032834000006027b0d000004046f470000060a160b066f5900000a1631270717580b07286e00000a03286f00000a287000000a\
2c080628350000062b08066f7100000a2dd9066f2200000a07286e00000a03287200000a287000000a2c451b8d410000010c0816724c050070a208171201287300000aa20818727e050070a208190f01fe16170000016f1400000aa2081a72b0050070a208287400000a73270000067a2a000000033003004f00000000000000\
0316286e00000a287200000a25287000000a2d110f01287500000a287600000a287700000a287000000a2c2272d40500700f01fe16170000016f1400000a7232060070284300000a73270000067a2a001330020029000000120000110228380000060a287800000a06737900000a6f7a00000a02062836000006287800000a6f\
7b00000a2a722b11287800000a020328370000066f7c00000a026f5a00000a2de72a000013300200250000001300001103737900000a0a026f5900000a8d010000010b02076f7d00000a2606076f7e00000a26062a0000001b3003005800000014000011026f4400000a0a0628390000060b076f7f00000a8d180000010c160d\
076f8000000a13052b171205288100000a130408091104283a000006a20917580d1205288200000a2de0de0e1205fe160600001b6f1700000adc082a01100000020024002448000e000000001b3002006600000015000011738300000a0a026f4600000a6f6600000a0c2b35086f6700000a741b0000010b0772140500706f4a\
00000a6f1400000a6f8400000a724e060070286800000a2c0806076f8500000a26086f6c00000a2dc3de110875070000010d092c06096f1700000adc062a000001100000020012004153001100000000133005006f0100001600001102728c0200706f4a00000aa5490000010a02725e0200706f4a00000a74410000010b0272\
580600706f4a00000a74570000010c06130411044523000000050000000d000000050000000d000000050000004b000000050000000500000005000000050000000d0000000500000026000000050000000500000005000000050000000500000005000000050000000500000026000000260000000500000086000000050000\
008600000086000000860000007d0000008600000005000000050000004b0000004b00000038810000000706738600000a2a070602726a0600706f4a00000aa5420000016a738700000a2a02726a0600706f4a00000aa5420000010d0920ff7f00003102150d0706096a738700000a2a07060272800600706f4a00000a288800\
000a288900000a0272a20600706f4a00000a288800000a288900000a738a00000a2a070608738b00000a2a72bc060070068c490000016f1400000a72d2060070284300000a738c00000a7a001330030014000000170000117340000006732a0000060a0602036f2b0000062a1330030014000000180000117340000006733200\
00060a0602036f330000062a133002000e0000001900001173030000060a06026f010000062a000013300200130000001a000011734000000673080000060a06026f090000062a0013300200130000001a000011734000000673080000060a06026f0a0000062a3602281c00000a0228430000062a72027b100000042d0d0228\
4400000602177d1000000402288d00000a2a1e027b0f0000042a9e02738e00000a7d0e000004027b0e000004721a0700706f8f00000a027b0e0000046f1100000a2a32027b0e0000046f9000000a2a0013300200280000001b00001102724c070070282800000a28470000060a066f5a00000a2606166f9100000a0b066f2200\
000a072a32027b0e0000046f9200000a2a00000013300300510000001c000011027e9300000a7d0f000004027b0e00000402fe0648000006739400000a6f9500000a731200000a0a06027b0e0000046f1300000a060f01fe16080000016f1400000a6f1500000a061a6f9600000a0b072a000000033004004400000000000000\
027c0f000004282f00000a2c1002723e010070282800000a7d0f00000402257b0f000004046f9700000a7296070070282e00000a282800000a289800000a7d0f0000042a13300300500000001d000011731200000a0a06027b0e0000046f1300000a06729c0700706f1500000a066f9900000a72ce070070036f9a00000a2606\
6f9900000a72e0070070046f9a00000a26061a6f9b00000a066f1600000a262a133003003e0000001d000011731200000a0a06027b0e0000046f1300000a0672ee0700706f1500000a066f9900000a7204080070036f9a00000a26061a6f9b00000a066f1600000a262a000013300300430000001d000011731200000a0a0602\
7b0e0000046f1300000a0672160800706f1500000a066f9900000a7246080070038c080000016f9a00000a26061a6f9b00000a066f1600000a262a0042534a4201000100000000000c00000076322e302e35303732370000000005006c000000d40e0000237e0000400f00002812000023537472696e67730000000068210000\
5008000023555300b8290000100000002347554944000000c82900008c07000023426c6f620000000000000002000001579fa2090902000000fa25330016000001000000620000000b000000100000004b0000004c000000030000009b0000000800000010000000010000001d00000002000000050000000500000006000000\
01000000040000000100000000000a000100000000000600f100ea000600f800ea0006000201ea000a002d0118010a005201370106006301ea0006006801ea000a00740118010600d101b4010600e301b4010a005f0218010a008b0218010600e302c80206004703c8020a0064034e030a00a20318010600e803ea0006000604\
ea0006006e0464040600800464040a003d050c010a008f050c010a00c50518010a001d0637010a003e0637010e008506c8020a0092060c010a00e5064e030a006d074e0306006e095c09060085095c090600a2095c090600c1095c090600da095c090600f3095c0906000e0a5c090600460a270a06005a0aea000600700a5c09\
0600890a5c090600b70aa40aa700cb0a00000600fa0ada0a06001a0bda0a12004c0b380b12005d0b380b0a00870b740b0a00990b4e030a00b30b740b0600f30be30b0a00050c4e030a00200c740b0600430cea000600600cea000a00760c740b0a00830c37010a009f0c37010600a60c270a0600bc0c270a0600c70c5c090600\
e50c5c090600fa0cea000a002c0d370106003f0dea0006004c0dea0006006b0dea003b00710d00000600a10dea000600c30db70d0e00090eea0d0a00400e0c010a005b0e0c010a009c0e0c010a00c40e18010a00dd0e18010600fe0eea0006003a0fea0006003f0fea0006007d0f6a0f0a00970f0c010600c70fea000a00e30f\
18010a00261037010a00311037016b00710d00000e009010c8020600a910ea000600c310ae100600e410ea000600ec10ea0006000311ea0006001511ea000e0054113e110a0075114e030a00a0110c010a00ca114e030a00f0114e030a000a120c01000000000100000000000100010000001000170027000500010001000120\
100030002700090001000400000010004900270005000100080009011000560027000d0002000c000301000063000000190005002600012010007a00270009000c002600000010009400270005000c002a0000001000ad00270005000d00320081011000bd00270005000e003b0000001000ce00270005000e0040000100f401\
2c0051803d0236005180490246003100f0026a0006069f0446005680a704e8005680af04e8005680be04e8005680ce04e8005680d904e8005680e804e8000100f4012c000100f4012c000100f3068c010100fe06900101000a079401d0200000000086007e010a0001007421000000009100860110000200ce21000000008618\
ae0114000200d621000000008618ae0114000200de21000000008618ae0118000200e721000000008618ae011d000300f121000000008418ae0124000500fb21000000008618ae01300007000a2200000000830007020a00080029220000000083001f020a00090034220000000083002e020a000a0054220000000096005a02\
4e000b006f22000000009600690253000b00882200000000960074024e000b00c822000000009600940258000b001c25000000009600a20263000e006125000000009100fb0272000f0070250000000091000c03770010007a260000000091001d037d0011009f26000000009100270383001300d42600000000910037038800\
14002827000000009100720392001600c82900000000910086039f001800fc290000000091009a03830019001d2a000000009100ae03a7001a00352a000000009100be03a7001b004d2a000000009100d203a7001c00652a000000009100f103ad001d00822a0000000091001504b3001e00942a0000000091002f04b9001f00\
e42a0000000096084104bf002000f02a00000000e6094a04c4002000fc2a0000000096005504c8002000082b00000000c6005b04cf002100142b00000000e6017b04d30021001b2b00000000e6018d04d9002200242b000000009118570f15052300732b000000008618ae01140023007b2b000000008618ae0118002300842b\
000000008618ae011d0024008e2b000000008418ae0124002600982b000000008618ae0130002800a82b000000008600f2040a012900f82b000000008100130512012b004c2c000000009100310518012c00582c00000000910047051e012d00a42c0000000091005f0527012f00cc2c0000000091007d052f013100042e0000\
000091009a05350132002f2e000000008618ae0130003300402e000000008600ce053b013400f42e000000008100f00543013600502f000000009100080618013700852f000000009100290649013800a42f0000000091004c0652013a00d82f0000000091006a065c013c004c300000000091009a0664013d00d03000000000\
9100ae066f013e004c32000000009600f20476013f006c32000000009600ad007e0141008c32000000009600c90686014300a832000000009600d70686014400c8320000000096001f0286014500e732000000008618ae0114004600f53200000000e60113071400460012330000000086081b07970146001a33000000008100\
2b0714004600423300000000810033071400460050330000000086083e07cf00460084330000000086084d07cf00460094330000000086005e079c014600f4330000000084008507a301470044340000000086009307aa014900a034000000008600a00718004b00ec34000000008600be070a004c0000000100f40700000100\
fc0700000100fc0700000200040800000100130800000200180800000100f40100000100f40700000100f40700000100f407000001002008000002002a08000003003608000001004108000001005108000001004108000001005308000002005908000001006008000001002008000002002a08000001006808000002006f08\
000001003608000001008c08000001009708000001009708000001009708000001009708000001009f0800000100a80800000100530800000100b20800000100b40800000100fc0700000100fc0700000200040800000100130800000200180800000100f40100000100b60800000200c60800000100f4070000010068080000\
0100f40700000200680800000100f40700000200d40800000100d40800000100db0800000100f40100000100e20800000200f40700000100e20800000100ee0800000100ee0800000200f90800000100ee0800000200f90800000100ee0800000100d40800000100fe0800000100b60800000200c608000001000c0900000200\
f40700000100f40700000100f40700000100f407000001001809000001002009000002002709000001002c09000002003b0900000100480900000100570905001100050015000b001d00f100ae011800f900ae0118000101ae0118000901ae0118001101ae0118001901ae0118002101ae0118002901ae01b9013101ae01b901\
3901ae0118004101ae0118004901ae01be015901ae01c5016101ae0114006901ae016c02e100ae0118007901940b14008101ae0114008101a40b730209005b04cf008901bd0b18008901cd0b79023900130714007901dd0b14009901ae011400a1013a0c8c02a1014b0ccf000900ae011400b101ae0114001100ae0114001100\
ae0118001100ae011d001100ae012400b901dd0b1400c101ae01a202d101ae01d502e101d00cdc02e101f20ce202e901020de80241000e0dee02e9011a0df40259000e0df902f901ae0114000102440d91030902530d970309025b0d9d0341004a04c4000c00620db0030c007c0db60314008a0dc8030902960d79022102a60d\
cd031400aa0dc4002102b30dcd032902ae01c5012902d10dd3032902dc0dd9032902960d79022902e30de0036100ae010a003102ae0118003102530d19041c000f0e300409021b0e36042902ae0114000902270e470409025b0d4d04b901310e58040c00ae011400a900520e5d044102760e79020902800e63043902620d6804\
d900620d6e040c00870e73042400ae0114002400870e730424008b0e7f04b901930e8504b901a60e8a0481000e0d90047900b20e97047900cf0e9d047900e70ea4045902f40eab0461025b04af047900050fb404b901120fba04b9011b0f7902b9017b04c40031022a0feb048100f40ef70409029f0cfc048900300f02058900\
ae0106055900f40ef40269025b04af047102ae0114001c00ae0114001c00870e190511005e0fcf0041027c0d400579028a0d46050902890f4a05a900ac0f5005b100b80fcf0009025b0d56057902aa0dc4000902d80f7105b9000e0d7905b900ee0f7f059102fa0f8905b9010210c400b9000d107f0511025b04cf0009025b0d\
9005b9004a04c40091020e0d9e0591021910a50599023910b105c900ae01b705a1024210be05a10253101400a1026210be0579007110ca05c9007e10ca052c00760e79022c007c0dde0534008a0dc8033400aa0dc4002c00ae01140009028810cf002c00a1100806c100ae012406c100ae012c06c102cf103506c902fc103b06\
c100ae014306c100ae014d06d902ae011800e10218117a06e100ae011400790129111800e90213071400b9015e117f0679016811cf00410093049001f102ae018a06e100901190068101b0119706e9005e0fcf004100be11a7068101e111b0060103fd11b60689011612be060e000800390008000c00490008001800ec000800\
1c00f10008002000f60008002400fb0008002800000108002c0005012e0023000e072e002b001e072e0073006b072e000b00cb062e001300d9062e001b0008072e004b0029072e006b0062072e00430008072e00330008072e005b002f072e0063005907a3001b01a902c0015b010003e0015b01000300025b01000300000100\
000005007d0292029d02a303e90321043b045404bf04f2040b0521052a05310539055c059605c405d005f0051406580666066b067006750684069f06c506050001000b00030000009304df0000009804e4000000d007b0010000dc07b5010000e707b50102001f00030002002000050002004200070002004500090002004600\
0b00a903c00329047904d705e8050480000001000000f116016b01000000ca01270000000200000000000000000000000100e1000000000002000000000000000000000001000c01000000000200000000000000000000000100ea00000000000200000000000000000000000100380b000000000600050000000000003c4d6f\
64756c653e007453514c74434c522e646c6c00436f6d6d616e644578656375746f72007453514c74434c5200436f6d6d616e644578656375746f72457863657074696f6e004f7574707574436170746f72007453514c7450726976617465004765745374617274506f736974696f6e53746174657300496e76616c6964526573\
756c74536574457863657074696f6e004d65746144617461457175616c697479417373657274657200526573756c7453657446696c7465720053746f72656450726f6365647572657300546573744461746162617365466163616465006d73636f726c69620053797374656d004f626a65637400457863657074696f6e005661\
6c7565547970650053797374656d2e446174610053797374656d2e446174612e53716c547970657300494e756c6c61626c65004d6963726f736f66742e53716c5365727665722e536572766572004942696e61727953657269616c697a6500456e756d0049446973706f7361626c650053716c537472696e6700457865637574\
6500437265617465436f6e6e656374696f6e537472696e67546f436f6e746578744461746162617365002e63746f720053797374656d2e52756e74696d652e53657269616c697a6174696f6e0053657269616c697a6174696f6e496e666f0053747265616d696e67436f6e746578740074657374446174616261736546616361\
646500436170747572654f7574707574546f4c6f675461626c650053757070726573734f75747075740045786563757465436f6d6d616e64004e554c4c5f535452494e47004d41585f434f4c554d4e5f574944544800496e666f0053716c42696e617279005369676e696e674b657900437265617465556e697175654f626a65\
63744e616d650053716c4368617273005461626c65546f537472696e6700476574416c74657253746174656d656e74576974686f7574536368656d6142696e64696e670053797374656d2e436f6c6c656374696f6e732e47656e657269630044696374696f6e6172796032005768697465737061636500497357686974657370\
61636543686172004765745374617274506f736974696f6e00506164436f6c756d6e005472696d546f4d61784c656e6774680067657453716c53746174656d656e74004c69737460310053797374656d2e446174612e53716c436c69656e740053716c44617461526561646572006765745461626c65537472696e6741727261\
790053706c6974436f6c756d6e4e616d654c69737400756e71756f74650053716c4461746554696d650053716c44617465546f537472696e670053716c4461746554696d65546f537472696e6700536d616c6c4461746554696d65546f537472696e67004461746554696d650053716c4461746554696d6532546f537472696e\
67004461746554696d654f66667365740053716c4461746554696d654f6666736574546f537472696e670053716c42696e617279546f537472696e67006765745f4e756c6c006765745f49734e756c6c00506172736500546f537472696e670053797374656d2e494f0042696e61727952656164657200526561640042696e61\
7279577269746572005772697465004e756c6c0049734e756c6c0076616c75655f5f0044656661756c740041667465724669727374446173680041667465725365636f6e6444617368004166746572536c617368004166746572536c617368537461720041667465725374617200417373657274526573756c74536574734861\
766553616d654d6574614461746100637265617465536368656d61537472696e6746726f6d436f6d6d616e6400636c6f736552656164657200446174615461626c6500617474656d7074546f476574536368656d615461626c65007468726f77457863657074696f6e4966536368656d614973456d707479006275696c645363\
68656d61537472696e670044617461436f6c756d6e00636f6c756d6e50726f7065727479497356616c6964466f724d65746144617461436f6d70617269736f6e0053716c496e7433320073656e6453656c6563746564526573756c74536574546f53716c436f6e746578740076616c6964617465526573756c745365744e756d\
6265720073656e64526573756c747365745265636f7264730053716c4d657461446174610073656e64456163685265636f72644f66446174610053716c446174615265636f7264006372656174655265636f7264506f70756c617465645769746844617461006372656174654d65746144617461466f72526573756c74736574\
004c696e6b65644c69737460310044617461526f7700676574446973706c61796564436f6c756d6e730063726561746553716c4d65746144617461466f72436f6c756d6e004e6577436f6e6e656374696f6e00436170747572654f75747075740053716c436f6e6e656374696f6e00636f6e6e656374696f6e00696e666f4d65\
737361676500646973706f73656400446973706f7365006765745f496e666f4d65737361676500636f6e6e65637400646973636f6e6e656374006765745f5365727665724e616d65006765745f44617461626173654e616d650065786563757465436f6d6d616e640053716c496e666f4d6573736167654576656e7441726773\
004f6e496e666f4d65737361676500617373657274457175616c73006661696c5465737443617365416e645468726f77457863657074696f6e006c6f6743617074757265644f757470757400496e666f4d657373616765005365727665724e616d650044617461626173654e616d6500636f6d6d616e64006d65737361676500\
696e6e6572457863657074696f6e00696e666f00636f6e74657874005461626c654e616d65004f726465724f7074696f6e00436f6c756d6e4c6973740063726561746553746174656d656e74006300696e707574006c656e67746800726f774461746100726561646572005072696e744f6e6c79436f6c756d6e4e616d65416c\
6961734c69737400636f6c756d6e4e616d6500647456616c75650064746f56616c75650073716c42696e61727900720077006578706563746564436f6d6d616e640061637475616c436f6d6d616e6400736368656d6100636f6c756d6e00726573756c747365744e6f0064617461526561646572006d65746100636f6c756d6e\
44657461696c7300726573756c745365744e6f00436f6d6d616e640073656e6465720061726773006578706563746564537472696e670061637475616c537472696e67006661696c7572654d65737361676500746578740053797374656d2e5265666c656374696f6e00417373656d626c795469746c65417474726962757465\
00417373656d626c794465736372697074696f6e41747472696275746500417373656d626c79436f6e66696775726174696f6e41747472696275746500417373656d626c79436f6d70616e7941747472696275746500417373656d626c7950726f6475637441747472696275746500417373656d626c7954726164656d61726b\
41747472696275746500417373656d626c7943756c747572654174747269627574650053797374656d2e52756e74696d652e496e7465726f70536572766963657300436f6d56697369626c6541747472696275746500434c53436f6d706c69616e7441747472696275746500417373656d626c7956657273696f6e4174747269\
6275746500417373656d626c79436f707972696768744174747269627574650053797374656d2e446961676e6f73746963730044656275676761626c6541747472696275746500446562756767696e674d6f6465730053797374656d2e52756e74696d652e436f6d70696c6572536572766963657300436f6d70696c6174696f\
6e52656c61786174696f6e734174747269627574650052756e74696d65436f6d7061746962696c6974794174747269627574650053797374656d2e5472616e73616374696f6e73005472616e73616374696f6e53636f7065005472616e73616374696f6e53636f70654f7074696f6e0053797374656d2e446174612e436f6d6d\
6f6e004462436f6e6e656374696f6e004f70656e0053716c436f6d6d616e64007365745f436f6e6e656374696f6e004462436f6d6d616e64007365745f436f6d6d616e645465787400457865637574654e6f6e517565727900436c6f73650053797374656d2e5365637572697479005365637572697479457863657074696f6e\
0053716c436f6e6e656374696f6e537472696e674275696c646572004462436f6e6e656374696f6e537472696e674275696c646572007365745f4974656d00426f6f6c65616e006765745f436f6e6e656374696f6e537472696e670053657269616c697a61626c65417474726962757465004462446174615265616465720053\
716c55736572446566696e65645479706541747472696275746500466f726d6174005374727563744c61796f7574417474726962757465004c61796f75744b696e6400417373656d626c7900476574457865637574696e67417373656d626c7900417373656d626c794e616d65004765744e616d650056657273696f6e006765\
745f56657273696f6e006f705f496d706c69636974004765745075626c69634b6579546f6b656e0053716c4d6574686f644174747269627574650047756964004e65774775696400537472696e67005265706c61636500436f6e636174006765745f4974656d00496e74333200456e756d657261746f7200476574456e756d65\
7261746f72006765745f43757272656e74006765745f4c656e677468004d617468004d6178004d6f76654e657874004d696e0053797374656d2e5465787400537472696e674275696c64657200417070656e644c696e6500417070656e6400496e736572740053797374656d2e546578742e526567756c617245787072657373\
696f6e7300526567657800436f6e7461696e734b657900546f43686172417272617900537562737472696e6700476574536368656d615461626c650044617461526f77436f6c6c656374696f6e006765745f526f777300496e7465726e616c44617461436f6c6c656374696f6e42617365006765745f436f756e740045717561\
6c730041646400546f417272617900497344424e756c6c0053716c446254797065004765744461746554696d65004765744461746554696d654f66667365740053716c446563696d616c0047657453716c446563696d616c0053716c446f75626c650047657453716c446f75626c65006765745f56616c756500446f75626c65\
0047657453716c42696e6172790047657456616c7565006765745f4669656c64436f756e740053706c6974006765745f5469636b730042797465004e6f74496d706c656d656e746564457863657074696f6e002e6363746f72006765745f4d6573736167650053797374656d2e436f6c6c656374696f6e730049456e756d6572\
61746f72006f705f496e657175616c6974790044617461436f6c756d6e436f6c6c656374696f6e006765745f436f6c756d6e73006765745f436f6c756d6e4e616d6500537472696e67436f6d70617269736f6e00537461727473576974680053716c426f6f6c65616e006f705f457175616c697479006f705f54727565004e65\
7874526573756c74006f705f4c6573735468616e006f705f426974776973654f720053716c436f6e746578740053716c50697065006765745f506970650053656e64526573756c747353746172740053656e64526573756c7473456e640053656e64526573756c7473526f770047657453716c56616c7565730053657456616c\
75657300546f4c6f776572004c696e6b65644c6973744e6f64656031004164644c61737400547970650053797374656d2e476c6f62616c697a6174696f6e0043756c74757265496e666f006765745f496e76617269616e7443756c7475726500436f6e766572740049466f726d617450726f766964657200546f427974650041\
7267756d656e74457863657074696f6e00474300537570707265737346696e616c697a65007365745f436f6e6e656374696f6e537472696e670053797374656d2e436f6d706f6e656e744d6f64656c00436f6d706f6e656e7400476574537472696e67006765745f44617461626173650053716c496e666f4d65737361676545\
76656e7448616e646c6572006164645f496e666f4d65737361676500436f6d6d616e644265686176696f720045786563757465526561646572006f705f4164646974696f6e0053716c506172616d65746572436f6c6c656374696f6e006765745f506172616d65746572730053716c506172616d657465720041646457697468\
56616c756500436f6d6d616e6454797065007365745f436f6d6d616e64547970650000000080b34500720072006f007200200063006f006e006e0065006300740069006e006700200074006f002000640061007400610062006100730065002e00200059006f00750020006d006100790020006e00650065006400200074006f\
00200063007200650061007400650020007400530051004c007400200061007300730065006d0062006c007900200077006900740068002000450058005400450052004e0041004c005f004100430043004500530053002e0000174400610074006100200053006f007500720063006500002749006e00740065006700720061\
00740065006400200053006500630075007200690074007900001f49006e0069007400690061006c00200043006100740061006c006f00670000237400530051004c0074005f00740065006d0070006f0062006a006500630074005f0000032d00010100354f0062006a0065006300740020006e0061006d0065002000630061\
006e006e006f00740020006200650020004e0055004c004c0000037c0000032b0000634300520045004100540045005c0073002b00560049004500570028005c0073002a002e002a003f005c0073002a00290057004900540048005c0073002b0053004300480045004d004100420049004e00440049004e0047005c0073002b\
0041005300001d41004c00540045005200200056004900450057002400310041005300001975006e006500780070006500630074006500640020002f0000032000000b3c002e002e002e003e00001d530045004c0045004300540020002a002000460052004f004d002000001520004f00520044004500520020004200590020\
00001543006f006c0075006d006e004e0061006d00650000055d005d0000035d00000d21004e0055004c004c0021000019500072006f00760069006400650072005400790070006500002930002e0030003000300030003000300030003000300030003000300030003000300045002b00300000055d002c0000052c005b0000\
0b5c005d002c005c005b0000035b00001d7b0030003a0079007900790079002d004d004d002d00640064007d0001377b0030003a0079007900790079002d004d004d002d00640064002000480048003a006d006d003a00730073002e006600660066007d0001297b0030003a0079007900790079002d004d004d002d00640064\
002000480048003a006d006d007d00013f7b0030003a0079007900790079002d004d004d002d00640064002000480048003a006d006d003a00730073002e0066006600660066006600660066007d0001477b0030003a0079007900790079002d004d004d002d00640064002000480048003a006d006d003a00730073002e0066\
0066006600660066006600660020007a007a007a007d0001053000780000055800320000737400530051004c007400500072006900760061007400650020006900730020006e006f007400200069006e00740065006e00640065006400200074006f002000620065002000750073006500640020006f00750074007300690064\
00650020006f00660020007400530051004c0074002100001b540068006500200063006f006d006d0061006e00640020005b0000475d00200064006900640020006e006f0074002000720065007400750072006e00200061002000760061006c0069006400200072006500730075006c0074002000730065007400003b5d0020\
0064006900640020006e006f0074002000720065007400750072006e0020006100200072006500730075006c0074002000730065007400001149007300480069006400640065006e000009540072007500650000037b0000033a0000037d0000054900730000094200610073006500003145007800650063007500740069006f\
006e002000720065007400750072006e006500640020006f006e006c00790020000031200052006500730075006c00740053006500740073002e00200052006500730075006c00740053006500740020005b0000235d00200064006f006500730020006e006f0074002000650078006900730074002e00005d52006500730075\
006c007400530065007400200069006e00640065007800200062006500670069006e007300200061007400200031002e00200052006500730075006c007400530065007400200069006e0064006500780020005b00001b5d00200069007300200069006e00760061006c00690064002e00000974007200750065000011440061\
00740061005400790070006500001543006f006c0075006d006e00530069007a00650000214e0075006d00650072006900630050007200650063006900730069006f006e0000194e0075006d0065007200690063005300630061006c006500001541007200670075006d0065006e00740020005b0000475d0020006900730020\
006e006f0074002000760061006c0069006400200066006f007200200052006500730075006c007400530065007400460069006c007400650072002e00003143006f006e007400650078007400200043006f006e006e0065006300740069006f006e003d0074007200750065003b000049530045004c00450043005400200053\
0045005200560045005200500052004f0050004500520054005900280027005300650072007600650072004e0061006d006500270029003b0001050d000a0000317400530051004c0074002e0041007300730065007200740045007100750061006c00730053007400720069006e006700001145007800700065006300740065\
006400000d410063007400750061006c0000157400530051004c0074002e004600610069006c0000114d006500730073006100670065003000002f7400530051004c0074002e004c006f006700430061007000740075007200650064004f0075007400700075007400000974006500780074000005de9afb029ce74ba9dc99da\
f9484ead0008b77a5c561934e0890520010111210300000e03200001042001010e062002010e120907200201122511290306122c05200101122c02060e0c21004e0055004c004c002100020608049b0000000400001121040000112d0a0003123111211121112106000112311121070615123502030204000102030500010811\
210500020e0e080400010e0e0900020e1011211011210c0002151239011d0e123d11210700011d0e1011210500010e11410500010e11450500010e11490500010e112d040000111403200002060001111411210320000e05200101124d0520010112510408001114032800020306111804000000000401000000040200000004\
030000000404000000040500000007200201112111210520010e112105000101123d08000212551121123d07000201112112550500010e125505000102125907200201115d112105200101115d08000201123d1d12610900021265123d1d12610700011d1261123d0a000115126901126d12550600011261126d070002011121\
112107000201115d112105000101112103061271030611210206020420001121062001123d1121062002011c1275052002010e0e04280011210328000e0420010102062001011180a9042001010880a00024000004800000940000000602000000240000525341310004000001000100f7d9a45f2b508c2887a8794b053ce5de\
b28743b7c748ff545f1f51218b684454b785054629c1417d1d3542b095d80ba171294948fcf978a502aa03240c024746b563bc29b4d8dcd6956593c0c425446021d699ef6fb4dc2155de7e393150ad6617edc01216ea93fce5f8f7be9ff605ad2b8344e8cc01bedb924ed06fd368d1d0062001011180b9052001011271032000\
080e070512711280b50e1280c11280c9052002010e1c0a0705122c0e0e1280cd0e040701123d062001011180e52b010002000000020054080b4d61784279746553697a650100000054020d497346697865644c656e67746801062001011180ed0500001280f10520001280f50520001280f905000111210e0420001d05060001\
112d1d05808f010001005455794d6963726f736f66742e53716c5365727665722e5365727665722e446174614163636573734b696e642c2053797374656d2e446174612c2056657273696f6e3d322e302e302e302c2043756c747572653d6e65757472616c2c205075626c69634b6579546f6b656e3d62373761356335363139\
3334653038390a44617461416363657373010000000500001181010520020e0e0e0500020e0e0e05070111810106151239011d0e0520011300080920001511810d011300071511810d011d0e04200013000500020808080520001281150620011281150e082003128115080e082f0714122c0e123d151239011d0e081d081d0e\
08080808021281151d0e08081511810d011d0e1d08081511810d011d0e0720040e0e0e0808070703081281190e061512350203020520010213000420001d030b07061d03081118080811180520020e08080600030e0e0e0e0307010e042000125505200012811d042001020e052001126d080420011c0e052001011300051512\
39010e0520001d13000420010208052001114508060001114111450520011149080620011181290806200111812d080320000d0420010e0e052001112d080420011c082b07121255151239011d0e081d0e08126d1d0e151239010e0e1d0e081181251d0e0811812511812911812d0d0600021d0e0e0e0407011d0e0420001145\
0500020e0e1c0320000a042001010a090704128115051d05080300000107200201130013010807011512350203020607030e0e121c070703123d12550e0607021209125505200012813d0320001c050002020e0e0520001281410500010e1d1c1407090e126d125912813d12813d1c1d1c121d121d072002020e118145050001\
115d08090002118149115d115d060001021181490500010e1d0e070703123d081d0e060001118149020b0002118149118149118149050000128151062001011d12610520010112650507011d1261052001081d1c06070212651d1c0615126901126d09200015118155011300071511815501126d170706125515126901126d1d\
126108126d1511815501126d0b20011512815901130013000f070415126901126d126d12813d121d072002010e118125082003010e1181250a050000128161070002051c128169092004010e11812505050a2003010e11812512815d0d07051181250e12815d0811812504070112200407011224040701120804070112100400\
01011c0420010e08050702123d0e052002011c1806200101128179072001123d11817d0707021280c1123d0800021121112111210520001281810720021281850e1c062001011181890507011280c10d0100087453514c74434c5200002e010029434c527320666f7220746865207453514c7420756e69742074657374696e67\
206672616d65776f726b00000501000000000f01000a73716c6974792e6e657400000a0100057453514c74000005010001000029010024436f7079726967687420c2a9202073716c6974792e6e65742032303130202d203230313500000801000200000000000801000800000000001e01000100540216577261704e6f6e4578\
63657074696f6e5468726f7773010000000000005219ad5600000000020000001c010000ac660000ac48000052534453683bab7f3d6d534a9e23408f5ca7f1a701000000633a5c5465616d436974795c6275696c644167656e745c776f726b5c666264353737636331386432383966385c7453514c74434c525c7453514c7443\
4c525c6f626a5c437275697365436f6e74726f6c5c7453514c74434c522e7064620000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f067000000000000000000000e68000000200000000000000000000000000000000000000000000000680000000000000000000000000000\
00005f436f72446c6c4d61696e006d73636f7265652e646c6c0000000000ff25002000100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
00000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058800000a00300000000000000000000a00334000000560053005f00560045005200530049004f004e005f0049004e0046004f0000000000\
bd04effe0000010000000100016bf11600000100016bf1163f000000000000000400000002000000000000000000000000000000440000000100560061007200460069006c00650049006e0066006f00000000002400040000005400720061006e0073006c006100740069006f006e00000000000000b0040003000001005300\
7400720069006e006700460069006c00650049006e0066006f000000dc02000001003000300030003000300034006200300000006c002a00010043006f006d006d0065006e0074007300000043004c0052007300200066006f007200200074006800650020007400530051004c007400200075006e0069007400200074006500\
7300740069006e00670020006600720061006d00650077006f0072006b00000038000b00010043006f006d00700061006e0079004e0061006d00650000000000730071006c006900740079002e006e0065007400000000003c0009000100460069006c0065004400650073006300720069007000740069006f006e0000000000\
7400530051004c00740043004c0052000000000040000f000100460069006c006500560065007200730069006f006e000000000031002e0030002e0035003800370033002e0032003700330039003300000000003c000d00010049006e007400650072006e0061006c004e0061006d00650000007400530051004c0074004300\
4c0052002e0064006c006c00000000006c00240001004c006500670061006c0043006f007000790072006900670068007400000043006f0070007900720069006700680074002000a90020002000730071006c006900740079002e006e00650074002000320030003100300020002d0020003200300031003500000044000d00\
01004f0072006900670069006e0061006c00460069006c0065006e0061006d00650000007400530051004c00740043004c0052002e0064006c006c00000000002c0006000100500072006f0064007500630074004e0061006d006500000000007400530051004c007400000044000f000100500072006f006400750063007400\
560065007200730069006f006e00000031002e0030002e0035003800370033002e00320037003300390033000000000048000f00010041007300730065006d0062006c0079002000560065007200730069006f006e00000031002e0030002e0035003800370033002e0032003700330039003300000000000000000000000000\
006000000c000000203800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\
0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000

WITH PERMISSION_SET=EXTERNAL_ACCESS
GO
PRINT N'Creating types'
GO
CREATE TYPE [dbo].[ud_Id] AS TABLE
(
[Id] [bigint] NULL
)
GO
CREATE TYPE [tSQLt].[AssertStringTable] AS TABLE
(
[value] [nvarchar] (max) NULL
)
GO
CREATE TYPE [dbo].[TSTRINGA] FROM varchar (8000) NULL
GO
CREATE TYPE [tSQLt].[Private]
EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.tSQLtPrivate]
GO
CREATE TYPE [dbo].[TCONTEXT] FROM nvarchar (4000) NULL
GO
CREATE TYPE [dbo].[TBIGSTRING] FROM nvarchar (max) NULL
GO
CREATE TYPE [dbo].[TSTRING] FROM nvarchar (4000) NULL
GO
CREATE TYPE [dbo].[TJSON] FROM nvarchar (max) NULL
GO
CREATE TYPE [dbo].[ud_LogFilter] AS TABLE
(
[LogId] [bigint] NULL,
[CategoryId] [int] NULL,
[SubCategoryId] [int] NULL,
[CustomData] [dbo].[TJSON] NULL,
[CreatedTime] [datetime] NULL
)
GO
PRINT N'Creating [tSQLt].[Private_NullCellTable]'
GO
CREATE TABLE [tSQLt].[Private_NullCellTable]
(
[I] [int] NULL
)
GO
PRINT N'Creating trigger [tSQLt].[Private_NullCellTable_StopDeletes] on [tSQLt].[Private_NullCellTable]'
GO
CREATE TRIGGER [tSQLt].[Private_NullCellTable_StopDeletes] ON [tSQLt].[Private_NullCellTable] INSTEAD OF DELETE, INSERT, UPDATE
AS
BEGIN
  RETURN;
END;
GO
PRINT N'Creating [dsp].[LogUser]'
GO
CREATE TABLE [dsp].[LogUser]
(
[UserName] [nvarchar] (100) NOT NULL,
[IsEnabled] [bit] NOT NULL CONSTRAINT [DF_LogUser_IsEnabled] DEFAULT ((0))
)
GO
PRINT N'Creating primary key [PK__LogUser__C9F28457D1B75C41] on [dsp].[LogUser]'
GO
ALTER TABLE [dsp].[LogUser] ADD CONSTRAINT [PK__LogUser__C9F28457D1B75C41] PRIMARY KEY CLUSTERED  ([UserName])
GO
PRINT N'Creating [dsp].[LogFilterSetting]'
GO
CREATE TABLE [dsp].[LogFilterSetting]
(
[LogFilterSettingId] [int] NOT NULL IDENTITY(1, 1),
[UserName] [nvarchar] (100) NOT NULL,
[IsExludedFilter] [bit] NOT NULL CONSTRAINT [DF_LogFilter_IsExludedFilter] DEFAULT ((0)),
[Log_Filter] [nvarchar] (2000) NULL
)
GO
PRINT N'Creating primary key [PK__LogFilte__7B08B2A3AD695576] on [dsp].[LogFilterSetting]'
GO
ALTER TABLE [dsp].[LogFilterSetting] ADD CONSTRAINT [PK__LogFilte__7B08B2A3AD695576] PRIMARY KEY CLUSTERED  ([LogFilterSettingId])
GO
PRINT N'Creating [dsp].[AppVersion]'
GO
CREATE TABLE [dsp].[AppVersion]
(
[AppVersionId] [int] NOT NULL IDENTITY(1, 1),
[VersionNumber] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_AppVersion_CreatedTime] DEFAULT (getdate()),
[StartTime] [datetime2] NOT NULL CONSTRAINT [DF__AppVersio__Start__2421696F] DEFAULT (getutcdate()),
[EndTime] [datetime2] NOT NULL CONSTRAINT [DF__AppVersio__EndTi__25158DA8] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0))),
[VersioningStartTime] [datetime2] NOT NULL CONSTRAINT [DF__AppVersio__Versi__13674C79] DEFAULT (getutcdate()),
[VersioningEndTime] [datetime2] NOT NULL CONSTRAINT [DF__AppVersio__Versi__145B70B2] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0)))
)
GO
PRINT N'Creating primary key [PK_AppVersion] on [dsp].[AppVersion]'
GO
ALTER TABLE [dsp].[AppVersion] ADD CONSTRAINT [PK_AppVersion] PRIMARY KEY CLUSTERED  ([AppVersionId])
GO
PRINT N'Creating [dsp].[AppVersionDetail]'
GO
CREATE TABLE [dsp].[AppVersionDetail]
(
[AppVersionDetailId] [int] NOT NULL IDENTITY(1, 1),
[AppVersionId] [int] NOT NULL,
[StoredProcedureId] [int] NOT NULL,
[StoredProcedureName] [nvarchar] (256) NOT NULL,
[StoredProcedurePhysicalName] [nvarchar] (256) NOT NULL,
[SchemaName] [nvarchar] (50) NOT NULL,
[StoredProcedureVersionNumber] [int] NULL,
[ExpirationTime] [datetime] NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_AppVersionDetail_CreatedTime] DEFAULT (getdate())
)
GO
PRINT N'Creating primary key [PK_AppVersionDetail] on [dsp].[AppVersionDetail]'
GO
ALTER TABLE [dsp].[AppVersionDetail] ADD CONSTRAINT [PK_AppVersionDetail] PRIMARY KEY CLUSTERED  ([AppVersionDetailId])
GO
PRINT N'Creating [dbo].[Users]'
GO
CREATE TABLE [dbo].[Users]
(
[UserId] [int] NOT NULL IDENTITY(1, 1),
[AuthUserId] [int] NULL,
[IsEnabled] [bit] NOT NULL CONSTRAINT [DF_Users_IsEnabled] DEFAULT ((1)),
[ModifiedByUserId] [int] NULL,
[SysStartTime] [datetime2] NOT NULL CONSTRAINT [DF_UsersSysStartTime] DEFAULT (sysutcdatetime()),
[SysEndTime] [datetime2] NOT NULL CONSTRAINT [DF_UsersSysEndTime] DEFAULT ('9999.12.31 23:59:59.99'),
[MoneyTransactionCountModeId] [tinyint] NULL,
[ModifiedTime] [datetime] NULL
)
GO
PRINT N'Creating primary key [PK_Users] on [dbo].[Users]'
GO
ALTER TABLE [dbo].[Users] ADD CONSTRAINT [PK_Users] PRIMARY KEY CLUSTERED  ([UserId])
GO
PRINT N'Creating index [IX_AuthUserId] on [dbo].[Users]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_AuthUserId] ON [dbo].[Users] ([AuthUserId])
GO
PRINT N'Creating [dbo].[AuthUser]'
GO
CREATE TABLE [dbo].[AuthUser]
(
[AuthUserId] [int] NOT NULL,
[UserName] [varchar] (100) NULL,
[NationalNumber] [char] (10) NULL,
[Email] [nvarchar] (40) NULL,
[Mobile] [varchar] (13) NULL,
[FirstName] [nvarchar] (100) NULL,
[LastName] [nvarchar] (100) NULL,
[GenderId] [tinyint] NULL,
[Birthdate] [date] NULL,
[AddressProvinceId] [int] NULL,
[AddressStreet] [nvarchar] (max) NULL,
[AddressPostalCode] [char] (10) NULL,
[IsEnabled] [bit] NOT NULL CONSTRAINT [DF_AuthUser_IsEnabled] DEFAULT ((1)),
[Description] [nvarchar] (max) NULL,
[RecordVersion] [varbinary] (8) NOT NULL,
[CreatedByUserId] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_AuthUser_CreatedTime] DEFAULT (getdate()),
[ModifiedByUserId] [int] NULL,
[ModifiedTime] [datetime] NULL,
[AddressDistrictId] [int] NULL
)
GO
PRINT N'Creating primary key [PK_AuthUser] on [dbo].[AuthUser]'
GO
ALTER TABLE [dbo].[AuthUser] ADD CONSTRAINT [PK_AuthUser] PRIMARY KEY CLUSTERED  ([AuthUserId])
GO
PRINT N'Creating index [IX_Mobile] on [dbo].[AuthUser]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_Mobile] ON [dbo].[AuthUser] ([Mobile]) WHERE ([Mobile] IS NOT NULL)
GO
PRINT N'Creating index [IX_NationalNumber] on [dbo].[AuthUser]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_NationalNumber] ON [dbo].[AuthUser] ([NationalNumber]) WHERE ([NationalNumber] IS NOT NULL)
GO
PRINT N'Creating [dsp].[StringTable]'
GO
CREATE TABLE [dsp].[StringTable]
(
[StringId] [nvarchar] (100) NOT NULL,
[StringValue] [nvarchar] (max) NOT NULL,
[LocaleName] [nvarchar] (10) NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_StringTable_Name] on [dsp].[StringTable]'
GO
ALTER TABLE [dsp].[StringTable] ADD CONSTRAINT [PK_StringTable_Name] PRIMARY KEY CLUSTERED  ([StringId])
GO
PRINT N'Creating [dsp].[Exception]'
GO
CREATE TABLE [dsp].[Exception]
(
[ExceptionId] [int] NOT NULL,
[ExceptionName] [nvarchar] (100) NOT NULL,
[StringId] [nvarchar] (100) NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_Exception] on [dsp].[Exception]'
GO
ALTER TABLE [dsp].[Exception] ADD CONSTRAINT [PK_Exception] PRIMARY KEY CLUSTERED  ([ExceptionId])
GO
PRINT N'Creating [dspInboxMessage].[ProviderInfo]'
GO
CREATE TABLE [dspInboxMessage].[ProviderInfo]
(
[ProviderInfoId] [int] NOT NULL,
[ProviderId] [int] NOT NULL,
[ContactInfo] [nvarchar] (200) NOT NULL,
[IsEnable] [bit] NOT NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_ProviderInfo] on [dspInboxMessage].[ProviderInfo]'
GO
ALTER TABLE [dspInboxMessage].[ProviderInfo] ADD CONSTRAINT [PK_ProviderInfo] PRIMARY KEY CLUSTERED  ([ProviderInfoId])
GO
PRINT N'Creating [dspInboxMessage].[InboxMessage]'
GO
CREATE TABLE [dspInboxMessage].[InboxMessage]
(
[InboxMessageId] [bigint] NOT NULL IDENTITY(1, 1),
[MessageRefrenceNumber] [nvarchar] (50) NULL,
[Address] [nvarchar] (500) NOT NULL,
[MessageBody] [nvarchar] (1000) NOT NULL,
[MessageTime] [datetime] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_InboxProc_CreatedTime_Default] DEFAULT (getdate()),
[MessagePatternId] [int] NULL,
[ProviderInfoId] [int] NOT NULL,
[MessageServerCreatedTime] [datetime] NOT NULL,
[MessageServerInboxNumber] [bigint] NOT NULL,
[InboxMessageProcessStateId] [tinyint] NOT NULL,
[ProcessStartTime] [datetime] NULL,
[ProcessEndTime] [datetime] NULL,
[Error] [nvarchar] (4000) NULL
)
GO
PRINT N'Creating primary key [PK_InboxProcessedMessage] on [dspInboxMessage].[InboxMessage]'
GO
ALTER TABLE [dspInboxMessage].[InboxMessage] ADD CONSTRAINT [PK_InboxProcessedMessage] PRIMARY KEY CLUSTERED  ([InboxMessageId])
GO
PRINT N'Creating index [IX_Address_InboxMessageProcessStateId5] on [dspInboxMessage].[InboxMessage]'
GO
CREATE NONCLUSTERED INDEX [IX_Address_InboxMessageProcessStateId5] ON [dspInboxMessage].[InboxMessage] ([Address]) WHERE ([InboxMessageProcessStateId]=(5))
GO
PRINT N'Creating index [IX_AddressMessageTime_InboxMessageProcessStateId1] on [dspInboxMessage].[InboxMessage]'
GO
CREATE NONCLUSTERED INDEX [IX_AddressMessageTime_InboxMessageProcessStateId1] ON [dspInboxMessage].[InboxMessage] ([Address]) WHERE ([InboxMessageProcessStateId]=(1))
GO
PRINT N'Creating index [IX_MessageServerInboxId] on [dspInboxMessage].[InboxMessage]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_MessageServerInboxId] ON [dspInboxMessage].[InboxMessage] ([MessageServerInboxNumber])
GO
PRINT N'Creating [dspInboxMessage].[MessagePattern]'
GO
CREATE TABLE [dspInboxMessage].[MessagePattern]
(
[MessagePatternId] [int] NOT NULL IDENTITY(1, 1),
[PatternName] [nvarchar] (200) NOT NULL,
[StartTime] [datetime] NOT NULL,
[ExpirationTime] [datetime] NOT NULL,
[MessagePatternSepratorId] [int] NOT NULL,
[PatternKey] [nvarchar] (200) NOT NULL,
[MessagePatternStateId] [int] NOT NULL,
[ResponseProcedureSchemaName] [nvarchar] (50) NOT NULL,
[ResponseProcedureName] [nvarchar] (1000) NOT NULL,
[IsDeleted] [bit] NOT NULL CONSTRAINT [DF_MessagePattern_IsDeleted] DEFAULT ((0)),
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_MessagePattern] on [dspInboxMessage].[MessagePattern]'
GO
ALTER TABLE [dspInboxMessage].[MessagePattern] ADD CONSTRAINT [PK_MessagePattern] PRIMARY KEY CLUSTERED  ([MessagePatternId])
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessState]'
GO
CREATE TABLE [dspInboxMessage].[InboxMessageProcessState]
(
[InboxMessageProcessStateId] [tinyint] NOT NULL,
[InboxMessageProcessState] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_ProcessState] on [dspInboxMessage].[InboxMessageProcessState]'
GO
ALTER TABLE [dspInboxMessage].[InboxMessageProcessState] ADD CONSTRAINT [PK_ProcessState] PRIMARY KEY CLUSTERED  ([InboxMessageProcessStateId])
GO
PRINT N'Creating [dbo].[Application]'
GO
CREATE TABLE [dbo].[Application]
(
[ApplicationId] [int] NOT NULL,
[ApplicationName] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_Applications] on [dbo].[Application]'
GO
ALTER TABLE [dbo].[Application] ADD CONSTRAINT [PK_Applications] PRIMARY KEY CLUSTERED  ([ApplicationId])
GO
PRINT N'Creating [dbo].[Logs]'
GO
CREATE TABLE [dbo].[Logs]
(
[LogId] [bigint] NOT NULL IDENTITY(1, 1),
[ApplicationId] [int] NOT NULL,
[CategoryId] [int] NULL,
[SubCategoryId] [bigint] NULL,
[CustomData] [nvarchar] (max) NULL,
[CreatedByUserId] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL
)
GO
PRINT N'Creating primary key [PK_Logs] on [dbo].[Logs]'
GO
ALTER TABLE [dbo].[Logs] ADD CONSTRAINT [PK_Logs] PRIMARY KEY CLUSTERED  ([LogId])
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternSeprator]'
GO
CREATE TABLE [dspInboxMessage].[MessagePatternSeprator]
(
[MessagePatternSepratorId] [int] NOT NULL,
[MessagePatternSeprator] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_MessagePatternSeprator] on [dspInboxMessage].[MessagePatternSeprator]'
GO
ALTER TABLE [dspInboxMessage].[MessagePatternSeprator] ADD CONSTRAINT [PK_MessagePatternSeprator] PRIMARY KEY CLUSTERED  ([MessagePatternSepratorId])
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternState]'
GO
CREATE TABLE [dspInboxMessage].[MessagePatternState]
(
[MessagePatternStateId] [int] NOT NULL,
[MessagePatternStateName] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_MessagePatternState] on [dspInboxMessage].[MessagePatternState]'
GO
ALTER TABLE [dspInboxMessage].[MessagePatternState] ADD CONSTRAINT [PK_MessagePatternState] PRIMARY KEY CLUSTERED  ([MessagePatternStateId])
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep]'
GO
CREATE TABLE [dspInboxMessage].[MessagePatternStep]
(
[MessagePatternStepId] [int] NOT NULL IDENTITY(1, 1),
[MessagePatternId] [int] NOT NULL,
[MessagePatternStepTypeId] [tinyint] NOT NULL,
[ParameterName] [nvarchar] (300) NULL,
[SendMessageValue] [nvarchar] (4000) NULL,
[Order] [int] NOT NULL,
[DefaultValue] [nvarchar] (4000) NULL,
[Description] [nvarchar] (max) NULL,
[ConfirmHasCustomValidation] [bit] NULL,
[HasCustomValue] [bit] NULL
)
GO
PRINT N'Creating primary key [PK_MessagePatternSteps] on [dspInboxMessage].[MessagePatternStep]'
GO
ALTER TABLE [dspInboxMessage].[MessagePatternStep] ADD CONSTRAINT [PK_MessagePatternSteps] PRIMARY KEY CLUSTERED  ([MessagePatternStepId])
GO
PRINT N'Creating index [IX_MessagePatternStep_MessagePatternId] on [dspInboxMessage].[MessagePatternStep]'
GO
CREATE NONCLUSTERED INDEX [IX_MessagePatternStep_MessagePatternId] ON [dspInboxMessage].[MessagePatternStep] ([MessagePatternId]) INCLUDE ([Order])
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStepType]'
GO
CREATE TABLE [dspInboxMessage].[MessagePatternStepType]
(
[MessagePatternStepTypeId] [tinyint] NOT NULL,
[MessagePatternStepType] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_MessagePatternStepType] on [dspInboxMessage].[MessagePatternStepType]'
GO
ALTER TABLE [dspInboxMessage].[MessagePatternStepType] ADD CONSTRAINT [PK_MessagePatternStepType] PRIMARY KEY CLUSTERED  ([MessagePatternStepTypeId])
GO
PRINT N'Creating [dspAuth].[Permission]'
GO
CREATE TABLE [dspAuth].[Permission]
(
[PermissionId] [smallint] NOT NULL,
[PermissionName] [varchar] (100) NOT NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_Permission] on [dspAuth].[Permission]'
GO
ALTER TABLE [dspAuth].[Permission] ADD CONSTRAINT [PK_Permission] PRIMARY KEY CLUSTERED  ([PermissionId])
GO
PRINT N'Adding constraints to [dspAuth].[Permission]'
GO
ALTER TABLE [dspAuth].[Permission] ADD CONSTRAINT [IX_PermissionName] UNIQUE NONCLUSTERED  ([PermissionName])
GO
PRINT N'Creating [dspAuth].[PermissionGroupPermission]'
GO
CREATE TABLE [dspAuth].[PermissionGroupPermission]
(
[PermissionGroupId] [smallint] NOT NULL,
[PermissionId] [smallint] NOT NULL
)
GO
PRINT N'Creating primary key [PK_PermissionGroupPermission] on [dspAuth].[PermissionGroupPermission]'
GO
ALTER TABLE [dspAuth].[PermissionGroupPermission] ADD CONSTRAINT [PK_PermissionGroupPermission] PRIMARY KEY CLUSTERED  ([PermissionGroupId], [PermissionId])
GO
PRINT N'Creating [dspAuth].[PermissionGroup]'
GO
CREATE TABLE [dspAuth].[PermissionGroup]
(
[PermissionGroupId] [smallint] NOT NULL,
[PermissionGroupName] [varchar] (100) NOT NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_PermissionGroupId] on [dspAuth].[PermissionGroup]'
GO
ALTER TABLE [dspAuth].[PermissionGroup] ADD CONSTRAINT [PK_PermissionGroupId] PRIMARY KEY CLUSTERED  ([PermissionGroupId])
GO
PRINT N'Creating [dspInboxMessage].[ProviderType]'
GO
CREATE TABLE [dspInboxMessage].[ProviderType]
(
[ProviderTypeId] [tinyint] NOT NULL,
[ProviderType] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_ProviderType] on [dspInboxMessage].[ProviderType]'
GO
ALTER TABLE [dspInboxMessage].[ProviderType] ADD CONSTRAINT [PK_ProviderType] PRIMARY KEY CLUSTERED  ([ProviderTypeId])
GO
PRINT N'Creating [dspInboxMessage].[Provider]'
GO
CREATE TABLE [dspInboxMessage].[Provider]
(
[ProviderId] [int] NOT NULL,
[ProviderName] [nvarchar] (500) NOT NULL,
[ProviderTypeId] [tinyint] NOT NULL,
[IsEnable] [bit] NOT NULL,
[Description] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK_Provider] on [dspInboxMessage].[Provider]'
GO
ALTER TABLE [dspInboxMessage].[Provider] ADD CONSTRAINT [PK_Provider] PRIMARY KEY CLUSTERED  ([ProviderId])
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor]'
GO
CREATE TABLE [dspAuth].[SecurityDescriptor]
(
[SecurityDescriptorId] [bigint] NOT NULL IDENTITY(1, 1),
[ObjectTypeId] [smallint] NOT NULL,
[ObjectId] [int] NOT NULL
)
GO
PRINT N'Creating primary key [PK_SecurityDescriptor] on [dspAuth].[SecurityDescriptor]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptor] ADD CONSTRAINT [PK_SecurityDescriptor] PRIMARY KEY CLUSTERED  ([SecurityDescriptorId])
GO
PRINT N'Creating index [IX_ObjectId_ObjectTypeId] on [dspAuth].[SecurityDescriptor]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_ObjectId_ObjectTypeId] ON [dspAuth].[SecurityDescriptor] ([ObjectTypeId], [ObjectId])
GO
PRINT N'Creating [dspAuth].[Role]'
GO
CREATE TABLE [dspAuth].[Role]
(
[RoleId] [int] NOT NULL IDENTITY(1, 1),
[RoleName] [nvarchar] (100) NOT NULL,
[OwnerSecurityDescriptorId] [bigint] NOT NULL,
[ModifiedByUserId] [int] NOT NULL,
[RoleTypeId] [int] NULL,
[IsSystem] [bit] NOT NULL CONSTRAINT [DF_Role_IsSystem] DEFAULT ((0)),
[StartTime] [datetime2] NOT NULL CONSTRAINT [DF__Role__StartTime__62F12DE2] DEFAULT (getutcdate()),
[EndTime] [datetime2] NOT NULL CONSTRAINT [DF__Role__EndTime__63E5521B] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0)))
)
GO
PRINT N'Creating primary key [PK_Role] on [dspAuth].[Role]'
GO
ALTER TABLE [dspAuth].[Role] ADD CONSTRAINT [PK_Role] PRIMARY KEY CLUSTERED  ([RoleId])
GO
PRINT N'Creating index [IX_OwnerSecurityDescriptorId] on [dspAuth].[Role]'
GO
CREATE NONCLUSTERED INDEX [IX_OwnerSecurityDescriptorId] ON [dspAuth].[Role] ([OwnerSecurityDescriptorId])
GO
PRINT N'Creating [dspAuth].[ObjectType]'
GO
CREATE TABLE [dspAuth].[ObjectType]
(
[ObjectTypeId] [smallint] NOT NULL,
[ObjectTypeName] [nvarchar] (100) NOT NULL
)
GO
PRINT N'Creating primary key [PK_ObjectType] on [dspAuth].[ObjectType]'
GO
ALTER TABLE [dspAuth].[ObjectType] ADD CONSTRAINT [PK_ObjectType] PRIMARY KEY CLUSTERED  ([ObjectTypeId])
GO
PRINT N'Creating [dspAuth].[SecurityDescriptorParent]'
GO
CREATE TABLE [dspAuth].[SecurityDescriptorParent]
(
[SecurityDescriptorId] [bigint] NOT NULL,
[ParentSecurityDescriptorId] [bigint] NOT NULL
)
GO
PRINT N'Creating primary key [PK_SecurityDescriptorInheritance] on [dspAuth].[SecurityDescriptorParent]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorParent] ADD CONSTRAINT [PK_SecurityDescriptorInheritance] PRIMARY KEY CLUSTERED  ([SecurityDescriptorId], [ParentSecurityDescriptorId])
GO
PRINT N'Creating index [IX_SecurityDescriptorId] on [dspAuth].[SecurityDescriptorParent]'
GO
CREATE NONCLUSTERED INDEX [IX_SecurityDescriptorId] ON [dspAuth].[SecurityDescriptorParent] ([SecurityDescriptorId]) INCLUDE ([ParentSecurityDescriptorId])
GO
PRINT N'Creating [dspAuth].[SecurityDescriptorRolePermission]'
GO
CREATE TABLE [dspAuth].[SecurityDescriptorRolePermission]
(
[SecurityDescriptorId] [bigint] NOT NULL,
[RoleId] [int] NOT NULL,
[PermissionGroupId] [smallint] NOT NULL,
[AuditUserId] [int] NOT NULL
)
GO
PRINT N'Creating primary key [PK_SecurityDescriptorRolePermission] on [dspAuth].[SecurityDescriptorRolePermission]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorRolePermission] ADD CONSTRAINT [PK_SecurityDescriptorRolePermission] PRIMARY KEY CLUSTERED  ([SecurityDescriptorId], [RoleId], [PermissionGroupId])
GO
PRINT N'Creating [dspAuth].[SecurityDescriptorUserPermission]'
GO
CREATE TABLE [dspAuth].[SecurityDescriptorUserPermission]
(
[SecurityDescriptorId] [bigint] NOT NULL,
[UserId] [int] NOT NULL,
[PermissionGroupId] [smallint] NOT NULL,
[CreatedByUserId] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_SecurityDescriptorUserPermission_CreatedTime] DEFAULT (getdate()),
[ModifiedByUserId] [int] NULL,
[ModifiedTime] [datetime] NULL
)
GO
PRINT N'Creating primary key [PK_SecurityDescriptorUserPermission] on [dspAuth].[SecurityDescriptorUserPermission]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorUserPermission] ADD CONSTRAINT [PK_SecurityDescriptorUserPermission] PRIMARY KEY CLUSTERED  ([SecurityDescriptorId], [PermissionGroupId], [UserId])
GO
PRINT N'Creating [DatabaseVersioning].[TemporalType]'
GO
CREATE TABLE [DatabaseVersioning].[TemporalType]
(
[TemporalTypeId] [tinyint] NOT NULL,
[TemporalTypeName] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_TemporalType] on [DatabaseVersioning].[TemporalType]'
GO
ALTER TABLE [DatabaseVersioning].[TemporalType] ADD CONSTRAINT [PK_TemporalType] PRIMARY KEY CLUSTERED  ([TemporalTypeId])
GO
PRINT N'Creating [dsp].[SystemTable]'
GO
CREATE TABLE [dsp].[SystemTable]
(
[SystemTableId] [int] NOT NULL,
[SchemaName] [nvarchar] (50) NOT NULL,
[TableName] [nvarchar] (400) NOT NULL,
[IsTemporal] [bit] NOT NULL CONSTRAINT [DF_SystemTable_IsTemporal] DEFAULT ((0)),
[TemporalTypeId] [tinyint] NULL,
[LevelPriority] [smallint] NULL,
[ClusterColumnsName] [nvarchar] (1000) NULL,
[IsHistoryTable] [bit] NULL
)
GO
PRINT N'Creating primary key [PK__SystemTableId] on [dsp].[SystemTable]'
GO
ALTER TABLE [dsp].[SystemTable] ADD CONSTRAINT [PK__SystemTableId] PRIMARY KEY CLUSTERED  ([SystemTableId])
GO
PRINT N'Creating index [IX_LevelPriority] on [dsp].[SystemTable]'
GO
CREATE UNIQUE NONCLUSTERED INDEX [IX_LevelPriority] ON [dsp].[SystemTable] ([LevelPriority]) WHERE ([LevelPriority] IS NOT NULL)
GO
PRINT N'Adding constraints to [dsp].[SystemTable]'
GO
ALTER TABLE [dsp].[SystemTable] ADD CONSTRAINT [IX_SystemTable_TableNameSchemaName] UNIQUE NONCLUSTERED  ([SchemaName], [TableName])
GO
PRINT N'Creating [dspInboxMessage].[WaitForReplyMessageState]'
GO
CREATE TABLE [dspInboxMessage].[WaitForReplyMessageState]
(
[WaitForReplyMessageStateId] [tinyint] NOT NULL,
[WaitForReplyMessageState] [nvarchar] (50) NOT NULL
)
GO
PRINT N'Creating primary key [PK_WaitForReplyMessageState] on [dspInboxMessage].[WaitForReplyMessageState]'
GO
ALTER TABLE [dspInboxMessage].[WaitForReplyMessageState] ADD CONSTRAINT [PK_WaitForReplyMessageState] PRIMARY KEY CLUSTERED  ([WaitForReplyMessageStateId])
GO
PRINT N'Creating [dspInboxMessage].[WaitForReplyMessage]'
GO
CREATE TABLE [dspInboxMessage].[WaitForReplyMessage]
(
[WaitForReplyMessageId] [bigint] NOT NULL IDENTITY(1, 1),
[Address] [nvarchar] (100) NULL,
[MessagePatternStepId] [int] NULL,
[MessageLastData] [nvarchar] (max) NULL,
[WaitForReplyMessageStateId] [tinyint] NOT NULL CONSTRAINT [DF__WaitForRe__IsPro__4203A4B5] DEFAULT ((0)),
[ProviderInfoId] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_WaitForReplyMessage_CreatedTime] DEFAULT (getdate())
)
GO
PRINT N'Creating primary key [PK_WaitForReplyMessage] on [dspInboxMessage].[WaitForReplyMessage]'
GO
ALTER TABLE [dspInboxMessage].[WaitForReplyMessage] ADD CONSTRAINT [PK_WaitForReplyMessage] PRIMARY KEY CLUSTERED  ([WaitForReplyMessageId])
GO
PRINT N'Creating index [IX_AddressProviderInfoId] on [dspInboxMessage].[WaitForReplyMessage]'
GO
CREATE NONCLUSTERED INDEX [IX_AddressProviderInfoId] ON [dspInboxMessage].[WaitForReplyMessage] ([Address], [ProviderInfoId]) INCLUDE ([CreatedTime]) WHERE ([WaitForReplyMessageStateId]=(3))
GO
PRINT N'Creating [tSQLt].[Private_GetExternalAccessKeyBytes]'
GO
CREATE FUNCTION [tSQLt].[Private_GetExternalAccessKeyBytes]()
RETURNS TABLE
AS
RETURN
  SELECT 0x4D5A90000300000004000000FFFF0000B800000000000000400000000000000000000000000000000000000000000000000000000000000000000000800000000E1FBA0E00B409CD21B8014CCD21546869732070726F6772616D2063616E6E6F742062652072756E20696E20444F53206D6F64652E0D0D0A2400000000000000504500004C0103005419AD560000000000000000E00002210B010B00000400000006000000000000CE2300000020000000400000000000100020000000020000040000000000000004000000000000000080000000020000817000000300408500001000001000000000100000100000000000001000000000000000000000007C2300004F00000000400000E002000000000000000000000000000000000000006000000C00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000200000080000000000000000000000082000004800000000000000000000002E74657874000000D4030000002000000004000000020000000000000000000000000000200000602E72737263000000E0020000004000000004000000060000000000000000000000000000400000402E72656C6F6300000C0000000060000000020000000A00000000000000000000000000004000004200000000000000000000000000000000B0230000000000004800000002000500D0200000AC0200000900000000000000000000000000000050200000800000000000000000000000000000000000000000000000000000000000000000000000213462F5B9EF260060DE50E40053E6687E4C3CB839148A25A72ED4644D1DB6A8835FE0C2D5FDD8B91073B9C39F7A8FCD4BE43786C9306E73D060E389A18E678E8BF334A1C46DCD33B21D6986A0DDEF92A7C1CD14E1D25582B177CF24DFBE14AB8845A657360F13F7E75792FFBC48D5C7FB979E2E480BFDB7B8AEEB16FB394A3A42534A4201000100000000000C00000076322E302E35303732370000000005006C0000009C000000237E000008010000AC00000023537472696E677300000000B40100000800000023555300BC010000100000002347554944000000CC010000E000000023426C6F620000000000000002000001071400000900000000FA2533001600000100000002000000010000000200000002000000010000000100000000000A0001000000000006004E002E00060074002E00000000000100000000000100010009006E000A0011006E000F002E000B00B5002E001300BE000480000000000000000000000100000013009200000002000000000000000000000001002500000000000000003C4D6F64756C653E007453514C7445787465726E616C4163636573734B65792E646C6C006D73636F726C69620053797374656D2E52756E74696D652E436F6D70696C6572536572766963657300436F6D70696C6174696F6E52656C61786174696F6E73417474726962757465002E63746F720052756E74696D65436F6D7061746962696C697479417474726962757465007453514C7445787465726E616C4163636573734B6579000000000003200000000000FA9D540989B0294FAE952438919E8F450008B77A5C561934E08904200101080320000180A00024000004800000940000000602000000240000525341310004000001000100F7D9A45F2B508C2887A8794B053CE5DEB28743B7C748FF545F1F51218B684454B785054629C1417D1D3542B095D80BA171294948FCF978A502AA03240C024746B563BC29B4D8DCD6956593C0C425446021D699EF6FB4DC2155DE7E393150AD6617EDC01216EA93FCE5F8F7BE9FF605AD2B8344E8CC01BEDB924ED06FD368D1D00801000800000000001E01000100540216577261704E6F6E457863657074696F6E5468726F777301000000A42300000000000000000000BE230000002000000000000000000000000000000000000000000000B0230000000000000000000000005F436F72446C6C4D61696E006D73636F7265652E646C6C0000000000FF2500200010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100100000001800008000000000000000000000000000000100010000003000008000000000000000000000000000000100000000004800000058400000840200000000000000000000840234000000560053005F00560045005200530049004F004E005F0049004E0046004F0000000000BD04EFFE00000100000000000000000000000000000000003F000000000000000400000002000000000000000000000000000000440000000100560061007200460069006C00650049006E0066006F00000000002400040000005400720061006E0073006C006100740069006F006E00000000000000B004E4010000010053007400720069006E006700460069006C00650049006E0066006F000000C001000001003000300030003000300034006200300000002C0002000100460069006C0065004400650073006300720069007000740069006F006E000000000020000000300008000100460069006C006500560065007200730069006F006E000000000030002E0030002E0030002E003000000058001B00010049006E007400650072006E0061006C004E0061006D00650000007400530051004C007400450078007400650072006E0061006C004100630063006500730073004B00650079002E0064006C006C00000000002800020001004C006500670061006C0043006F00700079007200690067006800740000002000000060001B0001004F0072006900670069006E0061006C00460069006C0065006E0061006D00650000007400530051004C007400450078007400650072006E0061006C004100630063006500730073004B00650079002E0064006C006C0000000000340008000100500072006F006400750063007400560065007200730069006F006E00000030002E0030002E0030002E003000000038000800010041007300730065006D0062006C0079002000560065007200730069006F006E00000030002E0030002E0030002E003000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000C000000D03300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000 AS ExternalAccessKeyBytes, 0x7722217D36028E4C AS ExternalAccessKeyThumbPrint;
GO
PRINT N'Creating [tSQLt].[Private_Bin2Hex]'
GO
CREATE FUNCTION [tSQLt].[Private_Bin2Hex](@vb VARBINARY(MAX))
RETURNS TABLE
AS
RETURN
  SELECT X.S AS bare, '0x'+X.S AS prefix
    FROM (SELECT LOWER(CAST('' AS XML).value('xs:hexBinary(sql:variable("@vb") )','VARCHAR(MAX)')))X(S);
GO
PRINT N'Creating [tSQLt].[InstallExternalAccessKey]'
GO
CREATE PROCEDURE [tSQLt].[InstallExternalAccessKey]
AS
BEGIN
  IF(NOT EXISTS(SELECT * FROM sys.fn_my_permissions(NULL,'server') AS FMP WHERE FMP.permission_name = 'CONTROL SERVER'))
  BEGIN
    RAISERROR('Only principals with CONTROL SERVER permission can execute this procedure.',16,10);
    RETURN -1;
  END;

  DECLARE @cmd NVARCHAR(MAX);
  DECLARE @cmd2 NVARCHAR(MAX);
  DECLARE @master_sys_sp_executesql NVARCHAR(MAX); SET @master_sys_sp_executesql = 'master.sys.sp_executesql';

  SET @cmd = 'IF EXISTS(SELECT * FROM sys.assemblies WHERE name = ''tSQLtExternalAccessKey'') DROP ASSEMBLY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;

  SET @cmd2 = 'SELECT @cmd = ''DROP ASSEMBLY ''+QUOTENAME(A.name)+'';'''+ 
              '  FROM master.sys.assemblies AS A'+
              ' WHERE A.clr_name LIKE ''tsqltexternalaccesskey, %'';';
  EXEC sys.sp_executesql @cmd2,N'@cmd NVARCHAR(MAX) OUTPUT',@cmd OUT;
  EXEC @master_sys_sp_executesql @cmd;

  SELECT @cmd = 
         'CREATE ASSEMBLY tSQLtExternalAccessKey AUTHORIZATION dbo FROM ' +
         BH.prefix +
         ' WITH PERMISSION_SET = UNSAFE;'       
    FROM tSQLt.Private_GetExternalAccessKeyBytes() AS PGEAKB
   CROSS APPLY tSQLt.Private_Bin2Hex(PGEAKB.ExternalAccessKeyBytes) BH;
  EXEC @master_sys_sp_executesql @cmd;

  IF SUSER_ID('tSQLtExternalAccessKey') IS NOT NULL DROP LOGIN tSQLtExternalAccessKey;

  SET @cmd = N'IF ASYMKEY_ID(''tSQLtExternalAccessKey'') IS NOT NULL DROP ASYMMETRIC KEY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;

  SET @cmd2 = 'SELECT @cmd = ISNULL(''DROP LOGIN ''+QUOTENAME(SP.name)+'';'','''')+''DROP ASYMMETRIC KEY '' + QUOTENAME(AK.name) + '';'''+
              '  FROM master.sys.asymmetric_keys AS AK'+
              '  JOIN tSQLt.Private_GetExternalAccessKeyBytes() AS PGEAKB'+
              '    ON AK.thumbprint = PGEAKB.ExternalAccessKeyThumbPrint'+
              '  LEFT JOIN master.sys.server_principals AS SP'+
              '    ON AK.sid = SP.sid;';
  EXEC sys.sp_executesql @cmd2,N'@cmd NVARCHAR(MAX) OUTPUT',@cmd OUT;
  EXEC @master_sys_sp_executesql @cmd;

  SET @cmd = 'CREATE ASYMMETRIC KEY tSQLtExternalAccessKey FROM ASSEMBLY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;
 
  SET @cmd = 'CREATE LOGIN tSQLtExternalAccessKey FROM ASYMMETRIC KEY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;

  SET @cmd = 'DROP ASSEMBLY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;

  SET @cmd = 'GRANT EXTERNAL ACCESS ASSEMBLY TO tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql @cmd;

END;
GO
PRINT N'Creating [dsp].[String_ReplaceEnter]'
GO
-- Create Function String
CREATE FUNCTION [dsp].[String_ReplaceEnter] (@Value NVARCHAR(/*NCQ*/ 4000))
RETURNS NVARCHAR(/*NCQ*/ 4000)
WITH SCHEMABINDING
AS
BEGIN
    RETURN REPLACE(@Value, N'\n', CHAR(/*No Codequality Error*/ 13) + CHAR(/*No Codequality Error*/ 10));
END;

GO
PRINT N'Creating [dsp].[StringTable_Value]'
GO

CREATE	FUNCTION [dsp].[StringTable_Value] (@StringId TSTRING)
RETURNS TSTRING
AS
BEGIN
	DECLARE @Value TSTRING;

	SELECT	@Value = ST.StringValue
	FROM	dsp.StringTable AS ST
	WHERE	ST.StringId = @StringId;

	RETURN dsp.String_ReplaceEnter(@Value);
END;


GO
PRINT N'Creating [dspstr].[String2]'
GO

				CREATE FUNCTION [dspstr].[String2]() 
				RETURNS TSTRING
				AS 
				BEGIN
					RETURN dsp.StringTable_Value('String2');
				END
						
GO
PRINT N'Creating [dsp].[Setting]'
GO
CREATE TABLE [dsp].[Setting]
(
[SettingId] [int] NOT NULL,
[AppName] [nvarchar] (50) NOT NULL CONSTRAINT [DF_Setting_AppName] DEFAULT (N'NewApplicationName'),
[AppVersion] [varchar] (50) NOT NULL CONSTRAINT [DF_Setting_AppVersion] DEFAULT ('1.0.0'),
[IsUnitTestMode] [bit] NOT NULL CONSTRAINT [DF_Setting_IsUnitTestMode] DEFAULT ((0)),
[IsProductionEnvironment] [bit] NOT NULL CONSTRAINT [DF_Setting_IsProductionEnvironment] DEFAULT ((0)),
[PaginationDefaultRecordCount] [int] NOT NULL CONSTRAINT [DF_Setting_PaginationDefaultRecordCount] DEFAULT ((50)),
[PaginationMaxRecordCount] [int] NOT NULL CONSTRAINT [DF_Setting_PaginationMaxRecordCount] DEFAULT ((200)*(1000000)),
[AppUserId] [nvarchar] (50) NULL,
[SystemUserId] [nvarchar] (50) NULL,
[MaintenanceMode] [tinyint] NOT NULL CONSTRAINT [DF_Setting_MaintenanceMode] DEFAULT ((0)),
[IsVersioningEnable] [bit] NULL CONSTRAINT [DF_Setting_IsVersioningEnable] DEFAULT ((0)),
[IsEnabledInitNewAppVersion] [bit] NULL CONSTRAINT [DF_Setting_IsInitNewAppVersion] DEFAULT ((0)),
[StoredProcedureVersionNumberPrefix] [nvarchar] (50) NULL,
[IsEnabledRequestWroker] [bit] NULL CONSTRAINT [DF__Setting__IsEnabl__00B50445] DEFAULT ((1)),
[StartTime] [datetime2] NOT NULL CONSTRAINT [DF__Setting__StartTi__5DF76E9B] DEFAULT (getutcdate()),
[EndTime] [datetime2] NOT NULL CONSTRAINT [DF__Setting__EndTime__5EEB92D4] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0)))
)
GO
PRINT N'Creating primary key [PK_Setting] on [dsp].[Setting]'
GO
ALTER TABLE [dsp].[Setting] ADD CONSTRAINT [PK_Setting] PRIMARY KEY CLUSTERED  ([SettingId])
GO
PRINT N'Creating [dsp].[StoredProcedure_VersionNumber]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_VersionNumber] (@StoredProcedureName TSTRING)
RETURNS @T TABLE (VersionNumber TSTRING)
AS
BEGIN

    DECLARE @StoredProcedureVersionNumberPrefix TSTRING;

    -- Get the StoredProcedureVersionNumberPrefix value from settings
    SELECT  TOP 1 @StoredProcedureVersionNumberPrefix = S.StoredProcedureVersionNumberPrefix
      FROM  dsp.Setting AS S;

    DECLARE @StartIndex INT = CHARINDEX(@StoredProcedureVersionNumberPrefix, @StoredProcedureName);
    DECLARE @Length INT = LEN(@StoredProcedureName);

    -- Check if the stored procedure name does not have version number
    IF (@StartIndex IS NULL OR  @StartIndex = 0)
        RETURN;

    -- Get the version number from the stored procedure name
    INSERT INTO @T (VersionNumber)
    VALUES (SUBSTRING(@StoredProcedureName, @StartIndex + LEN(@StoredProcedureVersionNumberPrefix), @Length - @StartIndex));

    RETURN;
END;




GO
PRINT N'Creating [dsp].[StoreProcedure_MaxVersionNumber]'
GO
CREATE FUNCTION [dsp].[StoreProcedure_MaxVersionNumber] ()
RETURNS INT
AS
BEGIN
    -- Get Schema name
    DECLARE @SchemaName TSTRING = dbo.Setting_VersioningSchemaName();

    -- The temp table definition
    DECLARE @MaxVersionNumber INT;
    SELECT  @MaxVersionNumber = SPM.VersionNumber --
      FROM  sys.procedures AS P
            CROSS APPLY dsp.StoredProcedure_VersionNumber(P.name) AS SPM
     WHERE  P.schema_id = SCHEMA_ID(@SchemaName)
     ORDER BY CAST(SPM.VersionNumber AS INT) DESC;

    SET @MaxVersionNumber = ISNULL(@MaxVersionNumber, 0);
    SET @MaxVersionNumber = @MaxVersionNumber + 1;
    RETURN @MaxVersionNumber;
END;



GO
PRINT N'Creating [dsp].[ThrowException]'
GO
CREATE	PROCEDURE [dsp].[ThrowException]
	@Exception TJSON
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @ExceptionId INT = JSON_VALUE(@Exception, '$.errorId');
	THROW @ExceptionId, @Exception, 1;
END;





GO
PRINT N'Creating [dsp].[Formatter_FormatString]'
GO
CREATE FUNCTION [dsp].[Formatter_FormatString] (@str NVARCHAR(/*NoCodeQuality*/4000))
RETURNS NVARCHAR(/*NoCodeQuality*/4000)
WITH SCHEMABINDING
AS
BEGIN
	RETURN NULLIF(TRIM(@str), '');
END;



GO
PRINT N'Creating [dsp].[Param_IsSetBase]'
GO
CREATE	FUNCTION [dsp].[Param_IsSetBase] (@Value SQL_VARIANT,
	@NullAsNotSet BIT)
RETURNS BIT WITH SCHEMABINDING
AS
BEGIN
	IF (@Value IS NULL AND @NullAsNotSet = 1)
		RETURN 0;

	DECLARE @Type NVARCHAR(/*NoCodeChecker*/ 20) = CAST(SQL_VARIANT_PROPERTY(@Value, 'BaseType') AS NVARCHAR(/*NoCodeChecker*/ 20));

	IF (@Type LIKE '%int%' AND CAST(@Value AS INT) = -1)
		RETURN 0;

	IF (@Type LIKE '%char%' AND (CAST(@Value AS NVARCHAR(/*NoCodeChecker*/ 10)) = '<notset>' OR CAST(@Value AS NVARCHAR(/*NoCodeChecker*/ 10)) = '<noaccess>'))
		RETURN 0;

	IF (@Type LIKE '%date%' AND CAST(@Value AS DATETIME) = '1753-01-01')
		RETURN 0;

	IF (@Type LIKE '%decimal%' AND CAST(@Value AS DECIMAL) = -1)
		RETURN 0;

	IF (@Type LIKE '%money%' AND CAST(@Value AS MONEY) = -1)
		RETURN 0;

	IF (@Type LIKE '%float%' AND CAST(@Value AS FLOAT) = -1)
		RETURN 0;

	RETURN 1;
END;














GO
PRINT N'Creating [dsp].[Param_IsSet]'
GO
CREATE	FUNCTION [dsp].[Param_IsSet] (@Value SQL_VARIANT)
RETURNS BIT
AS
BEGIN
	RETURN	dsp.Param_IsSetBase(@Value, 0);
END;














GO
PRINT N'Creating [dsp].[Param_IsSetString]'
GO

-- to check if the @value has been set or not
-- String not set value: <notset>
-- Int not set value: -1
-- datetime not set value: '1753-01-01'
CREATE FUNCTION [dsp].[Param_IsSetString] (@Value TBIGSTRING)
RETURNS BIT
AS
BEGIN
	DECLARE @Value2 TSTRING = @Value;
	RETURN dsp.Param_IsSet(@Value2);
END;



GO
PRINT N'Creating [dsp].[Formatter_FormatParam]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatParam] (@Param TSTRING)
RETURNS TSTRING
AS
BEGIN
	-- return nothing has been set
	IF (dsp.Param_IsSetString(@Param) = 0)
		RETURN '<notset>';

	-- set <null> string for NULL to indicate the value is null
	RETURN ISNULL(@Param, '<null>');
END;




GO
PRINT N'Creating [dsp].[Formatter_FormatMessage]'
GO

--todo: refactor to String_Format
CREATE FUNCTION [dsp].[Formatter_FormatMessage] (@Message TSTRING,
	@Param0 TSTRING = '<notset>',
	@Param1 TSTRING = '<notset>',
	@Param2 TSTRING = '<notset>',
	@Param3 TSTRING = '<notset>')
RETURNS TSTRING
AS
BEGIN

	-- Validate Params
	SET @Param0 = dsp.Formatter_FormatParam(@Param0);
	SET @Param1 = dsp.Formatter_FormatParam(@Param1);
	SET @Param2 = dsp.Formatter_FormatParam(@Param2);
	SET @Param3 = dsp.Formatter_FormatParam(@Param3);

	-- Replace Message
	SET @Message = dsp.Formatter_FormatString(@Message);
	SET @Message = REPLACE(@Message, '{0}', @Param0);
	SET @Message = REPLACE(@Message, '{1}', @Param1);
	SET @Message = REPLACE(@Message, '{2}', @Param2);
	SET @Message = REPLACE(@Message, '{3}', @Param3);

	RETURN @Message;

END;






GO
PRINT N'Creating [dsp].[Exception_BuildMessageParam4]'
GO
CREATE	FUNCTION [dsp].[Exception_BuildMessageParam4] (@ProcId INT,
	@ExceptionId INT,
	@Message TSTRING = NULL,
	@Param0 TSTRING = '<notset>',
	@Param1 TSTRING = '<notset>',
	@Param2 TSTRING = '<notset>',
	@Param3 TSTRING = '<notset>')
RETURNS TJSON
AS
BEGIN
	-- get exception name and detail
	DECLARE @Description TSTRING;
	DECLARE @ExceptionName TSTRING;

	SELECT	@Description = Description, @ExceptionName = ExceptionName
	FROM	dsp.Exception
	WHERE	ExceptionId = @ExceptionId;

	-- validate exception Id
	IF (@ExceptionName IS NULL)
	BEGIN
		SET @Message = 'Inavlid AppExceptionId; ExceptionId: {0}';
		SET @Param0 = @ExceptionId;
		SET @ExceptionId = 55001;
	END;

	-- Replace Message
	EXEC @Message = dsp.Formatter_FormatMessage @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2, @Param3 = @Param3;

	-- generate exception
	DECLARE @Exception TJSON = '{}';
	SET @Exception = JSON_MODIFY(@Exception, '$.errorId', @ExceptionId);
	SET @Exception = JSON_MODIFY(@Exception, '$.errorName', @ExceptionName);
	IF (@Description IS NOT NULL)
		SET @Exception = JSON_MODIFY(@Exception, '$.errorDescription', @Description);
	IF (@Message IS NOT NULL)
		SET @Exception = JSON_MODIFY(@Exception, '$.errorMessage', @Message);

	-- Set Schema and ProcName
	IF (@ProcId IS NOT NULL)
	BEGIN
		DECLARE @ProcName TSTRING = ISNULL(OBJECT_NAME(@ProcId), '(NoSP)');
		DECLARE @SchemaName TSTRING = OBJECT_SCHEMA_NAME(@ProcId);
		IF (@SchemaName IS NOT NULL)
			SET @ProcName = @SchemaName + '.' + @ProcName;
		SET @Exception = JSON_MODIFY(@Exception, '$.errorProcName', @ProcName);
	END;

	RETURN @Exception;
END;



GO
PRINT N'Creating [dsp].[ThrowAppException]'
GO
-- Create Procedure ThrowAppException

CREATE PROCEDURE [dsp].[ThrowAppException]
	@ProcId INT = NULL, @ExceptionId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>',
	@Param3 TSTRING = '<notset>'
AS
BEGIN
	SET NOCOUNT ON;

	DECLARE @Exception TJSON;
	EXEC @Exception = dsp.Exception_BuildMessageParam4 @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0,
		@Param1 = @Param1, @Param2 = @Param2, @Param3 = @Param3;
	EXEC dsp.ThrowException @Exception = @Exception;
END;











GO
PRINT N'Creating [err].[NoOperationId]'
GO

CREATE FUNCTION [err].[NoOperationId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55021;  
END
GO
PRINT N'Creating [err].[ThrowNoOperation]'
GO

CREATE PROCEDURE [err].[ThrowNoOperation] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.NoOperationId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [err].[ObjectAlreadyExistsId]'
GO

CREATE FUNCTION [err].[ObjectAlreadyExistsId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55004;  
END
GO
PRINT N'Creating [err].[ThrowObjectAlreadyExists]'
GO

CREATE PROCEDURE [err].[ThrowObjectAlreadyExists] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.ObjectAlreadyExistsId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[String_IsContain]'
GO
CREATE FUNCTION [dsp].[String_IsContain] (@ExpressionToFind TBIGSTRING,
    @ExpressionToSearch TBIGSTRING)
RETURNS TABLE
AS
RETURN (SELECT  IIF(CHARINDEX(@ExpressionToFind, @ExpressionToSearch, 0) = 0, 0, 1) AS IsContain);

GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_Parents]'
GO
CREATE FUNCTION [dspAuth].[SecurityDescriptor_Parents] (@SecurityDescriptorId BIGINT)
RETURNS TABLE
AS
RETURN (WITH SecurityDescriptorParents
			AS (SELECT	SOI.ParentSecurityDescriptorId AS SecurityDescriptorId
				FROM	dspAuth.SecurityDescriptorParent AS SOI
				WHERE	SOI.SecurityDescriptorId = @SecurityDescriptorId
				UNION ALL
				SELECT	SOI.ParentSecurityDescriptorId AS SecurityDescriptorId
				FROM	dspAuth.SecurityDescriptorParent AS SOI
						INNER JOIN SecurityDescriptorParents AS PSO ON PSO.SecurityDescriptorId = SOI.SecurityDescriptorId)
		SELECT	SOP.SecurityDescriptorId
		FROM	SecurityDescriptorParents AS SOP
		UNION
		SELECT	@SecurityDescriptorId);

GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_IsParentOf]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_IsParentOf]
	@SecurityDescriptorId BIGINT, @ChildSecurityDescriptorId BIGINT, @IsParentOf BIT OUT
AS
BEGIN
	SET @IsParentOf = 0;

	-- SecurityDescriptor_Parents Gets parernts of the SecurityDescriptor including itself
	SELECT	@IsParentOf = 1
	FROM	dspAuth.SecurityDescriptor_Parents(@ChildSecurityDescriptorId) AS SOPG
	WHERE	SOPG.SecurityDescriptorId = @SecurityDescriptorId;
END;

GO
PRINT N'Creating [dsperr].[ObjectAlreadyExistsId]'
GO

CREATE FUNCTION [dsperr].[ObjectAlreadyExistsId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55003;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowObjectAlreadyExists]'
GO

CREATE PROCEDURE [dsperr].[ThrowObjectAlreadyExists] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.ObjectAlreadyExistsId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsperr].[GeneralExceptionId]'
GO

CREATE FUNCTION [dsperr].[GeneralExceptionId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55026;  
END
			
GO
PRINT N'Creating [dsp].[ThrowGeneralException]'
GO

CREATE PROCEDURE [dsp].[ThrowGeneralException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.GeneralExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[ObjectType_User]'
GO
CREATE FUNCTION [dspAuth].[ObjectType_User]()
 RETURNS INT WITH SCHEMABINDING
 AS 
 BEGIN
     RETURN 2;
 END











GO
PRINT N'Creating [dbo].[User_CreateByAuthId]'
GO
CREATE PROCEDURE [dbo].[User_CreateByAuthId]
    @AuditUserId INT, @AuthUserId INT, @UserId INT = NULL OUT
AS
BEGIN
    -- Only the user System can have AuditUserId with null value 
    IF (@AuditUserId IS NULL AND EXISTS (SELECT 1 FROM  dbo.Users)) --
        EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'AuditUserId can not be NULL if table has some records';

    DECLARE @ObjectTypeId INT = dspAuth.ObjectType_User();    

    BEGIN TRY
        INSERT  dbo.Users (AuthUserId, IsEnabled, ModifiedByUserId)
        VALUES (@AuthUserId, 1, @AuditUserId);
        SET @UserId = SCOPE_IDENTITY();        
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() = 2601) -- SQL Duplicate Key
        BEGIN
            DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
            EXEC dsperr.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = @ErrorMessage;
        END;
        THROW;
    END CATCH;
END;
GO
PRINT N'Creating [dsp].[String_RemoveWhitespaces]'
GO
CREATE FUNCTION [dsp].[String_RemoveWhitespaces] ( @String TSTRING )
RETURNS TSTRING
AS
BEGIN
    RETURN REPLACE(REPLACE(REPLACE(REPLACE(@String, ' ', ''), CHAR(13), ''), CHAR(10), ''), CHAR(9), '');
END;



GO
PRINT N'Creating [tSQLt].[CaptureOutputLog]'
GO
CREATE TABLE [tSQLt].[CaptureOutputLog]
(
[Id] [int] NOT NULL IDENTITY(1, 1),
[OutputText] [nvarchar] (max) NULL
)
GO
PRINT N'Creating primary key [PK__CaptureO__3214EC074C626522] on [tSQLt].[CaptureOutputLog]'
GO
ALTER TABLE [tSQLt].[CaptureOutputLog] ADD CONSTRAINT [PK__CaptureO__3214EC074C626522] PRIMARY KEY CLUSTERED  ([Id])
GO
PRINT N'Creating [tSQLt].[LogCapturedOutput]'
GO
CREATE PROCEDURE [tSQLt].[LogCapturedOutput] @text NVARCHAR(MAX)
AS
BEGIN
  INSERT INTO tSQLt.CaptureOutputLog (OutputText) VALUES (@text);
END;
GO
PRINT N'Creating [err].[NotImplemetedId]'
GO

CREATE FUNCTION [err].[NotImplemetedId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55018;  
END
GO
PRINT N'Creating [err].[ThrowNotImplemeted]'
GO

CREATE PROCEDURE [err].[ThrowNotImplemeted] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.NotImplemetedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsperr].[InvalidOperationId]'
GO

CREATE FUNCTION [dsperr].[InvalidOperationId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55010;  
END
			
GO
PRINT N'Creating [dsp].[ThrowInvalidOperation]'
GO

CREATE PROCEDURE [dsp].[ThrowInvalidOperation] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvalidOperationId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_AddParent]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_AddParent]
    @SecurityDescriptorId BIGINT, @ParentSecurityDescriptorId BIGINT
AS
BEGIN
    -- Checking if the SecurityDescriptorId is parent of ParentSecurityDescriptorId or not
    DECLARE @IsParentOf BIT;
    EXEC dspAuth.SecurityDescriptor_IsParentOf @SecurityDescriptorId = @SecurityDescriptorId, @ChildSecurityDescriptorId = @ParentSecurityDescriptorId,
        @IsParentOf = @IsParentOf OUT;

    IF (@IsParentOf = 1)
        EXEC dsp.ThrowInvalidOperation @ProcId = @@PROCID,
            @Message = N'Invalid operation: SecurityDescriptorAddParent;A SecurityDescriptor: {0} has been already added as the child of security Object {1}',
            @Param0 = @ParentSecurityDescriptorId, @Param1 = @SecurityDescriptorId;

    -- Add SecurityDescriptor to SecurityDescriptorInherit
    BEGIN TRY
        INSERT  dspAuth.SecurityDescriptorParent (SecurityDescriptorId, ParentSecurityDescriptorId)
        VALUES (@SecurityDescriptorId, @ParentSecurityDescriptorId);
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() = 2627 AND   ERROR_MESSAGE() LIKE '%SecurityDescriptor%') -- duplicate unique index error
            EXEC err.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = N'SecurityDescriptor: {0}, ParentSecurityId: {1}',
                @Param0 = @SecurityDescriptorId, @Param1 = @ParentSecurityDescriptorId;
        THROW;
    END CATCH;
END;




GO
PRINT N'Creating [dbo].[User_CreateByAuthUserName]'
GO
CREATE PROCEDURE [dbo].[User_CreateByAuthUserName]
	@AuditUserId INT, @UserName TSTRING, @UserId INT = NULL OUTPUT
AS
BEGIN
	--ToDo Transaction
	DECLARE @Log_AppUserContext TCONTEXT = '$$';

	-- Get User from IcUserService by Username
	DECLARE @AuthUserId INT;
	EXEC IcUserService.api.User_GetIdByUserName @Context = @Log_AppUserContext OUT, @UserName = @UserName, @UserId = @AuthUserId OUTPUT;
	
	-- Add created User to IcLoyalty
	EXEC dbo.User_CreateByAuthId @AuthUserId = @AuthUserId, @AuditUserId = @AuditUserId, @UserId = @UserId OUT;	
END;

GO
PRINT N'Creating [dsp].[String_RemoveWhitespacesBig]'
GO
CREATE FUNCTION [dsp].[String_RemoveWhitespacesBig] ( @String TBIGSTRING )
RETURNS TBIGSTRING
AS
BEGIN
    RETURN REPLACE(REPLACE(REPLACE(REPLACE(@String, ' ', ''), CHAR(13), ''), CHAR(10), ''), CHAR(9), '');
END;




GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_AddRolePermission]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_AddRolePermission]
    @AuditUserId INT, @SecurityDescriptorId BIGINT, @PermissionGroupId INT, @RoleId INT
AS
BEGIN
    BEGIN TRY		
        INSERT  dspAuth.SecurityDescriptorRolePermission (SecurityDescriptorId, RoleId, PermissionGroupId, AuditUserId)
        VALUES (@SecurityDescriptorId, @RoleId, @PermissionGroupId, @AuditUserId);
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() = 2627) -- duplicate key error
            EXEC dsperr.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = N'SecurityDescriptor: {0}, RoleId {1}, PermissionGroupId: {2}',
                @Param0 = @SecurityDescriptorId, @Param1 = @RoleId, @Param2 = @PermissionGroupId;
        THROW;
    END CATCH;
END;
GO
PRINT N'Creating [dsp].[Util_VerifyServerName]'
GO
CREATE PROCEDURE [dsp].[Util_VerifyServerName]
	@ConfirmServerName TSTRING
AS
BEGIN
	DECLARE @ServerName TSTRING = @@SERVERNAME;
	IF (@ConfirmServerName IS NULL OR	LOWER(@ConfirmServerName) != LOWER(@@SERVERNAME))
		EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = N'ConfirmServerName must be set to ''{0}''!',
			@Param0 = @ServerName;
END;
GO
PRINT N'Creating [dsp].[Setting_GetProps]'
GO
CREATE PROCEDURE [dsp].[Setting_GetProps]
    @AppName TSTRING = NULL OUT, @AppVersion TSTRING = NULL OUT, @SystemUserId TSTRING = NULL OUT, @AppUserId TSTRING = NULL OUT,
    @IsProductionEnvironment BIT = NULL OUT, @PaginationDefaultRecordCount INT = NULL OUT, @PaginationMaxRecordCount INT = NULL OUT,
    @IsUnitTestMode BIT = NULL OUT, @MaintenanceMode INT = NULL OUT, @IsVersioningEnable BIT = NULL OUT, @IsEnabledInitNewAppVersion BIT = NULL OUT,
    @StoredProcedureVersionNumberPrefix TSTRING = NULL OUTPUT, @IsEnabledRequestWroker BIT = NULL OUTPUT
AS
BEGIN

    SELECT --
        @AppName = AppName, --
        @AppVersion = AppVersion, -- 
        @SystemUserId = SystemUserId, -- 
        @AppUserId = AppUserId, -- 
        @AppVersion = AppVersion, -- 
        @IsProductionEnvironment = IsProductionEnvironment, --
        @PaginationDefaultRecordCount = PaginationDefaultRecordCount, --
        @PaginationMaxRecordCount = PaginationMaxRecordCount, --
        @IsUnitTestMode = IsUnitTestMode, --
        @MaintenanceMode = MaintenanceMode, --
        @IsVersioningEnable = IsVersioningEnable, --
        @IsEnabledInitNewAppVersion = IsEnabledInitNewAppVersion, --
        @StoredProcedureVersionNumberPrefix = StoredProcedureVersionNumberPrefix, --
        @IsEnabledRequestWroker = IsEnabledRequestWroker --
      FROM  dsp.Setting;

END;
GO
PRINT N'Creating [dsp].[String_Tokenize]'
GO
CREATE	PROCEDURE [dsp].[String_Tokenize]
	@Expression TSTRING, @Delimeter TSTRING, @Position INT OUTPUT, @Token TSTRING OUTPUT
AS
BEGIN
	IF (@Position = 0)
	BEGIN
		SET @Token = NULL;
		RETURN;
	END;

	SET @Delimeter = ISNULL(@Delimeter, '/');

	SET @Position = ISNULL(@Position, 1);
	DECLARE @DelimiterIndex INT = CHARINDEX(@Delimeter, @Expression, @Position);
	IF (@DelimiterIndex = 0)
		SET @DelimiterIndex = LEN(@Expression) - @DelimiterIndex + 1;

	SET @Token = SUBSTRING(@Expression, @Position, @DelimiterIndex - @Position);

	SET @Position = @DelimiterIndex + 1;
	IF (@Position > LEN(@Expression))
		SET @Position = 0;
END;


GO
PRINT N'Creating [dsp].[Convert_ToString]'
GO
CREATE FUNCTION [dsp].[Convert_ToString] (@Value SQL_VARIANT)
RETURNS NVARCHAR(MAX /*NCQ*/)
WITH SCHEMABINDING
BEGIN
    RETURN CAST(@Value
AS  NVARCHAR(4000));
END;
GO
PRINT N'Creating [dsp].[Setting_$IncreaseAppVersion]'
GO
CREATE PROCEDURE [dsp].[Setting_$IncreaseAppVersion]
    @AppVersion TSTRING OUT, @ForceIncrease INT
AS
BEGIN
    DECLARE @Position INT;
    DECLARE @Part1 TSTRING;
    DECLARE @Part2 TSTRING;
    DECLARE @Part3 TSTRING;
    EXEC dsp.String_Tokenize @Expression = @AppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @Part1 OUTPUT;
    EXEC dsp.String_Tokenize @Expression = @AppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @Part2 OUTPUT;
    EXEC dsp.String_Tokenize @Expression = @AppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @Part3 OUTPUT;

    SET @Position = NULL;
    DECLARE @OldPart1 TSTRING;
    DECLARE @OldPart2 TSTRING;
    DECLARE @OldPart3 TSTRING;
    DECLARE @OldAppVersion TSTRING;
    EXEC dsp.Setting_GetProps @AppVersion = @OldAppVersion OUT;
    EXEC dsp.String_Tokenize @Expression = @OldAppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @OldPart1 OUTPUT;
    EXEC dsp.String_Tokenize @Expression = @OldAppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @OldPart2 OUTPUT;
    EXEC dsp.String_Tokenize @Expression = @OldAppVersion, @Delimeter = N'.', @Position = @Position OUTPUT, @Token = @OldPart3 OUTPUT;

	-- Check Star
    IF (@Part3 = N'*' OR @ForceIncrease = 1)
	BEGIN
		SET @Part3 = ISNULL(@OldPart3, N'0');
        SET @Part3 = dsp.Convert_ToString(CAST(@Part3 AS INT) + 1);
	END

    -- Check format
    SET @AppVersion = @Part1 + '.' + @Part2 + '.' + @Part3;
END;




GO
PRINT N'Creating [dsp].[Setting_SetProps]'
GO

CREATE PROCEDURE [dsp].[Setting_SetProps]
    @AppName TSTRING = N'<notset>', @AppVersion TSTRING = N'<notset>', @SystemUserId TSTRING = N'<notset>', @AppUserId TSTRING = N'<notset>',
    @PaginationDefaultRecordCount INT = -1, @PaginationMaxRecordCount INT = -1, @IsProductionEnvironment INT = -1, @IsUnitTestMode INT = -1,
    @ConfirmServerName TSTRING = NULL, @MaintenanceMode INT = -1, @IsVersioningEnable INT = -1, @IsEnabledInitNewAppVersion INT = -1
AS
BEGIN

    IF (dsp.Param_IsSet(@IsProductionEnvironment) = 1)
    BEGIN
        -- Verify server name if the IsProductionEnvironment is going to unset
        DECLARE @OldIsProductionEnvironment INT;
        EXEC dsp.Setting_GetProps @IsProductionEnvironment = @OldIsProductionEnvironment OUTPUT;
        IF (@IsProductionEnvironment = 0 AND @OldIsProductionEnvironment = 1) --
            EXEC dsp.Util_VerifyServerName @ConfirmServerName = @ConfirmServerName;

        -- Update IsProductionEnvironment
        UPDATE  dsp.Setting
           SET  IsProductionEnvironment = @IsProductionEnvironment;
    END;

    IF (dsp.Param_IsSet(@AppName) = 1)
        UPDATE  dsp.Setting
           SET  AppName = @AppName;

    IF (dsp.Param_IsSet(@AppVersion) = 1)
    BEGIN
        EXEC dsp.[Setting_$IncreaseAppVersion] @AppVersion = @AppVersion OUTPUT, @ForceIncrease = 0;
        IF (@AppVersion IS NULL) --
            EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'AppVersion contains an invalid value!';
        UPDATE  dsp.Setting
           SET  AppVersion = @AppVersion;
    END;

    IF (dsp.Param_IsSet(@PaginationDefaultRecordCount) = 1)
        UPDATE  dsp.Setting
           SET  PaginationDefaultRecordCount = @PaginationDefaultRecordCount;

    IF (dsp.Param_IsSet(@PaginationMaxRecordCount) = 1)
        UPDATE  dsp.Setting
           SET  PaginationMaxRecordCount = @PaginationMaxRecordCount;

    IF (dsp.Param_IsSet(@IsUnitTestMode) = 1)
        UPDATE  dsp.Setting
           SET  IsUnitTestMode = @IsUnitTestMode;

    IF (dsp.Param_IsSet(@SystemUserId) = 1)
        UPDATE  dsp.Setting
           SET  SystemUserId = @SystemUserId;

    IF (dsp.Param_IsSet(@AppUserId) = 1)
        UPDATE  dsp.Setting
           SET  AppUserId = @AppUserId;

    IF (dsp.Param_IsSet(@MaintenanceMode) = 1)
        UPDATE  dsp.Setting
           SET  MaintenanceMode = @MaintenanceMode;

    IF (dsp.Param_IsSet(@IsVersioningEnable) = 1)
        UPDATE  dsp.Setting
           SET  IsVersioningEnable = @IsVersioningEnable;

    IF (dsp.Param_IsSet(@IsEnabledInitNewAppVersion) = 1)
        UPDATE  dsp.Setting
           SET  IsEnabledInitNewAppVersion = @IsEnabledInitNewAppVersion;

END;











GO
PRINT N'Creating [dsp].[Log_IsEnabled]'
GO


CREATE FUNCTION [dsp].[Log_IsEnabled] ()
RETURNS BIT
AS
BEGIN
    DECLARE @Log_IsEnabled BIT = CAST(SESSION_CONTEXT(N'dsp.Log_IsEnabled') AS BIT);
    IF (@Log_IsEnabled IS NOT NULL)
        RETURN @Log_IsEnabled;

    SELECT  @Log_IsEnabled = LU.IsEnabled
      FROM  dsp.LogUser AS LU
     WHERE  LU.UserName = SYSTEM_USER;

    SET @Log_IsEnabled = ISNULL(@Log_IsEnabled, 0);
    EXEC sys.sp_set_session_context 'dsp.Log_IsEnabled', @Log_IsEnabled, @read_only = 0;

    RETURN @Log_IsEnabled;
END;







GO
PRINT N'Creating [dsp].[Log_FormatMessage2]'
GO
CREATE	FUNCTION [dsp].[Log_FormatMessage2] (@ProcId INT,
	@Message TSTRING,
	@Elipsis BIT = 0,
	@Param0 TSTRING = '<notset>',
	@Param1 TSTRING = '<notset>',
	@Param2 TSTRING = '<notset>',
	@Param3 TSTRING = '<notset>',
	@Param4 TSTRING = '<notset>',
	@Param5 TSTRING = '<notset>')
RETURNS TSTRING
AS
BEGIN
	SET @Elipsis = ISNULL(@Elipsis, 0);

	-- Validate Params
	SET @Param0 = dsp.Formatter_FormatParam(@Param0);
	SET @Param1 = dsp.Formatter_FormatParam(@Param1);
	SET @Param2 = dsp.Formatter_FormatParam(@Param2);
	SET @Param3 = dsp.Formatter_FormatParam(@Param3);
	SET @Param4 = dsp.Formatter_FormatParam(@Param4);
	SET @Param5 = dsp.Formatter_FormatParam(@Param5);

	-- Replace Message
	SET @Message = dsp.Formatter_FormatString(@Message);
	SET @Message = REPLACE(@Message, '{0}', @Param0);
	SET @Message = REPLACE(@Message, '{1}', @Param1);
	SET @Message = REPLACE(@Message, '{2}', @Param2);
	SET @Message = REPLACE(@Message, '{3}', @Param3);
	SET @Message = REPLACE(@Message, '{4}', @Param4);
	SET @Message = REPLACE(@Message, '{5}', @Param5);

	IF (@Elipsis = 1)
	BEGIN
		DECLARE @LastString TSTRING = SUBSTRING(@Message, LEN(@Message), 1);
		IF (@LastString NOT LIKE '[.?!:>;]')
			SET @Message = @Message + ' ...';
	END;

	-- Set Schema and ProcName
	DECLARE @ProcName TSTRING = ISNULL(OBJECT_NAME(@ProcId), '(NoSP)');
	DECLARE @SchemaName TSTRING = OBJECT_SCHEMA_NAME(@ProcId);
	IF (@SchemaName IS NOT NULL)
		SET @ProcName = @SchemaName + '.' + @ProcName;

	-- Format message 
	DECLARE @msg TSTRING = @ProcName + '> ' + @Message;
	RETURN dsp.String_ReplaceEnter(@msg);
END;




















GO
PRINT N'Creating [dsp].[Log_$CheckFilters]'
GO

-- returns 1, should the message be printed
CREATE FUNCTION [dsp].[Log_$CheckFilters] (@Message TSTRING)
RETURNS BIT
AS
BEGIN
	-- return 0 if @message likes exclude filters
	IF EXISTS (SELECT		1
					FROM	dsp.LogFilterSetting AS LFS
				WHERE	LFS.UserName = SYSTEM_USER AND	LFS.IsExludedFilter = 1 AND @Message LIKE '%' + LFS.Log_Filter + '%')
		RETURN 0;

	-- return 1 if include filters are empty
	IF NOT EXISTS (SELECT		1
						FROM	dsp.LogFilterSetting AS LFS
					WHERE	LFS.UserName = SYSTEM_USER AND	LFS.IsExludedFilter = 0)
		RETURN 1;

	--  return 1 if @message likes include filters  
	IF EXISTS (SELECT		1
					FROM	dsp.LogFilterSetting AS LFS
				WHERE	LFS.UserName = SYSTEM_USER AND	LFS.IsExludedFilter = 0 AND @Message LIKE '%' + LFS.Log_Filter + '%')
		RETURN 1;

	RETURN 0;
END;


GO
PRINT N'Creating [dsp].[Log_Trace]'
GO
CREATE PROCEDURE [dsp].[Log_Trace]
    @ProcId AS INT, @Message AS TSTRING, @Param0 AS TSTRING = '<notset>', @Param1 AS TSTRING = '<notset>', @Param2 AS TSTRING = '<notset>',
    @Param3 AS TSTRING = '<notset>', @Param4 AS TSTRING = '<notset>', @Param5 AS TSTRING = '<notset>', @Elipse BIT = 1, @IsHeader BIT = 0
AS
BEGIN
    DECLARE @IsProductionEnvironment BIT;
    EXEC dsp.Setting_GetProps @IsProductionEnvironment = @IsProductionEnvironment OUTPUT;
    IF (@IsProductionEnvironment = 1)
        RETURN;

    -- check is log enbaled (fast)
    DECLARE @Log_IsEnabled BIT = CAST(SESSION_CONTEXT(N'dsp.Log_IsEnabled') AS BIT);
    IF (@Log_IsEnabled IS NOT NULL AND  @Log_IsEnabled = 0)
        RETURN;

    -- check is log enbaled
    IF (dsp.Log_IsEnabled() = 0)
        RETURN;

    -- Format Message
    DECLARE @Msg TSTRING = dsp.Log_FormatMessage2(@ProcId, @Message, @Elipse, @Param0, @Param1, @Param2, @Param3, @Param4, @Param5);

    -- Manage header
    IF (@IsHeader = 1)
        SET @Msg = dsp.String_ReplaceEnter(N'\n-----------------------\n-- ' + @Msg + N'\n-----------------------');

    -- Check Filter
    IF (dsp.[Log_$CheckFilters](@Msg) = 0)
        RETURN;

    -- Print with Black Color
    -- PRINT @Msg;
    RAISERROR(@Msg, 0, 1) WITH NOWAIT; -- force to flush the buffer
END;
























GO
PRINT N'Creating [dbo].[Init_$CreateUsersAndRoles]'
GO
CREATE PROCEDURE [dbo].[Init_$CreateUsersAndRoles]
AS
BEGIN
    SET NOCOUNT ON;

    -- Creating Loyalty_System User; We need to assign system role later after creationg the system club 
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Creating the System User';
    DECLARE @UserId_Admin INT;
	EXEC dbo.User_CreateByAuthUserName @UserName = 'Log_Admin', @AuditUserId = NULL, @UserId = @UserId_Admin OUT;	
    EXEC dsp.Setting_SetProps @SystemUserId = @UserId_Admin;

    -- Creating the App User
    --EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Creating the App User';
    --DECLARE @UserName_AppUser TSTRING = const.UserName_App();
    --DECLARE @UserId_AppUser INT;
	
    --EXEC dbo.User_CreateByAuthUserName @UserName = @UserName_System, @AuditUserId = NULL, @UserId = @UserId_System OUT;
	
    --SET @UserId_AppUser = SCOPE_IDENTITY();
    --EXEC dsp.Setting_SetProps @AppUserId = @UserId_AppUser;

END;


GO
PRINT N'Creating [err].[NotSupportedId]'
GO

CREATE FUNCTION [err].[NotSupportedId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55017;  
END
GO
PRINT N'Creating [err].[ThrowNotSupported]'
GO

CREATE PROCEDURE [err].[ThrowNotSupported] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.NotSupportedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_AddUserPermission]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_AddUserPermission]
    @SecurityDescriptorId BIGINT, @PermissionGroupId INT, @UserId INT, @AuditUserId INT
AS
BEGIN
    INSERT  dspAuth.SecurityDescriptorUserPermission (SecurityDescriptorId, UserId, PermissionGroupId, CreatedByUserId)
    VALUES (@SecurityDescriptorId, @UserId, @PermissionGroupId, @AuditUserId);
END;

GO
PRINT N'Creating [dsp].[Synonym_ObjectExists]'
GO
CREATE	FUNCTION [dsp].[Synonym_ObjectExists] (@SchemaName TSTRING,
	@SynonymName TSTRING)
RETURNS BIT
BEGIN
	RETURN IIF(
		EXISTS (SELECT		1 FROM sys.synonyms WHERE name = @SynonymName AND schema_id = SCHEMA_ID(@SchemaName) AND
														base_object_name NOT LIKE '%NullServer%'),
		1,
		0);
END;


GO
PRINT N'Creating [tSQLt].[Private_NewTestClassList]'
GO
CREATE TABLE [tSQLt].[Private_NewTestClassList]
(
[ClassName] [nvarchar] (450) NOT NULL
)
GO
PRINT N'Creating primary key [PK__Private___F8BF561A3B975135] on [tSQLt].[Private_NewTestClassList]'
GO
ALTER TABLE [tSQLt].[Private_NewTestClassList] ADD CONSTRAINT [PK__Private___F8BF561A3B975135] PRIMARY KEY CLUSTERED  ([ClassName])
GO
PRINT N'Creating [tSQLt].[Private_MarkSchemaAsTestClass]'
GO
CREATE PROCEDURE [tSQLt].[Private_MarkSchemaAsTestClass]
  @QuotedClassName NVARCHAR(MAX)
AS
BEGIN
  SET NOCOUNT ON;

  DECLARE @UnquotedClassName NVARCHAR(MAX);

  SELECT @UnquotedClassName = name
    FROM sys.schemas
   WHERE QUOTENAME(name) = @QuotedClassName;

  EXEC sp_addextendedproperty @name = N'tSQLt.TestClass', 
                              @value = 1,
                              @level0type = 'SCHEMA',
                              @level0name = @UnquotedClassName;

  INSERT INTO tSQLt.Private_NewTestClassList(ClassName)
  SELECT @UnquotedClassName
   WHERE NOT EXISTS
             (
               SELECT * 
                 FROM tSQLt.Private_NewTestClassList AS NTC
                 WITH(UPDLOCK,ROWLOCK,HOLDLOCK)
                WHERE NTC.ClassName = @UnquotedClassName
             );
END;
GO
PRINT N'Creating [dsperr].[AccessDeniedOrObjectNotExistsId]'
GO

CREATE FUNCTION [dsperr].[AccessDeniedOrObjectNotExistsId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55002;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowAccessDeniedOrObjectNotExists]'
GO

CREATE PROCEDURE [dsperr].[ThrowAccessDeniedOrObjectNotExists] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.AccessDeniedOrObjectNotExistsId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_GetProps]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_GetProps]
    @SecurityDescriptorId BIGINT, @ObjectId BIGINT = NULL OUT, @ObjectTypeId INT = NULL OUT
AS
BEGIN
    SET @ObjectId = NULL;
    SET @ObjectTypeId = NULL;

    SELECT  @ObjectId = SD.ObjectId, @ObjectTypeId = SD.ObjectTypeId
      FROM  dspAuth.SecurityDescriptor AS SD
     WHERE  SD.SecurityDescriptorId = @SecurityDescriptorId;

    IF (@ObjectId IS NULL) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID;
END;
GO
PRINT N'Creating [dsp].[Table_ExtendedProperty]'
GO
CREATE   FUNCTION [dsp].[Table_ExtendedProperty] (@TableId INT)
RETURNS TJSON
AS
BEGIN
    DECLARE @ExtendedProperties TJSON = (   SELECT  EP.name AS ExtendedPropertyKey, EP.value AS ExtendedPropertyValue
                                              FROM  sys.extended_properties EP
                                             WHERE  EP.major_id = @TableId --
                                                AND EP.class = 1 --
                                                AND EP.minor_id = 0
                                            FOR JSON AUTO);

    RETURN @ExtendedProperties;
END;
GO
PRINT N'Creating [err].[ObjectIsInUseId]'
GO

CREATE FUNCTION [err].[ObjectIsInUseId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55005;  
END
GO
PRINT N'Creating [err].[ThrowObjectIsInUse]'
GO

CREATE PROCEDURE [err].[ThrowObjectIsInUse] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.ObjectIsInUseId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_RemoveRolePermission]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_RemoveRolePermission]
    @SecurityDescriptorId BIGINT, @PermissionGroupId INT, @RoleId INT
AS
BEGIN
	-- Check if role has not the permission on object
    IF NOT EXISTS (   SELECT    1
                        FROM    dspAuth.SecurityDescriptorRolePermission AS SDRP
                       WHERE SDRP.RoleId = @RoleId --
                          AND   SDRP.PermissionGroupId = @PermissionGroupId --
                          AND   SDRP.SecurityDescriptorId = @SecurityDescriptorId)
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID;

	-- Delete permission
    DELETE  dspAuth.SecurityDescriptorRolePermission
     WHERE  RoleId = @RoleId AND PermissionGroupId = @PermissionGroupId AND SecurityDescriptorId = @SecurityDescriptorId;
END;
GO
PRINT N'Creating [dsperr].[ProductionEnvinronmentIsTurnedOnId]'
GO

CREATE FUNCTION [dsperr].[ProductionEnvinronmentIsTurnedOnId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55029;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowProductionEnvinronmentIsTurnedOn]'
GO

CREATE PROCEDURE [dsperr].[ThrowProductionEnvinronmentIsTurnedOn] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.ProductionEnvinronmentIsTurnedOnId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Util_ProtectProductionEnvironment]'
GO

CREATE PROCEDURE [dsp].[Util_ProtectProductionEnvironment]
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @IsProductionEnvironment BIT;
    EXEC dsp.Setting_GetProps @IsProductionEnvironment = @IsProductionEnvironment OUTPUT;

    -- Validate IsProductionEnvironment
    IF (@IsProductionEnvironment = 1) --
        EXEC dsperr.ThrowProductionEnvinronmentIsTurnedOn @ProcId = @@PROCID, @Message = 'This operation can not be executed in ProductionEnvironment';
END;
GO
PRINT N'Creating [dsp].[Table_GetExtendedPropertyValueByKey]'
GO
CREATE FUNCTION [dsp].[Table_GetExtendedPropertyValueByKey] (@SchemaName TSTRING = 'dbo',
    @TableName AS TSTRING,
    @ExtendedPropertyKey
AS  TSTRING)
RETURNS TABLE
RETURN SELECT   EP.name AS ExtendedPropertyKey, CAST(EP.value AS NVARCHAR(MAX /*NCQ*/)) ExtendedPropertyValue
         FROM   sys.tables T
                INNER JOIN sys.schemas S ON S.schema_id = T.schema_id
                INNER JOIN sys.extended_properties EP ON T.object_id = EP.major_id
        WHERE   EP.class = 1 --
           AND  EP.minor_id = 0 --
           AND  T.name = @TableName --
           AND  EP.name = @ExtendedPropertyKey --
           AND  S.name = @SchemaName;

GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_RemoveUserPermission]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_RemoveUserPermission]
    @SecurityDescriptorId BIGINT, @PermissionGroupId INT, @UserId INT
AS
BEGIN
	-- Check if role has not the permission on object
    IF NOT EXISTS (   SELECT    1
                        FROM    dspAuth.SecurityDescriptorUserPermission AS SDRP
                       WHERE SDRP.UserId = @UserId --
                          AND   SDRP.PermissionGroupId = @PermissionGroupId --
                          AND   SDRP.SecurityDescriptorId = @SecurityDescriptorId)
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID;

	-- Delete permission
    DELETE  dspAuth.SecurityDescriptorUserPermission
     WHERE  UserId = @UserId AND PermissionGroupId = @PermissionGroupId AND SecurityDescriptorId = @SecurityDescriptorId;
END;
GO
PRINT N'Creating [dbo].[Setting]'
GO
CREATE TABLE [dbo].[Setting]
(
[SettingId] [int] NOT NULL CONSTRAINT [DF_Setting_SettingId] DEFAULT ((1)),
[AppSetting1] [int] NOT NULL CONSTRAINT [DF_Setting_AppSetting1] DEFAULT ((0)),
[AppSetting2] [int] NOT NULL CONSTRAINT [DF_Setting_AppSetting2] DEFAULT ((0))
)
GO
PRINT N'Creating primary key [PK_Setting] on [dbo].[Setting]'
GO
ALTER TABLE [dbo].[Setting] ADD CONSTRAINT [PK_Setting] PRIMARY KEY CLUSTERED  ([SettingId])
GO
PRINT N'Creating [dbo].[Init_Cleanup]'
GO
CREATE PROCEDURE [dbo].[Init_Cleanup]
AS
BEGIN
    SET NOCOUNT ON;

    -- Protect production environment
    EXEC dsp.Util_ProtectProductionEnvironment;

    -- Delete Setting
    DELETE  dbo.Setting;

    DELETE  dbo.Users;

END;
GO
PRINT N'Creating [dsp].[Table_GetForeignKeys]'
GO
CREATE   FUNCTION [dsp].[Table_GetForeignKeys] (@schemaName TSTRING = 'dbo',
    @tablename TSTRING)
RETURNS TABLE
AS
RETURN (   SELECT   fk.object_id AS ConstraintId, fk.name, ct.object_id, ct.name AS tablename
             FROM   sys.foreign_keys AS fk
                    INNER JOIN sys.tables AS ct ON fk.parent_object_id = ct.object_id
                    INNER JOIN sys.schemas AS cs ON ct.schema_id = cs.schema_id
            WHERE   ct.name = @tablename AND cs.name = @schemaName);


GO
PRINT N'Creating [tSQLt].[TestClasses]'
GO
----------------------------------------------------------------------
CREATE VIEW [tSQLt].[TestClasses]
AS
  SELECT s.name AS Name, s.schema_id AS SchemaId
    FROM sys.extended_properties ep
    JOIN sys.schemas s
      ON ep.major_id = s.schema_id
   WHERE ep.name = N'tSQLt.TestClass';
GO
PRINT N'Creating [tSQLt].[Private_GetSchemaId]'
GO
CREATE FUNCTION [tSQLt].[Private_GetSchemaId](@SchemaName NVARCHAR(MAX))
RETURNS INT
AS
BEGIN
  RETURN (
    SELECT TOP(1) schema_id
      FROM sys.schemas
     WHERE @SchemaName IN (name, QUOTENAME(name), QUOTENAME(name, '"'))
     ORDER BY 
        CASE WHEN name = @SchemaName THEN 0 ELSE 1 END
  );
END;
GO
PRINT N'Creating [tSQLt].[Private_IsTestClass]'
GO
CREATE FUNCTION [tSQLt].[Private_IsTestClass](@TestClassName NVARCHAR(MAX))
RETURNS BIT
AS
BEGIN
  RETURN 
    CASE 
      WHEN EXISTS(
             SELECT 1 
               FROM tSQLt.TestClasses
              WHERE SchemaId = tSQLt.Private_GetSchemaId(@TestClassName)
            )
      THEN 1
      ELSE 0
    END;
END;
GO
PRINT N'Creating [tSQLt].[Private_DisallowOverwritingNonTestSchema]'
GO
CREATE PROCEDURE [tSQLt].[Private_DisallowOverwritingNonTestSchema]
  @ClassName NVARCHAR(MAX)
AS
BEGIN
  IF SCHEMA_ID(@ClassName) IS NOT NULL AND tSQLt.Private_IsTestClass(@ClassName) = 0
  BEGIN
    RAISERROR('Attempted to execute tSQLt.NewTestClass on ''%s'' which is an existing schema but not a test class', 16, 10, @ClassName);
  END
END;
GO
PRINT N'Creating [err].[TooManyRequestId]'
GO

CREATE FUNCTION [err].[TooManyRequestId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55024;  
END
GO
PRINT N'Creating [err].[ThrowTooManyRequest]'
GO

CREATE PROCEDURE [err].[ThrowTooManyRequest] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.TooManyRequestId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[ThrowAccessDeniedOrObjectNotExists]'
GO
CREATE PROCEDURE [dsp].[ThrowAccessDeniedOrObjectNotExists]
    @ProcId INT, @ObjectTypeName TSTRING, @ObjectId TSTRING, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>',
    @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @ArgMessage TSTRING;
    EXEC @ArgMessage = dsp.Formatter_FormatMessage @Message = N'{"ObjectName": "{0}", "ObjectId": "{1}"}', @Param0 = @ObjectTypeName, @Param1 = @ObjectId;

    IF (@Message IS NOT NULL)
        SET @ArgMessage = JSON_MODIFY(@ArgMessage, '$.Message', @Message);

    DECLARE @ExceptionId INT = /* err.AccessDeniedOrObjectNotExistsId() */ 55002;
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @ArgMessage, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2,
        @Param3 = @Param3;
END;









GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_SecurityDescriptorByObject]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_SecurityDescriptorByObject]
    @ObjectId INT, @ObjectTypeId INT, @ThrowIfNotExists BIT = 1, @SecurityDescriptorId BIGINT = NULL OUT
AS
BEGIN
    SET @ThrowIfNotExists = ISNULL(@ThrowIfNotExists, 1);
    SET @SecurityDescriptorId = NULL;

    -- Find SecurityDescriptorId
    SELECT  @SecurityDescriptorId = SD.SecurityDescriptorId
      FROM  dspAuth.SecurityDescriptor AS SD
     WHERE  SD.ObjectTypeId = @ObjectTypeId AND SD.ObjectId = @ObjectId;

    -- 
    IF (@SecurityDescriptorId IS NULL AND   @ThrowIfNotExists = 1)
    BEGIN
        DECLARE @ObjectTypeName TSTRING;
        SELECT  @ObjectTypeName = OT.ObjectTypeName
          FROM  dspAuth.ObjectType AS OT
         WHERE  OT.ObjectTypeId = @ObjectTypeId;

        EXEC dsp.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @ObjectTypeName = @ObjectTypeName, @ObjectId = @ObjectId;
    END;

END;




GO
PRINT N'Creating [dbo].[Init_FillData]'
GO
CREATE PROCEDURE [dbo].[Init_FillData]
AS
BEGIN
    SET NOCOUNT ON;

    -- Initialize UserService
    EXEC IcUserService.dsp.Init;

    -- Initialize the app 
    EXEC dsp.Setting_SetProps @AppName = 'IcLoyalty', @AppVersion = '2.0.*';

    -- Init UsersAndRoles
    IF NOT EXISTS (SELECT   1 FROM  dbo.Users AS U)
        EXEC dbo.[Init_$CreateUsersAndRoles];
END;

GO
PRINT N'Creating [tSQLt].[Private_QuoteClassNameForNewTestClass]'
GO
CREATE FUNCTION [tSQLt].[Private_QuoteClassNameForNewTestClass](@ClassName NVARCHAR(MAX))
  RETURNS NVARCHAR(MAX)
AS
BEGIN
  RETURN 
    CASE WHEN @ClassName LIKE '[[]%]' THEN @ClassName
         ELSE QUOTENAME(@ClassName)
     END;
END;
GO
PRINT N'Creating [tSQLt].[DropClass]'
GO
CREATE PROCEDURE [tSQLt].[DropClass]
    @ClassName NVARCHAR(MAX)
AS
BEGIN
    DECLARE @Cmd NVARCHAR(MAX);

    WITH ObjectInfo(name, type) AS
         (
           SELECT QUOTENAME(SCHEMA_NAME(O.schema_id))+'.'+QUOTENAME(O.name) , O.type
             FROM sys.objects AS O
            WHERE O.schema_id = SCHEMA_ID(PARSENAME(@ClassName,1))
         ),
         TypeInfo(name) AS
         (
           SELECT QUOTENAME(SCHEMA_NAME(T.schema_id))+'.'+QUOTENAME(T.name)
             FROM sys.types AS T
            WHERE T.schema_id = SCHEMA_ID(PARSENAME(@ClassName,1))
         ),
         XMLSchemaInfo(name) AS
         (
           SELECT QUOTENAME(SCHEMA_NAME(XSC.schema_id))+'.'+QUOTENAME(XSC.name)
             FROM sys.xml_schema_collections AS XSC
            WHERE XSC.schema_id = SCHEMA_ID(PARSENAME(@ClassName,1))
         ),
         DropStatements(no,cmd) AS
         (
           SELECT 10,
                  'DROP ' +
                  CASE type WHEN 'P' THEN 'PROCEDURE'
                            WHEN 'PC' THEN 'PROCEDURE'
                            WHEN 'U' THEN 'TABLE'
                            WHEN 'IF' THEN 'FUNCTION'
                            WHEN 'TF' THEN 'FUNCTION'
                            WHEN 'FN' THEN 'FUNCTION'
                            WHEN 'V' THEN 'VIEW'
                   END +
                   ' ' + 
                   name + 
                   ';'
              FROM ObjectInfo
             UNION ALL
           SELECT 20,
                  'DROP TYPE ' +
                   name + 
                   ';'
              FROM TypeInfo
             UNION ALL
           SELECT 30,
                  'DROP XML SCHEMA COLLECTION ' +
                   name + 
                   ';'
              FROM XMLSchemaInfo
             UNION ALL
            SELECT 10000,'DROP SCHEMA ' + QUOTENAME(name) +';'
              FROM sys.schemas
             WHERE schema_id = SCHEMA_ID(PARSENAME(@ClassName,1))
         ),
         StatementBlob(xml)AS
         (
           SELECT cmd [text()]
             FROM DropStatements
            ORDER BY no
              FOR XML PATH(''), TYPE
         )
    SELECT @Cmd = xml.value('/', 'NVARCHAR(MAX)') 
      FROM StatementBlob;

    EXEC(@Cmd);
END;
GO
PRINT N'Creating [tSQLt].[NewTestClass]'
GO
CREATE PROCEDURE [tSQLt].[NewTestClass]
    @ClassName NVARCHAR(MAX)
AS
BEGIN
  BEGIN TRY
    EXEC tSQLt.Private_DisallowOverwritingNonTestSchema @ClassName;

    EXEC tSQLt.DropClass @ClassName = @ClassName;

    DECLARE @QuotedClassName NVARCHAR(MAX);
    SELECT @QuotedClassName = tSQLt.Private_QuoteClassNameForNewTestClass(@ClassName);

    EXEC ('CREATE SCHEMA ' + @QuotedClassName);  
    EXEC tSQLt.Private_MarkSchemaAsTestClass @QuotedClassName;
  END TRY
  BEGIN CATCH
    DECLARE @ErrMsg NVARCHAR(MAX);SET @ErrMsg = ERROR_MESSAGE() + ' (Error originated in ' + ERROR_PROCEDURE() + ')';
    DECLARE @ErrSvr INT;SET @ErrSvr = ERROR_SEVERITY();
    
    RAISERROR(@ErrMsg, @ErrSvr, 10);
  END CATCH;
END;
GO
PRINT N'Creating [dspAuth].[Validate_CheckAccess]'
GO
CREATE PROCEDURE [dspAuth].[Validate_CheckAccess]
	@ProcId INT, @Permissions TSTRING, @PermissionId INT, @ThrowIfNotAccess BIT = 1, @HasPermission BIT = NULL OUT
AS
BEGIN
	-- Prepare input
	SET @HasPermission = 0;
	SET @ThrowIfNotAccess = ISNULL(@ThrowIfNotAccess, 1);
	SET @Permissions = STUFF(@Permissions, 1, 1, ',');
	SET @Permissions = STUFF(@Permissions, LEN(@Permissions), 1, ',');
	DECLARE @PermissionTemplate TSTRING = ',' + dsp.Convert_ToString(@PermissionId) + ',';

	-- Check access
	SET @HasPermission = IIF(CHARINDEX(@PermissionTemplate, @Permissions) > 0, 1, 0);

	-- Throw exception
	IF (@HasPermission = 0 AND @ThrowIfNotAccess = 1) --
		EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId;
END;
GO
PRINT N'Creating [dbo].[Init_FillExceptions]'
GO

CREATE PROCEDURE [dbo].[Init_FillExceptions]
AS
BEGIN
    SET NOCOUNT ON;

	-- delclare your application exceptions here. NOTE: ExceptionId must be started from 56000
	INSERT	dsp.Exception (ExceptionId, ExceptionName, Description)
	VALUES (56001, N'Error1', N'Error1 description'),
		(56002, N'Error2', N'Error2 description');

END
		
GO
PRINT N'Creating [dsp].[Table_Params]'
GO
CREATE FUNCTION [dsp].[Table_Params] (@TableId INT)
RETURNS TABLE
AS
RETURN (   SELECT   OBJECT_SCHEMA_NAME(T.object_id) AS SchemaName, T.name AS TableName, C.name AS ColumnName,C.column_id AS ColumnId ,C.is_identity IsIdentity, Y.name AS DataType,
               C.is_nullable IsNullable, C.max_length MaxLength, C.collation_name CollationName, Y.is_user_defined IsUserDefined
             FROM   sys.tables T
                    INNER JOIN sys.columns C ON T.object_id = C.object_id
                    INNER JOIN sys.types Y ON C.system_type_id = Y.system_type_id AND   C.user_type_id = Y.user_type_id
            WHERE   T.object_id = @TableId);


GO
PRINT N'Creating [dsp].[Table_GetParamsJson]'
GO
CREATE   FUNCTION [dsp].[Table_GetParamsJson] (@TableId INT)
RETURNS TJSON
AS
BEGIN
    DECLARE @Params TJSON = (   SELECT  TP.ColumnId, TP.ColumnName, TP.IsIdentity, TP.DataType, TP.IsNullable, TP.MaxLength, TP.CollationName, TP.IsUserDefined
                                  FROM  dsp.Table_Params(@TableId) AS TP
                                FOR JSON AUTO);
    RETURN @Params;
END;
GO
PRINT N'Creating [tSQLt].[TestResult]'
GO
CREATE TABLE [tSQLt].[TestResult]
(
[Id] [int] NOT NULL IDENTITY(1, 1),
[Class] [nvarchar] (max) NOT NULL,
[TestCase] [nvarchar] (max) NOT NULL,
[TranName] [nvarchar] (max) NOT NULL,
[Result] [nvarchar] (max) NULL,
[Msg] [nvarchar] (max) NULL,
[TestStartTime] [datetime] NOT NULL CONSTRAINT [DF:TestResult(TestStartTime)] DEFAULT (getdate()),
[TestEndTime] [datetime] NULL,
[Name] AS ((quotename([Class])+'.')+quotename([TestCase]))
)
GO
PRINT N'Creating primary key [PK__TestResu__3214EC077DDA1951] on [tSQLt].[TestResult]'
GO
ALTER TABLE [tSQLt].[TestResult] ADD CONSTRAINT [PK__TestResu__3214EC077DDA1951] PRIMARY KEY CLUSTERED  ([Id])
GO
PRINT N'Creating [tSQLt].[Private_CleanTestResult]'
GO
CREATE PROCEDURE [tSQLt].[Private_CleanTestResult]
AS
BEGIN
   DELETE FROM tSQLt.TestResult;
END;
GO
PRINT N'Creating [err].[UserIsDisabledId]'
GO

CREATE FUNCTION [err].[UserIsDisabledId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55019;  
END
GO
PRINT N'Creating [err].[ThrowUserIsDisabled]'
GO

CREATE PROCEDURE [err].[ThrowUserIsDisabled] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.UserIsDisabledId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Table_GetPrimaryKey]'
GO
CREATE FUNCTION [dsp].[Table_GetPrimaryKey] (@Schemaname TSTRING,
    @TableName TSTRING)
RETURNS TSTRING
AS
BEGIN
    RETURN (   SELECT   KU.COLUMN_NAME AS PrimaryColumn
                 FROM   INFORMATION_SCHEMA.TABLE_CONSTRAINTS AS TC
                        INNER JOIN INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS KU ON --
                        TC.CONSTRAINT_TYPE = 'PRIMARY KEY' AND  TC.CONSTRAINT_NAME = KU.CONSTRAINT_NAME AND KU.TABLE_NAME = @TableName);
END;




GO
PRINT N'Creating [tSQLt].[Private_SysTypes]'
GO
CREATE VIEW [tSQLt].[Private_SysTypes] AS SELECT * FROM sys.types AS T;
GO
PRINT N'Creating [tSQLt].[Private_GetFullTypeName]'
GO
CREATE FUNCTION [tSQLt].[Private_GetFullTypeName](@TypeId INT, @Length INT, @Precision INT, @Scale INT, @CollationName NVARCHAR(MAX))
RETURNS TABLE
AS
RETURN SELECT X.SchemaName + '.' + X.Name + X.Suffix + X.Collation AS TypeName, X.SchemaName, X.Name, X.Suffix, X.is_table_type AS IsTableType
FROM(
  SELECT QUOTENAME(SCHEMA_NAME(T.schema_id)) SchemaName, QUOTENAME(T.name) Name,
              CASE WHEN T.max_length = -1
                    THEN ''
                   WHEN @Length = -1
                    THEN '(MAX)'
                   WHEN T.name LIKE 'n%char'
                    THEN '(' + CAST(@Length / 2 AS NVARCHAR) + ')'
                   WHEN T.name LIKE '%char' OR T.name LIKE '%binary'
                    THEN '(' + CAST(@Length AS NVARCHAR) + ')'
                   WHEN T.name IN ('decimal', 'numeric')
                    THEN '(' + CAST(@Precision AS NVARCHAR) + ',' + CAST(@Scale AS NVARCHAR) + ')'
                   ELSE ''
               END Suffix,
              CASE WHEN @CollationName IS NULL OR T.is_user_defined = 1 THEN ''
                   ELSE ' COLLATE ' + @CollationName
               END Collation,
               T.is_table_type
          FROM tSQLt.Private_SysTypes AS T WHERE T.user_type_id = @TypeId
          )X;
GO
PRINT N'Creating [tSQLt].[Private_CreateProcedureSpy]'
GO
CREATE PROCEDURE [tSQLt].[Private_CreateProcedureSpy]
    @ProcedureObjectId INT,
    @OriginalProcedureName NVARCHAR(MAX),
    @LogTableName NVARCHAR(MAX),
    @CommandToExecute NVARCHAR(MAX) = NULL
AS
BEGIN
    DECLARE @Cmd NVARCHAR(MAX);
    DECLARE @ProcParmList NVARCHAR(MAX),
            @TableColList NVARCHAR(MAX),
            @ProcParmTypeList NVARCHAR(MAX),
            @TableColTypeList NVARCHAR(MAX);
            
    DECLARE @Seperator CHAR(1),
            @ProcParmTypeListSeparater CHAR(1),
            @ParamName sysname,
            @TypeName sysname,
            @IsOutput BIT,
            @IsCursorRef BIT,
            @IsTableType BIT;
            

      
    SELECT @Seperator = '', @ProcParmTypeListSeparater = '', 
           @ProcParmList = '', @TableColList = '', @ProcParmTypeList = '', @TableColTypeList = '';
      
    DECLARE Parameters CURSOR FOR
     SELECT p.name, t.TypeName, p.is_output, p.is_cursor_ref, t.IsTableType
       FROM sys.parameters p
       CROSS APPLY tSQLt.Private_GetFullTypeName(p.user_type_id,p.max_length,p.precision,p.scale,NULL) t
      WHERE object_id = @ProcedureObjectId;
    
    OPEN Parameters;
    
    FETCH NEXT FROM Parameters INTO @ParamName, @TypeName, @IsOutput, @IsCursorRef, @IsTableType;
    WHILE (@@FETCH_STATUS = 0)
    BEGIN
        IF @IsCursorRef = 0
        BEGIN
            SELECT @ProcParmList = @ProcParmList + @Seperator + 
                                   CASE WHEN @IsTableType = 1 
                                     THEN '(SELECT * FROM '+@ParamName+' FOR XML PATH(''row''),TYPE,ROOT('''+STUFF(@ParamName,1,1,'')+'''))' 
                                     ELSE @ParamName 
                                   END, 
                   @TableColList = @TableColList + @Seperator + '[' + STUFF(@ParamName,1,1,'') + ']', 
                   @ProcParmTypeList = @ProcParmTypeList + @ProcParmTypeListSeparater + @ParamName + ' ' + @TypeName + 
                                       CASE WHEN @IsTableType = 1 THEN ' READONLY' ELSE ' = NULL ' END+ 
                                       CASE WHEN @IsOutput = 1 THEN ' OUT' ELSE '' END, 
                   @TableColTypeList = @TableColTypeList + ',[' + STUFF(@ParamName,1,1,'') + '] ' + 
                          CASE 
                               WHEN @IsTableType = 1
                               THEN 'XML'
                               WHEN @TypeName LIKE '%nchar%'
                                 OR @TypeName LIKE '%nvarchar%'
                               THEN 'NVARCHAR(MAX)'
                               WHEN @TypeName LIKE '%char%'
                               THEN 'VARCHAR(MAX)'
                               ELSE @TypeName
                          END + ' NULL';

            SELECT @Seperator = ',';        
            SELECT @ProcParmTypeListSeparater = ',';
        END
        ELSE
        BEGIN
            SELECT @ProcParmTypeList = @ProcParmTypeListSeparater + @ParamName + ' CURSOR VARYING OUTPUT';
            SELECT @ProcParmTypeListSeparater = ',';
        END;
        
        FETCH NEXT FROM Parameters INTO @ParamName, @TypeName, @IsOutput, @IsCursorRef, @IsTableType;
    END;
    
    CLOSE Parameters;
    DEALLOCATE Parameters;
    
    DECLARE @InsertStmt NVARCHAR(MAX);
    SELECT @InsertStmt = 'INSERT INTO ' + @LogTableName + 
                         CASE WHEN @TableColList = '' THEN ' DEFAULT VALUES'
                              ELSE ' (' + @TableColList + ') SELECT ' + @ProcParmList
                         END + ';';
                         
    SELECT @Cmd = 'CREATE TABLE ' + @LogTableName + ' (_id_ int IDENTITY(1,1) PRIMARY KEY CLUSTERED ' + @TableColTypeList + ');';
    EXEC(@Cmd);

    SELECT @Cmd = 'CREATE PROCEDURE ' + @OriginalProcedureName + ' ' + @ProcParmTypeList + 
                  ' AS BEGIN ' + 
                     @InsertStmt + 
                     ISNULL(@CommandToExecute, '') + ';' +
                  ' END;';
    EXEC(@Cmd);

    RETURN 0;
END;
GO
PRINT N'Creating [dsp].[Table_CompareData]'
GO
CREATE PROCEDURE [dsp].[Table_CompareData]
	@SourceSchemaName TSTRING = NULL, @SourceTableName TSTRING = NULL, @DestinationTableName TSTRING, @DestinationSchemaName TSTRING = 'dbo',
	@IsWithDelete BIT = 1
AS
BEGIN
	SET @SourceTableName = ISNULL(@SourceSchemaName, '#' + @DestinationTableName);

	DECLARE @SourceTable TSTRING = @SourceTableName;
	IF (dsp.Formatter_FormatString(@SourceSchemaName) IS NOT NULL)
		SET @SourceTable = @SourceSchemaName + '.' + @SourceTableName;

	DECLARE @DestinationTable TSTRING = @DestinationTableName;
	IF (dsp.Formatter_FormatString(@DestinationSchemaName) IS NOT NULL)
		SET @DestinationTable = @DestinationSchemaName + '.' + @DestinationTableName;

	-- find primary key
	DECLARE @PrimaryKey TSTRING;
	SELECT	@PrimaryKey = COLUMN_NAME
	FROM	INFORMATION_SCHEMA.KEY_COLUMN_USAGE
	WHERE	OBJECTPROPERTY(OBJECT_ID(CONSTRAINT_SCHEMA + '.' + QUOTENAME(CONSTRAINT_NAME)), 'IsPrimaryKey') = 1 AND TABLE_NAME = @DestinationTableName AND
			TABLE_SCHEMA = @DestinationSchemaName;

	IF (@PrimaryKey IS NULL)
		EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'Could not find Primary key for table {0}!', @Param0 = @DestinationTableName

	-- columns
	DECLARE @ColumnsForUpdate TSTRING =
			(	SELECT		',' + c.name + '=S.' + c.name
				FROM	sys.columns c
						INNER JOIN sys.objects o ON o.object_id = c.object_id
						LEFT JOIN sys.types t ON t.user_type_id = c.user_type_id
				WHERE	o.type = 'U' AND SCHEMA_NAME(o.schema_id) = @DestinationSchemaName AND	o.name = @DestinationTableName AND	c.is_identity = 0 AND
						c.name <> @PrimaryKey
				FOR XML PATH(''));

	SET @ColumnsForUpdate = STUFF(@ColumnsForUpdate, 1, 1, '');

		-- columns
	DECLARE @ColumnsForInsert TSTRING =
			(	SELECT		',' + c.name 
				FROM	sys.columns c
						INNER JOIN sys.objects o ON o.object_id = c.object_id
						LEFT JOIN sys.types t ON t.user_type_id = c.user_type_id
				WHERE	o.type = 'U' AND SCHEMA_NAME(o.schema_id) = @DestinationSchemaName AND	o.name = @DestinationTableName 	
				FOR XML PATH(''));

	SET @ColumnsForInsert = STUFF(@ColumnsForInsert, 1, 1, '');

	DECLARE @Sql TSTRING =
		'
		UPDATE @DestinationTable SET @ColumnsForUpdate FROM @SourceTable AS S WHERE S.@PrimaryKey=@DestinationTable.@PrimaryKey;

		INSERT @DestinationTable (@ColumnsForInsert) SELECT * FROM @SourceTable AS S WHERE S.@PrimaryKey NOT IN (SELECT @PrimaryKey FROM @DestinationTable AS S);

		IF (@IsWithDelete=1)
			DELETE @DestinationTable WHERE @PrimaryKey NOT IN (SELECT @PrimaryKey FROM @SourceTable AS S);
	';
	SET @Sql = REPLACE(@Sql, '@IsWithDelete', @IsWithDelete);
	SET @Sql = REPLACE(@Sql, '@SourceTable', @SourceTable);
	SET @Sql = REPLACE(@Sql, '@DestinationTable', @DestinationTable);
	SET @Sql = REPLACE(@Sql, '@PrimaryKey', @PrimaryKey);
	SET @Sql = REPLACE(@Sql, '@ColumnsForUpdate', @ColumnsForUpdate);
	SET @Sql = REPLACE(@Sql, '@ColumnsForInsert', @ColumnsForInsert);

	EXEC (@Sql);
END;





GO
PRINT N'Creating [const].[Application_IcLoyalty]'
GO
CREATE   FUNCTION [const].[Application_IcLoyalty] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dbo].[Init_FillLookups]'
GO

CREATE PROCEDURE [dbo].[Init_FillLookups]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @TableName TSTRING;

	-- SQL Prompt formatting off
    -- Application
    SET @TableName = N'Application';
    SELECT  *
    INTO    #Application
      FROM  dbo.Application
     WHERE  1 = 0;
    INSERT INTO #Application (ApplicationId, ApplicationName)
    VALUES (const.Application_IcLoyalty(), N'Loyalty')
        

    EXEC dsp.Table_CompareData @DestinationTableName = @TableName;
END
		
GO
PRINT N'Creating [dsp].[Table_GetTransactionalTableWithoutCreatedTime]'
GO
CREATE FUNCTION [dsp].[Table_GetTransactionalTableWithoutCreatedTime] (@SchemaName TSTRING = NULL,
    @TableName TSTRING = NULL)
RETURNS TABLE
AS
RETURN (   SELECT DISTINCT  S.name AS SchemaName, T.name AS TableName, GEPV.ExtendedPropertyValue
             FROM   sys.tables T
                    INNER JOIN sys.columns C ON C.object_id = T.object_id
                    INNER JOIN sys.schemas S ON S.schema_id = T.schema_id
                    CROSS APPLY dsp.Table_GetExtendedPropertyValueByKey(S.name, T.name, 'TemporalTypeId') GEPV
            WHERE   GEPV.ExtendedPropertyValue = 3 AND  C.name <> 'CreatedTime' AND (S.name = @SchemaName OR S.name IS NULL) AND (T.name = @TableName OR T.name IS NULL) );




GO
PRINT N'Creating [tSQLt].[Private_GetCursorForRunAll]'
GO
CREATE PROCEDURE [tSQLt].[Private_GetCursorForRunAll]
  @TestClassCursor CURSOR VARYING OUTPUT
AS
BEGIN
  SET @TestClassCursor = CURSOR LOCAL FAST_FORWARD FOR
   SELECT Name
     FROM tSQLt.TestClasses;

  OPEN @TestClassCursor;
END;
GO
PRINT N'Creating [err].[ValidationErrorId]'
GO

CREATE FUNCTION [err].[ValidationErrorId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55015;  
END
GO
PRINT N'Creating [err].[ThrowValidationError]'
GO

CREATE PROCEDURE [err].[ThrowValidationError] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.ValidationErrorId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dbo].[Init_FillStrings]'
GO

CREATE PROCEDURE [dbo].[Init_FillStrings]
AS
BEGIN
    SET NOCOUNT ON;

	-- Delclare your application strings here
	INSERT	dsp.StringTable (StringId, StringValue)
	VALUES 
		(N'String1', N'string 1'),
		(N'String2', N'string 2');

END
		
GO
PRINT N'Creating [dsp].[Table_HasIdentityColumn]'
GO
CREATE FUNCTION [dsp].[Table_HasIdentityColumn] (@FullTableName TSTRING)
RETURNS BIT
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [tSQLt].[Private_GetCursorForRunNew]'
GO
CREATE PROCEDURE [tSQLt].[Private_GetCursorForRunNew]
  @TestClassCursor CURSOR VARYING OUTPUT
AS
BEGIN
  SET @TestClassCursor = CURSOR LOCAL FAST_FORWARD FOR
   SELECT TC.Name
     FROM tSQLt.TestClasses AS TC
     JOIN tSQLt.Private_NewTestClassList AS PNTCL
       ON PNTCL.ClassName = TC.Name;

  OPEN @TestClassCursor;
END;
GO
PRINT N'Creating [dbo].[Setting_GetProps]'
GO

-- Retrieve Application settings
CREATE PROCEDURE [dbo].[Setting_GetProps]
    @AppSetting1 INT = -1 OUT, @AppSetting2 INT = -1 OUT
AS
BEGIN
	SET NOCOUNT ON;

    SELECT  @AppSetting1 = AppSetting1, @AppSetting2 = AppSetting2
      FROM  dbo.Setting;

END;
GO
PRINT N'Creating [dsp].[Table_HasPrimaryKey]'
GO
CREATE FUNCTION [dsp].[Table_HasPrimaryKey] (@SchemaName TSTRING,
    @TableName TSTRING)
RETURNS TABLE
RETURN SELECT   ISNULL((   SELECT   1
                             FROM   sys.tables T
                                    INNER JOIN sys.schemas S ON S.schema_id = T.schema_id
                                    LEFT OUTER JOIN sys.indexes I ON T.object_id = I.object_id
                            WHERE   I.is_primary_key = 1 --
                               AND  (@SchemaName IS NULL OR S.name = @SchemaName) --
                               AND  (@TableName IS NULL OR  T.name = @TableName)), 0) HasPrimaryKey;

GO
PRINT N'Creating [tSQLt].[Private_GetQuotedFullName]'
GO
CREATE FUNCTION [tSQLt].[Private_GetQuotedFullName](@Objectid INT)
RETURNS NVARCHAR(517)
AS
BEGIN
    DECLARE @QuotedName NVARCHAR(517);
    SELECT @QuotedName = QUOTENAME(OBJECT_SCHEMA_NAME(@Objectid)) + '.' + QUOTENAME(OBJECT_NAME(@Objectid));
    RETURN @QuotedName;
END;
GO
PRINT N'Creating [tSQLt].[Private_GetSetupProcedureName]'
GO
CREATE PROCEDURE [tSQLt].[Private_GetSetupProcedureName]
  @TestClassId INT = NULL,
  @SetupProcName NVARCHAR(MAX) OUTPUT
AS
BEGIN
    SELECT @SetupProcName = tSQLt.Private_GetQuotedFullName(object_id)
      FROM sys.procedures
     WHERE schema_id = @TestClassId
       AND LOWER(name) = 'setup';
END;
GO
PRINT N'Creating [tSQLt].[TestMessage]'
GO
CREATE TABLE [tSQLt].[TestMessage]
(
[Msg] [nvarchar] (max) NULL
)
GO
PRINT N'Creating [tSQLt].[Fail]'
GO
CREATE PROCEDURE [tSQLt].[Fail]
    @Message0 NVARCHAR(MAX) = '',
    @Message1 NVARCHAR(MAX) = '',
    @Message2 NVARCHAR(MAX) = '',
    @Message3 NVARCHAR(MAX) = '',
    @Message4 NVARCHAR(MAX) = '',
    @Message5 NVARCHAR(MAX) = '',
    @Message6 NVARCHAR(MAX) = '',
    @Message7 NVARCHAR(MAX) = '',
    @Message8 NVARCHAR(MAX) = '',
    @Message9 NVARCHAR(MAX) = ''
AS
BEGIN
   DECLARE @WarningMessage NVARCHAR(MAX);
   SET @WarningMessage = '';

   IF XACT_STATE() = -1
   BEGIN
     SET @WarningMessage = CHAR(13)+CHAR(10)+'Warning: Uncommitable transaction detected!';

     DECLARE @TranName NVARCHAR(MAX);
     SELECT @TranName = TranName
       FROM tSQLt.TestResult
      WHERE Id = (SELECT MAX(Id) FROM tSQLt.TestResult);

     DECLARE @TranCount INT;
     SET @TranCount = @@TRANCOUNT;
     ROLLBACK;
     WHILE(@TranCount>0)
     BEGIN
       BEGIN TRAN;
       SET @TranCount = @TranCount -1;
     END;
     SAVE TRAN @TranName;
   END;

   INSERT INTO tSQLt.TestMessage(Msg)
   SELECT COALESCE(@Message0, '!NULL!')
        + COALESCE(@Message1, '!NULL!')
        + COALESCE(@Message2, '!NULL!')
        + COALESCE(@Message3, '!NULL!')
        + COALESCE(@Message4, '!NULL!')
        + COALESCE(@Message5, '!NULL!')
        + COALESCE(@Message6, '!NULL!')
        + COALESCE(@Message7, '!NULL!')
        + COALESCE(@Message8, '!NULL!')
        + COALESCE(@Message9, '!NULL!')
        + @WarningMessage;
        
   RAISERROR('tSQLt.Failure',16,10);
END;
GO
PRINT N'Creating [dbo].[Setting_SetProps]'
GO

-- Retrieve Application settings
CREATE PROCEDURE [dbo].[Setting_SetProps]
    @AppSetting1 INT = -1, @AppSetting2 INT = -1
AS
BEGIN
    SET NOCOUNT ON;

    IF (dsp.Param_IsSet(@AppSetting1) = 1)
        UPDATE  dbo.Setting
           SET  AppSetting1 = @AppSetting1;

    IF (dsp.Param_IsSet(@AppSetting2) = 2)
        UPDATE  dbo.Setting
           SET  AppSetting2 = @AppSetting2;
END;
GO
PRINT N'Creating [dsp].[Table_IndexName]'
GO
-- Returns:
-- 0: Ok
-- 1: Index not exists
-- 2: IndexName is incorrect 
CREATE FUNCTION [dsp].[Table_IndexName] (
	@TableName TSTRING,
	@ColumnName TSTRING)
RETURNS TSTRING
AS
BEGIN
	DECLARE @IndexName TSTRING;
	SELECT	@IndexName = ind.name
	FROM		sys.indexes ind
			INNER JOIN sys.index_columns ic ON ind.object_id = ic.object_id
										AND ind.index_id = ic.index_id
			INNER JOIN sys.columns col ON ic.object_id = col.object_id
									AND ic.column_id = col.column_id
			INNER JOIN sys.tables t ON ind.object_id = t.object_id
	WHERE	ind.is_primary_key = 0
			AND t.name = @TableName
			AND col.name = @ColumnName;

	RETURN @IndexName;
END;

GO
PRINT N'Creating [SQLCop].[test Ad hoc distributed queries]'
GO
CREATE PROCEDURE [SQLCop].[test Ad hoc distributed queries]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Ad_Hoc_Distributed_Queries
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    select	@Output = 'Status: Ad Hoc Distributed Queries are enabled'
    from	sys.configurations
    where	name = 'Ad Hoc Distributed Queries'
			and value_in_use = 1
           
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Ad_Hoc_Distributed_Queries'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dsp].[Log_Error]'
GO
CREATE	PROCEDURE [dsp].[Log_Error]
	@ProcId AS INT, @Message AS TSTRING, @Param0 AS TSTRING = '<notset>', @Param1 AS TSTRING = '<notset>', @Param2 AS TSTRING = '<notset>'
AS
BEGIN
	SET @Message = 'Error: ' + @Message;
	EXEC dsp.Log_Trace @ProcId = @ProcId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2, @Elipse = 0;
END;







GO
PRINT N'Creating [dsp].[Table_ListBaseOnExtendedProperty]'
GO
CREATE FUNCTION [dsp].[Table_ListBaseOnExtendedProperty] (@ExtendedProperty TSTRING = NULL)
RETURNS TABLE
AS
RETURN SELECT   t.object_id AS ObjectId, s.name SchemaName, t.name AS TableName, ep.name AS ExtendedPropertyName, ep.value AS ExtendedPropertyValue
         FROM   sys.extended_properties ep
                INNER JOIN sys.tables t ON t.object_id = ep.major_id
                INNER JOIN sys.schemas s ON s.schema_id = t.schema_id
        WHERE   ep.class = 1 --
           AND  ep.minor_id = 0 --
           AND  (@ExtendedProperty IS NULL OR   ep.name = @ExtendedProperty) --
           AND  s.name <> 'tSQLt';

GO
PRINT N'Creating [tSQLt].[Private_SqlVersion]'
GO
CREATE FUNCTION [tSQLt].[Private_SqlVersion]()
RETURNS TABLE
AS
RETURN
  SELECT CAST(SERVERPROPERTY('ProductVersion')AS NVARCHAR(128)) ProductVersion,
         CAST(SERVERPROPERTY('Edition')AS NVARCHAR(128)) Edition;
GO
PRINT N'Creating [tSQLt].[Info]'
GO
CREATE FUNCTION [tSQLt].[Info]()
RETURNS TABLE
AS
RETURN
SELECT Version = '1.0.5873.27393',
       ClrVersion = (SELECT tSQLt.Private::Info()),
       ClrSigningKey = (SELECT tSQLt.Private::SigningKey()),
       V.SqlVersion,
       V.SqlBuild,
       V.SqlEdition
  FROM
  (
    SELECT CAST(VI.major+'.'+VI.minor AS NUMERIC(10,2)) AS SqlVersion,
           CAST(VI.build+'.'+VI.revision AS NUMERIC(10,2)) AS SqlBuild,
           SqlEdition
      FROM
      (
        SELECT PARSENAME(PSV.ProductVersion,4) major,
               PARSENAME(PSV.ProductVersion,3) minor, 
               PARSENAME(PSV.ProductVersion,2) build,
               PARSENAME(PSV.ProductVersion,1) revision,
               Edition AS SqlEdition
          FROM tSQLt.Private_SqlVersion() AS PSV
      )VI
  )V;
GO
PRINT N'Creating [tSQLt].[EnableExternalAccess]'
GO
CREATE PROCEDURE [tSQLt].[EnableExternalAccess]
  @try BIT = 0,
  @enable BIT = 1
AS
BEGIN
  BEGIN TRY
    IF @enable = 1
    BEGIN
      EXEC('ALTER ASSEMBLY tSQLtCLR WITH PERMISSION_SET = EXTERNAL_ACCESS;');
    END
    ELSE
    BEGIN
      EXEC('ALTER ASSEMBLY tSQLtCLR WITH PERMISSION_SET = SAFE;');
    END
  END TRY
  BEGIN CATCH
    IF(@try = 0)
    BEGIN
      DECLARE @Message NVARCHAR(4000);
      SET @Message = 'The attempt to ' +
                      CASE WHEN @enable = 1 THEN 'enable' ELSE 'disable' END +
                      ' tSQLt features requiring EXTERNAL_ACCESS failed' +
                      ': '+ERROR_MESSAGE();
      RAISERROR(@Message,16,10);
    END;
    RETURN -1;
  END CATCH;
  RETURN 0;
END;
GO
PRINT N'Creating [tSQLt].[Private_Init]'
GO
CREATE PROCEDURE [tSQLt].[Private_Init]
AS
BEGIN
  EXEC tSQLt.Private_CleanTestResult;

  DECLARE @enable BIT; SET @enable = 1;
  DECLARE @version_match BIT;SET @version_match = 0;
  BEGIN TRY
    EXEC sys.sp_executesql N'SELECT @r = CASE WHEN I.Version = I.ClrVersion THEN 1 ELSE 0 END FROM tSQLt.Info() AS I;',N'@r BIT OUTPUT',@version_match OUT;
  END TRY
  BEGIN CATCH
    RAISERROR('Cannot access CLR. Assembly might be in an invalid state. Try running EXEC tSQLt.EnableExternalAccess @enable = 0; or reinstalling tSQLt.',16,10);
    RETURN;
  END CATCH;
  IF(@version_match = 0)
  BEGIN
    RAISERROR('tSQLt is in an invalid state. Please reinstall tSQLt.',16,10);
    RETURN;
  END;

  IF((SELECT SqlEdition FROM tSQLt.Info()) <> 'SQL Azure')
  BEGIN
    EXEC tSQLt.EnableExternalAccess @enable = @enable, @try = 1;
  END;
END;
GO
PRINT N'Creating [SQLCop].[test Agent Service]'
GO
CREATE PROCEDURE [SQLCop].[test Agent Service]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Find_out_if_SQL_Agent_running
	
	SET NOCOUNT ON
    
	Declare @Output VarChar(max)
    DECLARE @service NVARCHAR(100)

	Set @Output = ''

    
    If Convert(VarChar(100), ServerProperty('Edition')) Like 'Express%'
      Select @Output = 'SQL Server Agent not installed for express editions'
    Else If Is_SrvRoleMember('sysadmin') = 0
      Select @Output = 'You need to be a member of the sysadmin server role to run this check'
    Else
      Begin
        SELECT @service = CASE WHEN CHARINDEX('\',@@SERVERNAME)>0
               THEN N'SQLAgent$'+@@SERVICENAME
               ELSE N'SQLSERVERAGENT' END

        Create Table #Temp(Output VarChar(1000))
        Insert Into #Temp
        EXEC master..xp_servicecontrol N'QUERYSTATE', @service 

        Select	Top 1 @Output = Output
        From	#Temp 
        Where	Output Not Like 'Running%'
        
        Drop	Table #Temp
      End
      
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Find_out_if_SQL_Agent_running'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dsp].[Audit_Error]'
GO
CREATE	PROCEDURE [dsp].[Audit_Error]
	@ProcId AS INT, @Message AS TSTRING, @Param0 AS TSTRING = '<notset>', @Param1 AS TSTRING = '<notset>', @Param2 AS TSTRING = '<notset>'
AS
BEGIN
	-- Format Message
	EXEC dsp.Log_Error @ProcId = @ProcId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2;
END;


GO
PRINT N'Creating [dspAuth].[RoleUser]'
GO
CREATE TABLE [dspAuth].[RoleUser]
(
[RoleId] [int] NOT NULL,
[UserId] [int] NOT NULL,
[ModifiedByUserId] [int] NOT NULL,
[CreatedTime] [datetime] NOT NULL CONSTRAINT [DF_RoleUserMember_CreatedTime] DEFAULT (getdate())
)
GO
PRINT N'Creating primary key [PK_RoleUserMember] on [dspAuth].[RoleUser]'
GO
ALTER TABLE [dspAuth].[RoleUser] ADD CONSTRAINT [PK_RoleUserMember] PRIMARY KEY CLUSTERED  ([RoleId], [UserId])
GO
PRINT N'Creating index [IX_MemberUserId] on [dspAuth].[RoleUser]'
GO
CREATE NONCLUSTERED INDEX [IX_MemberUserId] ON [dspAuth].[RoleUser] ([UserId])
GO
PRINT N'Creating [dspAuth].[Role_HasUser]'
GO
CREATE FUNCTION [dspAuth].[Role_HasUser] (@RoleId INT,
    @UserId INT)
RETURNS TABLE
RETURN (SELECT  ISNULL((   SELECT   1
                             FROM   dspAuth.RoleUser AS RMU
                            WHERE   RMU.RoleId = @RoleId AND RMU.UserId = @UserId), 0) AS HasMember);
GO
PRINT N'Creating [SQLCop].[test Auto close]'
GO
CREATE PROCEDURE [SQLCop].[test Auto close]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/sql-server-auto-close
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    Select @Output = @Output + 'Database set to Auto Close' + Char(13) + Char(10)
    Where   DatabaseProperty(db_name(), 'IsAutoClose') = 1

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/sql-server-auto-close'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dsp].[Audit_Trace]'
GO
CREATE PROCEDURE [dsp].[Audit_Trace]
	@ProcId AS INT,
	@Message AS TSTRING,
	@Param0 AS TSTRING = '<notset>',
	@Param1 AS TSTRING = '<notset>',
	@Param2 AS TSTRING = '<notset>'
AS
BEGIN
	-- Format Message
	EXEC dsp.Log_Trace @ProcId = @ProcId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2;
END;




GO
PRINT N'Creating [tSQLt].[GetTestResultFormatter]'
GO
CREATE FUNCTION [tSQLt].[GetTestResultFormatter]()
RETURNS NVARCHAR(MAX)
AS
BEGIN
    DECLARE @FormatterName NVARCHAR(MAX);
    
    SELECT @FormatterName = CAST(value AS NVARCHAR(MAX))
    FROM sys.extended_properties
    WHERE name = N'tSQLt.ResultsFormatter'
      AND major_id = OBJECT_ID('tSQLt.Private_OutputTestResults');
      
    SELECT @FormatterName = COALESCE(@FormatterName, 'tSQLt.DefaultResultFormatter');
    
    RETURN @FormatterName;
END;
GO
PRINT N'Creating [tSQLt].[Private_OutputTestResults]'
GO
CREATE PROCEDURE [tSQLt].[Private_OutputTestResults]
  @TestResultFormatter NVARCHAR(MAX) = NULL
AS
BEGIN
    DECLARE @Formatter NVARCHAR(MAX);
    SELECT @Formatter = COALESCE(@TestResultFormatter, tSQLt.GetTestResultFormatter());
    EXEC (@Formatter);
END
GO
PRINT N'Creating [SQLCop].[test Auto create statistics]'
GO
CREATE PROCEDURE [SQLCop].[test Auto create statistics]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.sql-server-performance.com/tips/optimizing_indexes_general_p1.aspx
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    Select @Output = @Output + 'Database not set to Auto Create Statistics' + Char(13) + Char(10)
    Where  DatabaseProperty(db_name(), 'IsAutoCreateStatistics') = 0
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.sql-server-performance.com/tips/optimizing_indexes_general_p1.aspx'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dsp].[Log_Warn]'
GO
CREATE	PROCEDURE [dsp].[Log_Warn]
	@ProcId AS INT, @Message AS TSTRING, @Param0 AS TSTRING = '<notset>', @Param1 AS TSTRING = '<notset>', @Param2 AS TSTRING = '<notset>'
AS
BEGIN
	SET @Message = 'Warning: ' + @Message;
	EXEC dsp.Log_Trace @ProcId = @ProcId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2, @Elipse = 0;
END;



GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_Roles]'
GO
CREATE FUNCTION [dspAuth].[SecurityDescriptor_Roles] (@SecurityDescriptorId BIGINT)
RETURNS TABLE
RETURN (   SELECT   R.RoleId, R.RoleName
             FROM   dspAuth.Role AS R
            WHERE   R.OwnerSecurityDescriptorId = @SecurityDescriptorId);
GO
PRINT N'Creating [tSQLt].[Private_ResetNewTestClassList]'
GO
CREATE PROCEDURE [tSQLt].[Private_ResetNewTestClassList]
AS
BEGIN
  SET NOCOUNT ON;
  DELETE FROM tSQLt.Private_NewTestClassList;
END;
GO
PRINT N'Creating [SQLCop].[test Auto Shrink]'
GO
CREATE PROCEDURE [SQLCop].[test Auto Shrink]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.sqlskills.com/blogs/paul/post/Auto-shrink-e28093-turn-it-OFF!.aspx
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    Select @Output = @Output + 'Database set to Auto Shrink' + Char(13) + Char(10)
    Where  DatabaseProperty(db_name(), 'IsAutoShrink') = 1
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.sqlskills.com/blogs/paul/post/Auto-shrink-e28093-turn-it-OFF!.aspx'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dsp].[Audit_Warning]'
GO
CREATE	PROCEDURE [dsp].[Audit_Warning]
	@ProcId AS INT, @Message AS TSTRING, @Param0 AS TSTRING = '<notset>', @Param1 AS TSTRING = '<notset>', @Param2 AS TSTRING = '<notset>'
AS
BEGIN
	-- Format Message
	EXEC dsp.Log_Warn @ProcId = @ProcId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2;
END;



GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_UserPermissions]'
GO
CREATE FUNCTION [dspAuth].[SecurityDescriptor_UserPermissions] (@ObjectId BIGINT,
    @ObjectTypeId INT,
    @UserId INT,
    @FilterPermissionId INT)
RETURNS TABLE
AS
RETURN (   SELECT   PGP.PermissionId
             FROM   dspAuth.SecurityDescriptor AS SD
                    CROSS APPLY dspAuth.SecurityDescriptor_Parents(SD.SecurityDescriptorId) AS SDP
                    INNER JOIN dspAuth.SecurityDescriptorRolePermission AS ACL ON ACL.SecurityDescriptorId = SDP.SecurityDescriptorId
                    INNER JOIN dspAuth.PermissionGroupPermission AS PGP ON PGP.PermissionGroupId = ACL.PermissionGroupId
                    CROSS APPLY dspAuth.Role_HasUser(ACL.RoleId, @UserId) AS RHM
            WHERE   SD.ObjectId = @ObjectId --
               AND  SD.ObjectTypeId = @ObjectTypeId --               
               AND  RHM.HasMember = 1 --
               AND  (@FilterPermissionId IS NULL OR PGP.PermissionId = @FilterPermissionId)
           UNION
           SELECT   PGP.PermissionId
             FROM   dspAuth.SecurityDescriptor AS SD
                    CROSS APPLY dspAuth.SecurityDescriptor_Parents(SD.SecurityDescriptorId) AS SDP
                    INNER JOIN dspAuth.SecurityDescriptorUserPermission AS ACL ON ACL.SecurityDescriptorId = SDP.SecurityDescriptorId
                    INNER JOIN dspAuth.PermissionGroupPermission AS PGP ON PGP.PermissionGroupId = ACL.PermissionGroupId
            WHERE   SD.ObjectId = @ObjectId --
               AND  SD.ObjectTypeId = @ObjectTypeId --
               AND  ACL.UserId = @UserId --
               AND  (@FilterPermissionId IS NULL OR PGP.PermissionId = @FilterPermissionId)
            GROUP BY PGP.PermissionId);



GO
PRINT N'Creating [SQLCop].[test Auto update statistics]'
GO
CREATE PROCEDURE [SQLCop].[test Auto update statistics]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.microsoft.com/technet/abouttn/flash/tips/tips_070604.mspx
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''
	
    Select @Output = @Output + 'Database not set to Auto Update Statistics' + Char(13) + Char(10)
    Where  DatabaseProperty(db_name(), 'IsAutoUpdateStatistics') = 0
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.microsoft.com/technet/abouttn/flash/tips/tips_070604.mspx'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dspconst].[RequestProcessResultObjectPattern]'
GO
CREATE   FUNCTION [dspconst].[RequestProcessResultObjectPattern] ()
RETURNS TJSON
AS
BEGIN
    RETURN '{"ObjectNumber": 1, "ResultNumber": 1, "Error": ""}';
END;
GO
PRINT N'Creating [SQLCop].[test Buffer cache hit ratio]'
GO
CREATE PROCEDURE [SQLCop].[test Buffer cache hit ratio]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/MSSQLServerAdmin/use-sys-dm_os_performance_counters-to-ge
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

	If Exists(Select 1 From fn_my_permissions(NULL, 'SERVER') WHERE permission_name = 'VIEW SERVER STATE')
		SELECT	@Output = Convert(DECIMAL(4,1), (a.cntr_value * 1.0 / b.cntr_value) * 100.0)
		FROM	sys.dm_os_performance_counters  a
				JOIN  (
					SELECT cntr_value,OBJECT_NAME
					FROM   sys.dm_os_performance_counters  
					WHERE  counter_name collate SQL_LATIN1_GENERAL_CP1_CI_AI = 'Buffer cache hit ratio base'
							AND OBJECT_NAME collate SQL_LATIN1_GENERAL_CP1_CI_AI like '%Buffer Manager%'
					) b 
					ON  a.OBJECT_NAME = b.OBJECT_NAME
		WHERE	a.counter_name collate SQL_LATIN1_GENERAL_CP1_CI_AI = 'Buffer cache hit ratio'
				AND a.OBJECT_NAME collate SQL_LATIN1_GENERAL_CP1_CI_AI like '%:Buffer Manager%'
				and Convert(DECIMAL(4,1), (a.cntr_value * 1.0 / b.cntr_value) * 100.0) < 95
	Else
		Set @Output = 'You do not have VIEW SERVER STATE permissions within this instance.'
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/MSSQLServerAdmin/use-sys-dm_os_performance_counters-to-ge'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dsp].[String_CreateRandom]'
GO
CREATE PROCEDURE [dsp].[String_CreateRandom]
    @Length INT, @IncludeLetter BIT = 1, @IncludeDigit BIT = 1, @RandomString TSTRING OUT
AS
BEGIN
    DECLARE @counter INT;
    DECLARE @nextChar CHAR(1);
    SET @counter = 1;
    SET @RandomString = '';

    WHILE @counter <= @Length
    BEGIN
        IF (@IncludeLetter = 1 AND  @IncludeDigit = 1)
            SET @nextChar = CHAR(48 + CONVERT(INT, (122 - 48 + 1) * RAND())); -- 0 to z
        ELSE IF (@IncludeLetter = 1)
            SET @nextChar = CHAR(65 + CONVERT(INT, (122 - 65 + 1) * RAND())); -- a to z
        ELSE IF (@IncludeDigit = 1)
            SET @nextChar = CHAR(48 + CONVERT(INT, (57 - 48 + 1) * RAND())); -- 0 to 9
        ELSE
            RETURN NULL;

        IF ASCII(@nextChar) NOT IN ( 58, 59, 60, 61, 62, 63, 64, 91, 92, 93, 94, 95, 96 )
        BEGIN
            SELECT  @RandomString = @RandomString + @nextChar;
            SET @counter = @counter + 1;
        END;
    END;
END;






GO
PRINT N'Creating [dspconst].[RequestRuleObjectPattern]'
GO

CREATE   FUNCTION [dspconst].[RequestRuleObjectPattern] ()
RETURNS TJSON
AS
BEGIN
    RETURN '{
			"IntervalTypeId": 1,
			"IntervalValue": "",
			"StartTime": "",
			"ExpireTime": "",
			"ExecutionTime": ""
			}';
END;
GO
PRINT N'Creating [tSQLt].[Private_Print]'
GO
CREATE PROCEDURE [tSQLt].[Private_Print] 
    @Message NVARCHAR(MAX),
    @Severity INT = 0
AS 
BEGIN
    DECLARE @SPos INT;SET @SPos = 1;
    DECLARE @EPos INT;
    DECLARE @Len INT; SET @Len = LEN(@Message);
    DECLARE @SubMsg NVARCHAR(MAX);
    DECLARE @Cmd NVARCHAR(MAX);
    
    DECLARE @CleanedMessage NVARCHAR(MAX);
    SET @CleanedMessage = REPLACE(@Message,'%','%%');
    
    WHILE (@SPos <= @Len)
    BEGIN
      SET @EPos = CHARINDEX(CHAR(13)+CHAR(10),@CleanedMessage+CHAR(13)+CHAR(10),@SPos);
      SET @SubMsg = SUBSTRING(@CleanedMessage, @SPos, @EPos - @SPos);
      SET @Cmd = N'RAISERROR(@Msg,@Severity,10) WITH NOWAIT;';
      EXEC sp_executesql @Cmd, 
                         N'@Msg NVARCHAR(MAX),@Severity INT',
                         @SubMsg,
                         @Severity;
      SELECT @SPos = @EPos + 2,
             @Severity = 0; --Print only first line with high severity
    END

    RETURN 0;
END;
GO
PRINT N'Creating [tSQLt].[Private_Configurations]'
GO
CREATE TABLE [tSQLt].[Private_Configurations]
(
[Name] [nvarchar] (100) NOT NULL,
[Value] [sql_variant] NULL
)
GO
PRINT N'Creating primary key [PK__Private___737584F7E25CFAA4] on [tSQLt].[Private_Configurations]'
GO
ALTER TABLE [tSQLt].[Private_Configurations] ADD CONSTRAINT [PK__Private___737584F7E25CFAA4] PRIMARY KEY CLUSTERED  ([Name])
GO
PRINT N'Creating [tSQLt].[Private_GetConfiguration]'
GO
CREATE FUNCTION [tSQLt].[Private_GetConfiguration](
  @Name NVARCHAR(100)
)
RETURNS TABLE
AS
RETURN
  SELECT PC.Name,
         PC.Value 
    FROM tSQLt.Private_Configurations AS PC
   WHERE PC.Name = @Name;
GO
PRINT N'Creating [tSQLt].[Private_GetCleanObjectName]'
GO
CREATE FUNCTION [tSQLt].[Private_GetCleanObjectName](@ObjectName NVARCHAR(MAX))
RETURNS NVARCHAR(MAX)
AS
BEGIN
    RETURN (SELECT OBJECT_NAME(OBJECT_ID(@ObjectName)));
END;
GO
PRINT N'Creating [tSQLt].[GetNewTranName]'
GO
CREATE PROCEDURE [tSQLt].[GetNewTranName]
  @TranName CHAR(32) OUTPUT
AS
BEGIN
  SELECT @TranName = LEFT('tSQLtTran'+REPLACE(CAST(NEWID() AS NVARCHAR(60)),'-',''),32);
END;
GO
PRINT N'Creating [tSQLt].[Private_RunTest]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunTest]
   @TestName NVARCHAR(MAX),
   @SetUp NVARCHAR(MAX) = NULL
AS
BEGIN
    DECLARE @Msg NVARCHAR(MAX); SET @Msg = '';
    DECLARE @Msg2 NVARCHAR(MAX); SET @Msg2 = '';
    DECLARE @Cmd NVARCHAR(MAX); SET @Cmd = '';
    DECLARE @TestClassName NVARCHAR(MAX); SET @TestClassName = '';
    DECLARE @TestProcName NVARCHAR(MAX); SET @TestProcName = '';
    DECLARE @Result NVARCHAR(MAX); SET @Result = 'Success';
    DECLARE @TranName CHAR(32); EXEC tSQLt.GetNewTranName @TranName OUT;
    DECLARE @TestResultId INT;
    DECLARE @PreExecTrancount INT;

    DECLARE @VerboseMsg NVARCHAR(MAX);
    DECLARE @Verbose BIT;
    SET @Verbose = ISNULL((SELECT CAST(Value AS BIT) FROM tSQLt.Private_GetConfiguration('Verbose')),0);
    
    TRUNCATE TABLE tSQLt.CaptureOutputLog;
    CREATE TABLE #ExpectException(ExpectException INT,ExpectedMessage NVARCHAR(MAX), ExpectedSeverity INT, ExpectedState INT, ExpectedMessagePattern NVARCHAR(MAX), ExpectedErrorNumber INT, FailMessage NVARCHAR(MAX));

    IF EXISTS (SELECT 1 FROM sys.extended_properties WHERE name = N'SetFakeViewOnTrigger')
    BEGIN
      RAISERROR('Test system is in an invalid state. SetFakeViewOff must be called if SetFakeViewOn was called. Call SetFakeViewOff after creating all test case procedures.', 16, 10) WITH NOWAIT;
      RETURN -1;
    END;

    SELECT @Cmd = 'EXEC ' + @TestName;
    
    SELECT @TestClassName = OBJECT_SCHEMA_NAME(OBJECT_ID(@TestName)), --tSQLt.Private_GetCleanSchemaName('', @TestName),
           @TestProcName = tSQLt.Private_GetCleanObjectName(@TestName);
           
    INSERT INTO tSQLt.TestResult(Class, TestCase, TranName, Result) 
        SELECT @TestClassName, @TestProcName, @TranName, 'A severe error happened during test execution. Test did not finish.'
        OPTION(MAXDOP 1);
    SELECT @TestResultId = SCOPE_IDENTITY();

    IF(@Verbose = 1)
    BEGIN
      SET @VerboseMsg = 'tSQLt.Run '''+@TestName+'''; --Starting';
      EXEC tSQLt.Private_Print @Message =@VerboseMsg, @Severity = 0;
    END;

    BEGIN TRAN;
    SAVE TRAN @TranName;

    SET @PreExecTrancount = @@TRANCOUNT;
    
    TRUNCATE TABLE tSQLt.TestMessage;

    DECLARE @TmpMsg NVARCHAR(MAX);
    DECLARE @TestEndTime DATETIME; SET @TestEndTime = NULL;
    BEGIN TRY
        IF (@SetUp IS NOT NULL) EXEC @SetUp;
        EXEC (@Cmd);
        SET @TestEndTime = GETDATE();
        IF(EXISTS(SELECT 1 FROM #ExpectException WHERE ExpectException = 1))
        BEGIN
          SET @TmpMsg = COALESCE((SELECT FailMessage FROM #ExpectException)+' ','')+'Expected an error to be raised.';
          EXEC tSQLt.Fail @TmpMsg;
        END
    END TRY
    BEGIN CATCH
        SET @TestEndTime = ISNULL(@TestEndTime,GETDATE());
        IF ERROR_MESSAGE() LIKE '%tSQLt.Failure%'
        BEGIN
            SELECT @Msg = Msg FROM tSQLt.TestMessage;
            SET @Result = 'Failure';
        END
        ELSE
        BEGIN
          DECLARE @ErrorInfo NVARCHAR(MAX);
          SELECT @ErrorInfo = 
            COALESCE(ERROR_MESSAGE(), '<ERROR_MESSAGE() is NULL>') + 
            '[' +COALESCE(LTRIM(STR(ERROR_SEVERITY())), '<ERROR_SEVERITY() is NULL>') + ','+COALESCE(LTRIM(STR(ERROR_STATE())), '<ERROR_STATE() is NULL>') + ']' +
            '{' + COALESCE(ERROR_PROCEDURE(), '<ERROR_PROCEDURE() is NULL>') + ',' + COALESCE(CAST(ERROR_LINE() AS NVARCHAR), '<ERROR_LINE() is NULL>') + '}';

          IF(EXISTS(SELECT 1 FROM #ExpectException))
          BEGIN
            DECLARE @ExpectException INT;
            DECLARE @ExpectedMessage NVARCHAR(MAX);
            DECLARE @ExpectedMessagePattern NVARCHAR(MAX);
            DECLARE @ExpectedSeverity INT;
            DECLARE @ExpectedState INT;
            DECLARE @ExpectedErrorNumber INT;
            DECLARE @FailMessage NVARCHAR(MAX);
            SELECT @ExpectException = ExpectException,
                   @ExpectedMessage = ExpectedMessage, 
                   @ExpectedSeverity = ExpectedSeverity,
                   @ExpectedState = ExpectedState,
                   @ExpectedMessagePattern = ExpectedMessagePattern,
                   @ExpectedErrorNumber = ExpectedErrorNumber,
                   @FailMessage = FailMessage
              FROM #ExpectException;

            IF(@ExpectException = 1)
            BEGIN
              SET @Result = 'Success';
              SET @TmpMsg = COALESCE(@FailMessage+' ','')+'Exception did not match expectation!';
              IF(ERROR_MESSAGE() <> @ExpectedMessage)
              BEGIN
                SET @TmpMsg = @TmpMsg +CHAR(13)+CHAR(10)+
                           'Expected Message: <'+@ExpectedMessage+'>'+CHAR(13)+CHAR(10)+
                           'Actual Message  : <'+ERROR_MESSAGE()+'>';
                SET @Result = 'Failure';
              END
              IF(ERROR_MESSAGE() NOT LIKE @ExpectedMessagePattern)
              BEGIN
                SET @TmpMsg = @TmpMsg +CHAR(13)+CHAR(10)+
                           'Expected Message to be like <'+@ExpectedMessagePattern+'>'+CHAR(13)+CHAR(10)+
                           'Actual Message            : <'+ERROR_MESSAGE()+'>';
                SET @Result = 'Failure';
              END
              IF(ERROR_NUMBER() <> @ExpectedErrorNumber)
              BEGIN
                SET @TmpMsg = @TmpMsg +CHAR(13)+CHAR(10)+
                           'Expected Error Number: '+CAST(@ExpectedErrorNumber AS NVARCHAR(MAX))+CHAR(13)+CHAR(10)+
                           'Actual Error Number  : '+CAST(ERROR_NUMBER() AS NVARCHAR(MAX));
                SET @Result = 'Failure';
              END
              IF(ERROR_SEVERITY() <> @ExpectedSeverity)
              BEGIN
                SET @TmpMsg = @TmpMsg +CHAR(13)+CHAR(10)+
                           'Expected Severity: '+CAST(@ExpectedSeverity AS NVARCHAR(MAX))+CHAR(13)+CHAR(10)+
                           'Actual Severity  : '+CAST(ERROR_SEVERITY() AS NVARCHAR(MAX));
                SET @Result = 'Failure';
              END
              IF(ERROR_STATE() <> @ExpectedState)
              BEGIN
                SET @TmpMsg = @TmpMsg +CHAR(13)+CHAR(10)+
                           'Expected State: '+CAST(@ExpectedState AS NVARCHAR(MAX))+CHAR(13)+CHAR(10)+
                           'Actual State  : '+CAST(ERROR_STATE() AS NVARCHAR(MAX));
                SET @Result = 'Failure';
              END
              IF(@Result = 'Failure')
              BEGIN
                SET @Msg = @TmpMsg;
              END
            END 
            ELSE
            BEGIN
                SET @Result = 'Failure';
                SET @Msg = 
                  COALESCE(@FailMessage+' ','')+
                  'Expected no error to be raised. Instead this error was encountered:'+
                  CHAR(13)+CHAR(10)+
                  @ErrorInfo;
            END
          END
          ELSE
          BEGIN
            SET @Result = 'Error';
            SET @Msg = @ErrorInfo;
          END  
        END;
    END CATCH

    BEGIN TRY
        ROLLBACK TRAN @TranName;
    END TRY
    BEGIN CATCH
        DECLARE @PostExecTrancount INT;
        SET @PostExecTrancount = @PreExecTrancount - @@TRANCOUNT;
        IF (@@TRANCOUNT > 0) ROLLBACK;
        BEGIN TRAN;
        IF(   @Result <> 'Success'
           OR @PostExecTrancount <> 0
          )
        BEGIN
          SELECT @Msg = COALESCE(@Msg, '<NULL>') + ' (There was also a ROLLBACK ERROR --> ' + COALESCE(ERROR_MESSAGE(), '<ERROR_MESSAGE() is NULL>') + '{' + COALESCE(ERROR_PROCEDURE(), '<ERROR_PROCEDURE() is NULL>') + ',' + COALESCE(CAST(ERROR_LINE() AS NVARCHAR), '<ERROR_LINE() is NULL>') + '})';
          SET @Result = 'Error';
        END
    END CATCH    

    If(@Result <> 'Success') 
    BEGIN
      SET @Msg2 = @TestName + ' failed: (' + @Result + ') ' + @Msg;
      EXEC tSQLt.Private_Print @Message = @Msg2, @Severity = 0;
    END

    IF EXISTS(SELECT 1 FROM tSQLt.TestResult WHERE Id = @TestResultId)
    BEGIN
        UPDATE tSQLt.TestResult SET
            Result = @Result,
            Msg = @Msg,
            TestEndTime = @TestEndTime
         WHERE Id = @TestResultId;
    END
    ELSE
    BEGIN
        INSERT tSQLt.TestResult(Class, TestCase, TranName, Result, Msg)
        SELECT @TestClassName, 
               @TestProcName,  
               '?', 
               'Error', 
               'TestResult entry is missing; Original outcome: ' + @Result + ', ' + @Msg;
    END    
      

    COMMIT;

    IF(@Verbose = 1)
    BEGIN
    SET @VerboseMsg = 'tSQLt.Run '''+@TestName+'''; --Finished';
      EXEC tSQLt.Private_Print @Message =@VerboseMsg, @Severity = 0;
    END;

END;
GO
PRINT N'Creating [SQLCop].[test Column collation does not match database default]'
GO
CREATE PROCEDURE [SQLCop].[test Column collation does not match database default]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/sql-server-collation-conflicts
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT	@Output = @Output + C.TABLE_SCHEMA + '.' + C.TABLE_NAME + '.' + C.COLUMN_NAME + Char(13) + Char(10)
	FROM	INFORMATION_SCHEMA.COLUMNS C
			INNER JOIN INFORMATION_SCHEMA.TABLES T            
				ON C.Table_Name = T.Table_Name 
	WHERE	T.Table_Type = 'BASE TABLE'          
			AND COLLATION_NAME <> convert(VarChar(100), DATABASEPROPERTYEX(db_name(), 'Collation'))
			AND COLUMNPROPERTY(OBJECT_ID(C.TABLE_NAME), COLUMN_NAME, 'IsComputed') = 0 
			AND C.TABLE_SCHEMA <> 'tSQLt'
	Order By C.TABLE_SCHEMA, C.TABLE_NAME, C.COLUMN_NAME
		
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/sql-server-collation-conflicts' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
  
END;
GO
PRINT N'Creating [dsp].[CRYPT_PBKDF2_VARBINARY_SHA512]'
GO

-- https://github.com/Anti-weakpasswords/PBKDF2-MSSQL-Custom-A/blob/master/Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512.sql
CREATE FUNCTION [dsp].[CRYPT_PBKDF2_VARBINARY_SHA512]
(
  @Password VARBINARY(MAX), -- HASHBYTES is limited, and HMAC concatenation limits this more, though MAX is a guess
  @Salt VARBINARY(MAX), -- HASHBYTES is limited, and HMAC concatenation limits this more, though MAX is a guess
  @IterationCount INT,
  @Outputbytes INT -- For password hashing, should "naturally" be the digest size (or less) - more than the digest size allows the first <digest size> to remain identical, so someone cracking the PBKDF2'd passwords only needs to generate and check the first <digest size>
  )
RETURNS VARBINARY(MAX)
AS
BEGIN
-- WARNING - if you are using SQL 2012 or better, DO NOT USE Yourfn_CRYPT_PBKDF2_VARBINARY_SHA1 UNLESS YOU NEED BACKWARDS COMPATIBILITY!!!  The 64-bit math required by SHA-512 (and SHA-384) is proportionally faster on CPUs vs. GPU's as of 2013, which reduces a GPU based attacker's advantage.
-- SEE PKCS #5, RFC2898, as well as PBKDF2, i.e. http://tools.ietf.org/rfc/rfc2898.txt
-- WARNING - SQL is NOT a good language for this type of math; results are fairly slow, and are generally better off being implemented by another language.
-- This is a dedicated HMAC-SHA-512 version, with a moderate amount of performance tuning.

/*
SET NOCOUNT ON
DECLARE @Result VARBINARY(64)
DECLARE @start DATETIME2(7)
SET @start = SYSDATETIME()
PRINT 'SHA-512 Test 1 from http://stackoverflow.com/questions/15593184/pbkdf2-hmac-sha-512-test-vectors'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'password'),CONVERT(VARBINARY(MAX),'salt'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x867f70cf1ade02cff3752599a3a53dc4af34c7a669815ae5d513554e1c8cf252c02d470a285a0501bad999bfe943c08f050235d7d68b1da55e63f73b60a57fce THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'SHA-512 Test 2 from http://stackoverflow.com/questions/15593184/pbkdf2-hmac-sha-512-test-vectors'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'password'),CONVERT(VARBINARY(MAX),'salt'),2,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xe1d9c16aa681708a45f5c7c4e215ceb66e011a2e9f0040713f18aefdb866d53cf76cab2868a39b9f7840edce4fef5a82be67335c77a6068e04112754f27ccf4e THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'SHA-512 Test 3 from http://stackoverflow.com/questions/15593184/pbkdf2-hmac-sha-512-test-vectors'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'password'),CONVERT(VARBINARY(MAX),'salt'),4096,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xd197b1b33db0143e018b12f3d1d1479e6cdebdcc97c5c0f87f6902e072f457b5143f30602641b3d55cd335988cb36b84376060ecd532e039b742a239434af2d5 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'SHA-512 Test 4 from http://stackoverflow.com/questions/15593184/pbkdf2-hmac-sha-512-test-vectors'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passwordPASSWORDpassword'),CONVERT(VARBINARY(MAX),'saltSALTsaltSALTsaltSALTsaltSALTsalt'),4096,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x8c0511f4c6e597c6ac6315d8f0362e225f3c501495ba23b868c005174dc4ee71115b59f9e60cd9532fa33e0f75aefe30225c583a186cd82bd4daea9724a3d3b8 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END
PRINT 'Duration (ms): ' + CONVERT(NVARCHAR(23),DATEDIFF(ms,@start,SYSDATETIME()))


PRINT 'Long Test 1a 1 iter Len19pw Len19sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTT'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xCBE6088AD4359AF42E603C2A33760EF9D4017A7B2AAD10AF46F992C660A0B461ECB0DC2A79C2570941BEA6A08D15D6887E79F32B132E1C134E9525EEDDD744FA THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 1b 100000 iter Len19pw Len19sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTT'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xACCDCD8798AE5CD85804739015EF2A11E32591B7B7D16F76819B30B0D49D80E1ABEA6C9822B80A1FDFE421E26F5603ECA8A47A64C9A004FB5AF8229F762FF41F THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 2a 1 iter Len20pw Len20sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTl'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x8E5074A9513C1F1512C9B1DF1D8BFFA9D8B4EF9105DFC16681222839560FB63264BED6AABF761F180E912A66E0B53D65EC88F6A1519E14804EBA6DC9DF137007 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 2b 100000 iter Len20pw Len20sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTl'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x594256B0BD4D6C9F21A87F7BA5772A791A10E6110694F44365CD94670E57F1AECD797EF1D1001938719044C7F018026697845EB9AD97D97DE36AB8786AAB5096 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 3a 1 iter Len21pw Len21sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlR'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2P'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xA6AC8C048A7DFD7B838DA88F22C3FAB5BFF15D7CB8D83A62C6721A8FAF6903EAB6152CB7421026E36F2FFEF661EB4384DC276495C71B5CAB72E1C1A38712E56B THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 3b 100000 iter Len21pw Len21sa- validated against and a Javascript Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlR'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2P'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x94FFC2B1A390B7B8A9E6A44922C330DB2B193ADCF082EECD06057197F35931A9D0EC0EE5C660744B50B61F23119B847E658D179A914807F4B8AB8EB9505AF065 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 4a 1 iter Len63pw Len63sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE5'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJe'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xE2CCC7827F1DD7C33041A98906A8FD7BAE1920A55FCB8F831683F14F1C3979351CB868717E5AB342D9A11ACF0B12D3283931D609B06602DA33F8377D1F1F9902 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 4b 100000 iter Len63pw Len63sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE5'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJe'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x07447401C85766E4AED583DE2E6BF5A675EABE4F3618281C95616F4FC1FDFE6ECBC1C3982789D4FD941D6584EF534A78BD37AE02555D9455E8F089FDB4DFB6BB THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 5a 1 iter Len64pw Len64sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJem'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0xB029A551117FF36977F283F579DC7065B352266EA243BDD3F920F24D4D141ED8B6E02D96E2D3BDFB76F8D77BA8F4BB548996AD85BB6F11D01A015CE518F9A717 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 5b 100000 iter Len64pw Len64sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJem'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x31F5CC83ED0E948C05A15735D818703AAA7BFF3F09F5169CAF5DBA6602A05A4D5CFF5553D42E82E40516D6DC157B8DAEAE61D3FEA456D964CB2F7F9A63BBBDB5 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 6a 1 iter Len65pw Len65sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57U'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemk'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x28B8A9F644D6800612197BB74DF460272E2276DE8CC07AC4897AC24DBC6EB77499FCAF97415244D9A29DA83FC347D09A5DBCFD6BD63FF6E410803DCA8A900AB6 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 6b 100000 iter Len65pw Len65sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57U'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemk'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x056BC9072A356B7D4DA60DD66F5968C2CAA375C0220EDA6B47EF8E8D105ED68B44185FE9003FBBA49E2C84240C9E8FD3F5B2F4F6512FD936450253DB37D10028 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 7a 1 iter Len127pw Len127sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi0'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x16226C85E4F8D604573008BFE61C10B6947B53990450612DD4A3077F7DEE2116229E68EFD1DF6D73BD3C6D07567790EEA1E8B2AE9A1B046BE593847D9441A1B7 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 7b 100000 iter Len127pw Len127sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi0'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x70CF39F14C4CAF3C81FA288FB46C1DB52D19F72722F7BC84F040676D3371C89C11C50F69BCFBC3ACB0AB9E92E4EF622727A916219554B2FA121BEDDA97FF3332 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 8a 1 iter Len128pw Len128sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi04'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy6'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x880C58C316D3A5B9F05977AB9C60C10ABEEBFAD5CE89CAE62905C1C4F80A0A098D82F95321A6220F8AECCFB45CE6107140899E8D655306AE6396553E2851376C THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 8b 100000 iter Len128pw Len128sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi04'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy6'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x2668B71B3CA56136B5E87F30E098F6B4371CB5ED95537C7A073DAC30A2D5BE52756ADF5BB2F4320CB11C4E16B24965A9C790DEF0CBC62906920B4F2EB84D1D4A THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 9a 1 iter Len129pw Len129sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi04U'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy6P'),1,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x93B9BA8283CC17D50EF3B44820828A258A996DE258225D24FB59990A6D0DE82DFB3FE2AC201952100E4CC8F06D883A9131419C0F6F5A6ECB8EC821545F14ADF1 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END

PRINT 'Long Test 9b 100000 iter Len129pw Len129sa- validated against a Python implemenation of PBKDF2'
SET @Result = YourDB.dbo.Yourfn_CRYPT_PBKDF2_VARBINARY_SHA512(CONVERT(VARBINARY(MAX),'passDATAb00AB7YxDTTlRH2dqxDx19GDxDV1zFMz7E6QVqKIzwOtMnlxQLttpE57Un4u12D2YD7oOPpiEvCDYvntXEe4NNPLCnGGeJArbYDEu6xDoCfWH6kbuV6awi04U'),CONVERT(VARBINARY(MAX),'saltKEYbcTcXHCBxtjD2PnBh44AIQ6XUOCESOhXpEp3HrcGMwbjzQKMSaf63IJemkURWoqHusIeVB8Il91NjiCGQacPUu9qTFaShLbKG0Yj4RCMV56WPj7E14EMpbxy6P'),100000,64)
SELECT @Result
PRINT CASE WHEN @Result IS NULL THEN 'NULL - BAD ALGO?' WHEN @Result = 0x2575B485AFDF37C260B8F3386D33A60ED929993C9D48AC516EC66B87E06BE54ADE7E7C8CB3417C81603B080A8EEFC56072811129737CED96236B9364E22CE3A5 THEN 'PASS' ELSE 'FAIL INVALID RESULT' END
PRINT 'Duration (ms): ' + CONVERT(NVARCHAR(23),DATEDIFF(ms,@start,SYSDATETIME()))

*/

  DECLARE @NumDigestSizesRequiredToEncompassOutputbytes INT
  DECLARE @RemainderOutputbytesAfterNumDigestSizesMinusOne INT
  DECLARE @Working BINARY(64) -- digest size
  DECLARE @ThisIterationResult BINARY(64) -- digest size
  DECLARE @FirstIterationDefinedResult VARBINARY(MAX) -- Salt size + INT size per HMAC definition
  DECLARE @output VARBINARY(MAX)
  DECLARE @CurrentDigestSizeChunk INT
  DECLARE @CurrentIteration INT
  -- Start Inlined HMAC-SHA-512 variables
  DECLARE @ipadRFC2104 BIGINT
  DECLARE @opadRFC2104 BIGINT
  DECLARE @k_ipadRFC2104 BINARY(128) -- BLOCKSIZE in bytes per HMAC definition
  DECLARE @k_opadRFC2104 BINARY(128) -- BLOCKSIZE in bytes per HMAC definition
  --SQL fails to allow binary operations on two binary data types!!!  We use bigint and iterate 8 times for 512 bits = 64 byte blocksize for better performance.
  SET @ipadRFC2104 = CAST(0x3636363636363636 AS BIGINT)
  SET @opadRFC2104 = CAST(0x5C5C5C5C5C5C5C5C AS BIGINT)
  -- End Inlined HMAC-SHA-512 variables  

  SET @NumDigestSizesRequiredToEncompassOutputbytes = (@Outputbytes + 63)/64 -- number > 1 is digest size/digest size minus 1
  SET @RemainderOutputbytesAfterNumDigestSizesMinusOne = @Outputbytes - (@NumDigestSizesRequiredToEncompassOutputbytes - 1) * 64 -- the number in here that's > 1 is the digest size


  SET @output = 0x
  SET @CurrentDigestSizeChunk = 1

  WHILE @CurrentDigestSizeChunk <= @NumDigestSizesRequiredToEncompassOutputbytes
  BEGIN
    SET @FirstIterationDefinedResult = @Salt + CAST(@CurrentDigestSizeChunk AS VARBINARY(4))
    --SET @ThisIterationResult = YourDB.dbo.Yourfn_CRYPT_HMAC_SHA512(@Password,@FirstIterationDefinedResult)

    -- NOTE: Inlining HMAC-SHA-512 appears to improve performance by a factor of six or so.  Setting the HMAC as an Inlined Table Valued Function instead of a Scalar function would reduce this disparity, of course.
    -- START INLINED HMAC-SHA-512 for performance improvement
    -- B = BLOCKSIZE (64 bytes for MD5, SHA-224, SHA-256, and 128 bytes for SHA-384 and SHA-512, per RFC2104 and RFC4868)
    IF LEN(@Password) > 128 -- Applications that use keys longer than B bytes will first hash the key using H and then use the resultant L byte string as the actual key to HMAC 
      SET @Password = CAST(HASHBYTES('SHA2_512', @Password) AS BINARY (128))
    ELSE
      SET @Password = CAST(@Password AS BINARY (128)) -- append zeros to the end of K to create a B byte string

    -- Loop unrolled for definite performance benefit
    -- Must XOR BLOCKSIZE bytes
    SET @k_ipadRFC2104 = CONVERT(BINARY(8),(SUBSTRING(@Password, 1, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 9, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 17, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 25, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 33, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 41, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 49, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 57, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 65, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 73, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 81, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 89, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 97, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 105, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 113, 8) ^ @ipadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 121, 8) ^ @ipadRFC2104))

    -- Loop unrolled for definite performance benefit
    -- Must XOR BLOCKSIZE bytes
    SET @k_opadRFC2104 = CONVERT(BINARY(8),(SUBSTRING(@Password, 1, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 9, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 17, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 25, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 33, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 41, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 49, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 57, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 65, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 73, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 81, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 89, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 97, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 105, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 113, 8) ^ @opadRFC2104))
      + CONVERT(BINARY(8),(SUBSTRING(@Password, 121, 8) ^ @opadRFC2104))

    SET @ThisIterationResult = HASHBYTES('SHA2_512', @k_opadRFC2104 + HASHBYTES('SHA2_512', @k_ipadRFC2104 + @FirstIterationDefinedResult))
    -- END   INLINED HMAC-SHA-512 for performance improvement

    SET @Working = @ThisIterationResult

    SET @CurrentIteration = 1
    WHILE @CurrentIteration < @IterationCount
    BEGIN
      --SET @ThisIterationResult = YourDB.dbo.Yourfn_CRYPT_HMAC_SHA512(@Password,@ThisIterationResult)

      -- NOTE: Inlining HMAC-SHA-512 appears to improve performance by a factor of six or so.  Setting the HMAC as an Inlined Table Valued Function instead of a Scalar function would reduce this disparity, of course.
      -- START INLINED HMAC-SHA-512 for performance improvement
      -- B = BLOCKSIZE (64 bytes for MD5, SHA-224, SHA-256, and 128 bytes for SHA-384 and SHA-512, per RFC2104 and RFC4868)

      -- We've already hashed the password if we needed to!
      -- We've already generated @k_ipadRFC2104 and @k_opadRFC2104 both!

      SET @ThisIterationResult =  HASHBYTES('SHA2_512', @k_opadRFC2104 + HASHBYTES('SHA2_512', @k_ipadRFC2104 + @ThisIterationResult))
      -- END   INLINED HMAC-SHA-512 for performance improvement

      -- Loop unrolled for possible performance benefit
      -- Stupid conversion required because SQL Server can't do binary operations on two binary variables!!!
      -- Must XOR digest size bytes
      SET @Working = CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,1,8)))^SUBSTRING(@Working,1,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,9,8)))^SUBSTRING(@Working,9,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,17,8)))^SUBSTRING(@Working,17,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,25,8)))^SUBSTRING(@Working,25,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,33,8)))^SUBSTRING(@Working,33,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,41,8)))^SUBSTRING(@Working,41,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,49,8)))^SUBSTRING(@Working,49,8)))
        + CONVERT(BINARY(8),(CONVERT(BIGINT,(SUBSTRING(@ThisIterationResult,57,8)))^SUBSTRING(@Working,57,8)))

      SET @CurrentIteration += 1 -- SHA-512 is a SQL 2012 only function, so SQL 2008 only syntax doesn't limit compatibility any further.
    END -- WHILE @CurrentIteration rounds

    SELECT @output = @output +
      CASE
        WHEN @CurrentDigestSizeChunk = @NumDigestSizesRequiredToEncompassOutputbytes THEN CONVERT(BINARY(64),LEFT(@Working,@RemainderOutputbytesAfterNumDigestSizesMinusOne)) -- digest size in bytes
        ELSE CONVERT(BINARY(64),@Working) -- digest size in bytes
        END 
    SET @CurrentDigestSizeChunk += 1 -- SHA-512 is a SQL 2012 only function, so SQL 2008 only syntax doesn't limit compatibility any further.
  END

  RETURN @output

END



GO
PRINT N'Creating [dsp].[Convert_BinaryToBase64]'
GO

-- #Inliner {"InlineMode":"none"} 
CREATE FUNCTION [dsp].[Convert_BinaryToBase64] (@bin VARBINARY(MAX))
RETURNS TSTRING
AS
BEGIN
	DECLARE @Base64 TSTRING;
	/*
        SELECT dbo.f_BinaryToBase64(CONVERT(VARBINARY(MAX), 'Converting this text to Base64...'))
    */
	SET @Base64 = CAST(N'' AS XML).value('xs:base64Binary(xs:hexBinary(sql:variable("@bin")))', 'TSTRING');
	RETURN @Base64;
END;

GO
PRINT N'Creating [dsp].[Const_Algorithm_PBKDF2_SHA512]'
GO
CREATE FUNCTION [dsp].[Const_Algorithm_PBKDF2_SHA512] ( )
RETURNS TSTRING
AS
BEGIN
    RETURN 'PBKDF2_SHA512';
END;


GO
PRINT N'Creating [dsp].[Crypt_CreatePassword]'
GO
CREATE PROCEDURE [dsp].[Crypt_CreatePassword]
    @Password TSTRINGA, -- NO Unicode Support
    @Algorithm TSTRING = NULL,
    @Iteration INT = 30000,
    @Salt TSTRINGA = NULL , -- NO Unicode Support
    @PasswordString TSTRING OUT
AS
BEGIN
    SET @Algorithm = LOWER(ISNULL(@Algorithm, dsp.Const_Algorithm_PBKDF2_SHA512()));
    IF ( @Algorithm = LOWER(dsp.Const_Algorithm_PBKDF2_SHA512()) )
    BEGIN
    
        IF ( @Salt IS NULL )
            EXEC dsp.String_CreateRandom @Length = 20, @RandomString = @Salt OUTPUT;
        DECLARE @PasswordHash TSTRING;
        SET @PasswordHash = dsp.Convert_BinaryToBase64(dsp.CRYPT_PBKDF2_VARBINARY_SHA512(CAST(@Password AS VARBINARY(MAX)), CAST(@Salt AS VARBINARY(MAX)),
                                                                                           @Iteration, 64));
	   SET @PasswordString = @Algorithm + '$' + dsp.Convert_ToString(@Iteration) + '$' + @Salt + '$' + @PasswordHash;
    END;
END;





GO
PRINT N'Creating [dspInboxMessage].[vw_MessagePattern]'
GO
CREATE VIEW [dspInboxMessage].[vw_MessagePattern]
AS
SELECT  MessagePatternId, PatternName, StartTime, ExpirationTime, MessagePatternSepratorId, PatternKey, MessagePatternStateId, ResponseProcedureSchemaName,
    ResponseProcedureName, Description
  FROM  dspInboxMessage.MessagePattern
 WHERE  IsDeleted = 0;;
GO
PRINT N'Creating [tSQLt].[Private_RunTestClass]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunTestClass]
  @TestClassName NVARCHAR(MAX)
AS
BEGIN
    DECLARE @TestCaseName NVARCHAR(MAX);
    DECLARE @TestClassId INT; SET @TestClassId = tSQLt.Private_GetSchemaId(@TestClassName);
    DECLARE @SetupProcName NVARCHAR(MAX);
    EXEC tSQLt.Private_GetSetupProcedureName @TestClassId, @SetupProcName OUTPUT;
    
    DECLARE testCases CURSOR LOCAL FAST_FORWARD 
        FOR
     SELECT tSQLt.Private_GetQuotedFullName(object_id)
       FROM sys.procedures
      WHERE schema_id = @TestClassId
        AND LOWER(name) LIKE 'test%';

    OPEN testCases;
    
    FETCH NEXT FROM testCases INTO @TestCaseName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        EXEC tSQLt.Private_RunTest @TestCaseName, @SetupProcName;

        FETCH NEXT FROM testCases INTO @TestCaseName;
    END;

    CLOSE testCases;
    DEALLOCATE testCases;
END;
GO
PRINT N'Creating [SQLCop].[test Column data types (Numeric vs. Int)]'
GO
CREATE PROCEDURE [SQLCop].[test Column data types (Numeric vs. Int)]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/always-include-precision-and-scale-with
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

	Select	@Output = @Output + ProblemItem + Char(13) + Char(10)
	From	(
			SELECT	TABLE_SCHEMA + '.' + TABLE_NAME + '.' + COLUMN_NAME As ProblemItem
            FROM	INFORMATION_SCHEMA.COLUMNS C
            WHERE	C.DATA_TYPE IN ('numeric','decimal') 
					AND NUMERIC_SCALE = 0 
					AND NUMERIC_PRECISION <= 18
					AND TABLE_SCHEMA <> 'tSQLt'
			) As Problems
	Order By ProblemItem

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/sql-server-types-numeric-vs-int' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	
END;
GO
PRINT N'Creating [dsp].[Path_RemoveExtension]'
GO
CREATE FUNCTION [dsp].[Path_RemoveExtension] (
	@Path TSTRING)
RETURNS TSTRING
BEGIN
	RETURN LEFT(@Path, LEN(@Path) - CHARINDEX('.', REVERSE(@Path)));
END;
GO
PRINT N'Creating [dsp].[Database_InitInMemoryDatabase]'
GO
CREATE PROCEDURE [dsp].[Database_InitInMemoryDatabase]
    @DbName TSTRING
AS
BEGIN
    SET @DbName = ISNULL(@DbName, DB_NAME());

    DECLARE @dbFile TSTRING;

    SELECT  @dbFile = mf.physical_name
      FROM  sys.master_files mf
     WHERE  mf.name = @DbName;

    DECLARE @InMemoryFile TSTRING = dsp.Path_RemoveExtension(@dbFile) + '_mod';

    -- Add FileGroup if not exists
    IF NOT EXISTS (SELECT   1 FROM  sys.filegroups WHERE name = 'InMemory_mod')
		ALTER DATABASE CURRENT ADD FILEGROUP InMemory_mod CONTAINS MEMORY_OPTIMIZED_DATA;

    -- Add File to file group if not added
    DECLARE @InMemoryName TSTRING = @DbName + '_mod1';
    DECLARE @Sql TSTRING = 'ALTER DATABASE CURRENT ADD FILE (name=''{InMemoryName}'', filename=''{InMemoryFile}'') TO FILEGROUP InMemory_mod';
    SET @Sql = REPLACE(@Sql, '{InMemoryFile}', @InMemoryFile);
    SET @Sql = REPLACE(@Sql, '{InMemoryName}', @InMemoryName);

    IF NOT EXISTS (SELECT   * FROM  sys.database_files WHERE name = @InMemoryName)
		EXEC sys.sp_executesql @stmt = @Sql;
END;




GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$GetMessagePatternIdByCoding]'
GO
CREATE FUNCTION [dspInboxMessage].[InboxMessageProcess_$GetMessagePatternIdByCoding] (@MessageBody TSTRING,
    @MessageTime DATETIME)
RETURNS INT
AS
BEGIN
    -- TODO: Need Index
    RETURN (   SELECT TOP (1)   MP.MessagePatternId
                 FROM   dspInboxMessage.vw_MessagePattern MP
                        INNER JOIN dspInboxMessage.MessagePatternSeprator MPS ON MPS.MessagePatternSepratorId = MP.MessagePatternSepratorId
                WHERE   MP.MessagePatternStateId = /*dspconst.MessagePatternStateId_Started()*/ 2 --
                   AND  ISNULL(@MessageTime, GETDATE()) BETWEEN MP.StartTime AND MP.ExpirationTime --
                   AND  MP.PatternKey = SUBSTRING(
                                            @MessageBody, 1, ISNULL(NULLIF(CHARINDEX(MPS.MessagePatternSeprator, @MessageBody, 2) - 1, -1), LEN(@MessageBody))));
END;
GO
PRINT N'Creating [tSQLt].[Run_LastExecution]'
GO
CREATE TABLE [tSQLt].[Run_LastExecution]
(
[TestName] [nvarchar] (max) NULL,
[SessionId] [int] NULL,
[LoginTime] [datetime] NULL
)
GO
PRINT N'Creating [tSQLt].[Private_SaveTestNameForSession]'
GO
CREATE PROCEDURE [tSQLt].[Private_SaveTestNameForSession] 
  @TestName NVARCHAR(MAX)
AS
BEGIN
  DELETE FROM tSQLt.Run_LastExecution
   WHERE SessionId = @@SPID;  

  INSERT INTO tSQLt.Run_LastExecution(TestName, SessionId, LoginTime)
  SELECT TestName = @TestName,
         session_id,
         login_time
    FROM sys.dm_exec_sessions
   WHERE session_id = @@SPID;
END
GO
PRINT N'Creating [SQLCop].[test Column Name Problems]'
GO
CREATE PROCEDURE [SQLCop].[test Column Name Problems]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-spaces-or-other-invalid-chara
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''
			
	SELECT 	@Output = @Output + TABLE_SCHEMA + '.' + TABLE_NAME + '.' + COLUMN_NAME + Char(13) + Char(10)
	FROM	INFORMATION_SCHEMA.COLUMNS
	WHERE	COLUMN_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE '%[^a-z0-9_$]%'
			And TABLE_SCHEMA <> 'tSQLt'
	Order By TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-spaces-or-other-invalid-chara' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	  
END;
GO
PRINT N'Creating [dspInboxMessage].[MessageLastData_ReadJson]'
GO
CREATE FUNCTION [dspInboxMessage].[MessageLastData_ReadJson] (@MessageLastData TJSON)
RETURNS TABLE
AS
RETURN (   SELECT   MsgKey, MsgValue
             FROM
                OPENJSON(@MessageLastData)
                WITH (MsgKey TSTRING, MsgValue TSTRING));
GO
PRINT N'Creating [tSQLt].[Private_ResolveSchemaName]'
GO
CREATE FUNCTION [tSQLt].[Private_ResolveSchemaName](@Name NVARCHAR(MAX))
RETURNS TABLE 
AS
RETURN
  WITH ids(schemaId) AS
       (SELECT tSQLt.Private_GetSchemaId(@Name)
       ),
       idsWithNames(schemaId, quotedSchemaName) AS
        (SELECT schemaId,
         QUOTENAME(SCHEMA_NAME(schemaId))
         FROM ids
        )
  SELECT schemaId, 
         quotedSchemaName,
         CASE WHEN EXISTS(SELECT 1 FROM tSQLt.TestClasses WHERE TestClasses.SchemaId = idsWithNames.schemaId)
               THEN 1
              ELSE 0
         END AS isTestClass, 
         CASE WHEN schemaId IS NOT NULL THEN 1 ELSE 0 END AS isSchema
    FROM idsWithNames;
GO
PRINT N'Creating [tSQLt].[Private_ResolveObjectName]'
GO
CREATE FUNCTION [tSQLt].[Private_ResolveObjectName](@Name NVARCHAR(MAX))
RETURNS TABLE 
AS
RETURN
  WITH ids(schemaId, objectId) AS
       (SELECT SCHEMA_ID(OBJECT_SCHEMA_NAME(OBJECT_ID(@Name))),
               OBJECT_ID(@Name)
       ),
       idsWithNames(schemaId, objectId, quotedSchemaName, quotedObjectName) AS
        (SELECT schemaId, objectId,
         QUOTENAME(SCHEMA_NAME(schemaId)) AS quotedSchemaName, 
         QUOTENAME(OBJECT_NAME(objectId)) AS quotedObjectName
         FROM ids
        )
  SELECT schemaId, 
         objectId, 
         quotedSchemaName,
         quotedObjectName,
         quotedSchemaName + '.' + quotedObjectName AS quotedFullName, 
         CASE WHEN LOWER(quotedObjectName) LIKE '[[]test%]' 
               AND objectId = OBJECT_ID(quotedSchemaName + '.' + quotedObjectName,'P') 
              THEN 1 ELSE 0 END AS isTestCase
    FROM idsWithNames;
GO
PRINT N'Creating [tSQLt].[Private_ResolveName]'
GO
CREATE FUNCTION [tSQLt].[Private_ResolveName](@Name NVARCHAR(MAX))
RETURNS TABLE 
AS
RETURN
  WITH resolvedNames(ord, schemaId, objectId, quotedSchemaName, quotedObjectName, quotedFullName, isTestClass, isTestCase, isSchema) AS
  (SELECT 1, schemaId, NULL, quotedSchemaName, NULL, quotedSchemaName, isTestClass, 0, 1
     FROM tSQLt.Private_ResolveSchemaName(@Name)
    UNION ALL
   SELECT 2, schemaId, objectId, quotedSchemaName, quotedObjectName, quotedFullName, 0, isTestCase, 0
     FROM tSQLt.Private_ResolveObjectName(@Name)
    UNION ALL
   SELECT 3, NULL, NULL, NULL, NULL, NULL, 0, 0, 0
   )
   SELECT TOP(1) schemaId, objectId, quotedSchemaName, quotedObjectName, quotedFullName, isTestClass, isTestCase, isSchema
     FROM resolvedNames
    WHERE schemaId IS NOT NULL 
       OR ord = 3
    ORDER BY ord
GO
PRINT N'Creating [tSQLt].[Private_GetLastTestNameIfNotProvided]'
GO
----------------------------------------------------------------------
CREATE FUNCTION [tSQLt].[Private_GetLastTestNameIfNotProvided](@TestName NVARCHAR(MAX))
RETURNS NVARCHAR(MAX)
AS
BEGIN
  IF(LTRIM(ISNULL(@TestName,'')) = '')
  BEGIN
    SELECT @TestName = TestName 
      FROM tSQLt.Run_LastExecution le
      JOIN sys.dm_exec_sessions es
        ON le.SessionId = es.session_id
       AND le.LoginTime = es.login_time
     WHERE es.session_id = @@SPID;
  END

  RETURN @TestName;
END
GO
PRINT N'Creating [tSQLt].[Private_Run]'
GO
CREATE PROCEDURE [tSQLt].[Private_Run]
   @TestName NVARCHAR(MAX),
   @TestResultFormatter NVARCHAR(MAX)
AS
BEGIN
SET NOCOUNT ON;
    DECLARE @FullName NVARCHAR(MAX);
    DECLARE @TestClassId INT;
    DECLARE @IsTestClass BIT;
    DECLARE @IsTestCase BIT;
    DECLARE @IsSchema BIT;
    DECLARE @SetUp NVARCHAR(MAX);SET @SetUp = NULL;
    
    SELECT @TestName = tSQLt.Private_GetLastTestNameIfNotProvided(@TestName);
    EXEC tSQLt.Private_SaveTestNameForSession @TestName;
    
    SELECT @TestClassId = schemaId,
           @FullName = quotedFullName,
           @IsTestClass = isTestClass,
           @IsSchema = isSchema,
           @IsTestCase = isTestCase
      FROM tSQLt.Private_ResolveName(@TestName);

    IF @IsSchema = 1
    BEGIN
        EXEC tSQLt.Private_RunTestClass @FullName;
    END
    
    IF @IsTestCase = 1
    BEGIN
      DECLARE @SetupProcName NVARCHAR(MAX);
      EXEC tSQLt.Private_GetSetupProcedureName @TestClassId, @SetupProcName OUTPUT;

      EXEC tSQLt.Private_RunTest @FullName, @SetupProcName;
    END;

    EXEC tSQLt.Private_OutputTestResults @TestResultFormatter;
END;
GO
PRINT N'Creating [SQLCop].[test Columns of data type Text/nText]'
GO
CREATE PROCEDURE [SQLCop].[test Columns of data type Text/nText]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/don-t-use-text-datatype-for-sql-2005-and
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT  @Output = @Output + SCHEMA_NAME(o.uid) + '.' + o.Name + '.' + col.name + Char(13) + Char(10)
	from    syscolumns col         
			Inner Join sysobjects o
				On col.id = o.id         
			inner join systypes           
	 			On col.xtype = systypes.xtype 
	Where   o.type = 'U'         
			And ObjectProperty(o.id, N'IsMSShipped') = 0         
			AND systypes.name IN ('text','ntext')
			And SCHEMA_NAME(o.uid) <> 'tSQLt'
	Order By SCHEMA_NAME(o.uid),o.Name, col.Name
			
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/don-t-use-text-datatype-for-sql-2005-and' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	    
END;
GO
PRINT N'Creating [dsperr].[ThrowInvalidOperation]'
GO

CREATE PROCEDURE [dsperr].[ThrowInvalidOperation] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvalidOperationId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[StoredProcedure_Params]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_Params] (@StoredProcedureId INT)
RETURNS TABLE
AS
RETURN (   SELECT --
                P.name ParamName, --
               P.is_output IsOutput, --
               TYPE_NAME(T.system_type_id) AS SystemTypeName, --
               TYPE_NAME(T.user_type_id) AS UserTypeName, --
               P.max_length AS Length
             FROM   sys.parameters AS P
                    INNER JOIN sys.types AS T ON T.user_type_id = P.user_type_id
            WHERE   P.object_id = @StoredProcedureId);
GO
PRINT N'Creating [dsp].[StoredProcedure_Metadata]'
GO

CREATE FUNCTION [dsp].[StoredProcedure_Metadata] (@SchemaName TSTRING = 'api',
    @StoredProcedureName TSTRING)
RETURNS @StoredProcedure_Metadata TABLE (Metadata TSTRING)
AS
BEGIN
    -- Get script
    DECLARE @Script TBIGSTRING;
    SELECT  @Script = OBJECT_DEFINITION(P.object_id)
      FROM  sys.procedures AS P
     WHERE  P.schema_id = SCHEMA_ID(@SchemaName) AND P.name = @StoredProcedureName;

    --find start of text
    DECLARE @MetaStartIndex INT = CHARINDEX('#MetaStart', @Script);

    -- Check if the stored procedure does not have meta data
    IF (@MetaStartIndex = 0)
    BEGIN
        INSERT INTO @StoredProcedure_Metadata (Metadata)
        VALUES (N'{}');
        RETURN;
    END;


    SET @MetaStartIndex = @MetaStartIndex + LEN('#MetaStart');

    DECLARE @MetaEndIndex INT = CHARINDEX('#MetaEnd', @Script, @MetaStartIndex);

    INSERT INTO @StoredProcedure_Metadata (Metadata)
    VALUES (SUBSTRING(@Script, @MetaStartIndex, @MetaEndIndex - @MetaStartIndex));

    RETURN;
END;







GO
PRINT N'Creating [dsp].[StoredProcedure_InvokeStoreProcedureName]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_InvokeStoreProcedureName] (@TargetAppVersionId INT,
    @TargetStoredProcedureName TSTRING,
    @LatestAppVersionId INT)
RETURNS TSTRING
AS
BEGIN
    DECLARE @StoredProcedureInvokeName TSTRING = @TargetStoredProcedureName;

    IF (@TargetAppVersionId = @LatestAppVersionId)
        RETURN @StoredProcedureInvokeName;

    -- Get max stored procedure version number in the target application version
    DECLARE @MaxStoredProcedureVersionNumberInTarget INT;

    -- Find stored procedure invoke name
    DECLARE @NextApplicationVersionId INT = @TargetAppVersionId + 1;
    DECLARE @StordProcedureNameInNextVersion TSTRING;
    SELECT TOP 1    @StordProcedureNameInNextVersion = AVD.StoredProcedurePhysicalName
      FROM  dsp.AppVersionDetail AS AVD
     WHERE  AVD.AppVersionId = @NextApplicationVersionId --
        AND AVD.StoredProcedureVersionNumber > @MaxStoredProcedureVersionNumberInTarget
     ORDER BY AVD.StoredProcedureVersionNumber;

    SET @StoredProcedureInvokeName = ISNULL(@StordProcedureNameInNextVersion, @StoredProcedureInvokeName);

    RETURN @StoredProcedureInvokeName;
END;
GO
PRINT N'Creating [dsp].[Database_StoredProcedures]'
GO
CREATE PROCEDURE [dsp].[Database_StoredProcedures]
    @SchemaName TSTRING, @JustLastVersion BIT = 0, @StoredProceduresJsonResult TJSON = NULL OUTPUT
AS
BEGIN
    SET @JustLastVersion = ISNULL(@JustLastVersion, 0);
    -- Get the latest application version number
    DECLARE @LatestAppVersionId INT;
    SELECT TOP 1    @LatestAppVersionId = AV.VersionNumber
      FROM  dsp.AppVersion AS AV
     ORDER BY AV.CreatedTime DESC;

    IF (@LatestAppVersionId IS NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'AppVersion is empty';

    CREATE TABLE #ApplicationStoredProcedures (StoredProcedureId INT,
        AppVersionId INT,
        AppVersionDetailId INT,
        ApplicationVersionNumber NVARCHAR(/*NCQ*/ 4000),
        StoredProcedureName NVARCHAR(/*NCQ*/ 4000) COLLATE Persian_100_CS_AI,
        StoredProcedureInvokeName NVARCHAR(/*NQC*/ 4000) COLLATE Persian_100_CS_AI,
        SchemaName NVARCHAR(/*NQC*/ 4000) COLLATE Persian_100_CS_AI,
        ExtendedProps NVARCHAR(/*NCQ*/ MAX));

    INSERT INTO #ApplicationStoredProcedures (StoredProcedureId, AppVersionId, AppVersionDetailId, ApplicationVersionNumber, StoredProcedureName,
        StoredProcedureInvokeName, SchemaName, ExtendedProps)
    SELECT --
        AVD.StoredProcedureId, --
        AVD.AppVersionId, --
        AVD.AppVersionDetailId, --
        AV.VersionNumber, --
        AVD.StoredProcedureName, --
        dsp.StoredProcedure_InvokeStoreProcedureName(AV.AppVersionId, AVD.StoredProcedureName, @LatestAppVersionId) StoredProcedureInvokeName, --
        AVD.SchemaName, --
        SPM.Metadata --
      FROM  dsp.AppVersion AS AV
            INNER JOIN dsp.AppVersionDetail AS AVD ON AV.AppVersionId = AVD.AppVersionId
            OUTER APPLY dsp.StoredProcedure_Metadata(@SchemaName, StoredProcedureName) AS SPM
     WHERE  AVD.StoredProcedureVersionNumber IS NULL --
        AND (@JustLastVersion = 0 OR AV.VersionNumber = @LatestAppVersionId);

    -- Get result
    SET @StoredProceduresJsonResult = (   SELECT --
                                                AVD.StoredProcedureName, --
                                              AVD.StoredProcedureInvokeName, --
                                              AVD.AppVersionId, --
                                              AVD.SchemaName, --
                                              AVD.AppVersionId, --
                                              AVD.ApplicationVersionNumber, --
                                              JSON_QUERY(AVD.ExtendedProps, '$') AS ExtendedProps, --        
                                              Params.ParamName, --
                                              Params.IsOutput, --
                                              Params.Length, --
                                              Params.SystemTypeName, --
                                              Params.UserTypeName --
                                            FROM    #ApplicationStoredProcedures AVD
                                                    OUTER APPLY dsp.StoredProcedure_Params(StoredProcedureId) AS Params
                                           ORDER BY AVD.AppVersionId, AVD.StoredProcedureName
                                          FOR JSON AUTO);

END;




GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_Search]'
GO
CREATE FUNCTION [dspInboxMessage].[MessagePattern_Search] (@RecordCount INT,
    @RecordIndex INT,
    @FilterResponseProcedureName TSTRING,
    @FilterPatternName TSTRING,
    @FilterStartTimeFrom DATETIME,
    @FilterStartTimeTo DATETIME,
    @FilterExpirationTimeFrom DATETIME,
    @FilterExpirationTimeTo DATETIME,
    @FilterMessagePatternStateId INT,
    @FilterPatternKey TSTRING)
RETURNS TABLE
AS
RETURN (
-- SQL Prompt formatting off
	SELECT   MP.MessagePatternId, MP.PatternName, MP.StartTime, MP.ExpirationTime, MessagePatternSeprator = MPSP.MessagePatternSeprator
		, MP.PatternKey, MessagePatternState = MPS.MessagePatternStateName, MP.Description
	FROM   dspInboxMessage.vw_MessagePattern MP
	INNER JOIN dspInboxMessage.MessagePatternState MPS ON MPS.MessagePatternStateId = MP.MessagePatternStateId
	INNER JOIN dspInboxMessage.MessagePatternSeprator MPSP ON MPSP.MessagePatternSepratorId = MP.MessagePatternSepratorId
    WHERE  (@FilterPatternName IS NULL OR MP.PatternName LIKE '%' + @FilterPatternName + '%')
		AND (@FilterStartTimeFrom IS NULL OR MP.StartTime >= @FilterStartTimeFrom)
		AND (@FilterStartTimeTo IS NULL OR MP.StartTime <= @FilterStartTimeTo)
		AND (@FilterExpirationTimeFrom IS NULL OR MP.ExpirationTime >= @FilterExpirationTimeFrom)
		AND (@FilterExpirationTimeTo IS NULL OR MP.ExpirationTime <= @FilterExpirationTimeTo)
		AND (@FilterMessagePatternStateId IS NULL OR MP.MessagePatternStateId = @FilterMessagePatternStateId)
		AND (@FilterPatternKey IS NULL OR MP.PatternKey LIKE '%' + @FilterPatternKey + '%')
		AND (@FilterResponseProcedureName IS NULL OR MP.ResponseProcedureName LIKE '%' + @FilterResponseProcedureName + '%')
    ORDER BY MP.MessagePatternId DESC OFFSET @RecordIndex ROWS FETCH NEXT @RecordCount ROWS ONLY);

-- SQL Prompt formatting on
GO
PRINT N'Creating [tSQLt].[Private_RunCursor]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunCursor]
  @TestResultFormatter NVARCHAR(MAX),
  @GetCursorCallback NVARCHAR(MAX)
AS
BEGIN
  SET NOCOUNT ON;
  DECLARE @TestClassName NVARCHAR(MAX);
  DECLARE @TestProcName NVARCHAR(MAX);

  DECLARE @TestClassCursor CURSOR;
  EXEC @GetCursorCallback @TestClassCursor = @TestClassCursor OUT;
----  
  WHILE(1=1)
  BEGIN
    FETCH NEXT FROM @TestClassCursor INTO @TestClassName;
    IF(@@FETCH_STATUS<>0)BREAK;

    EXEC tSQLt.Private_RunTestClass @TestClassName;
    
  END;
  
  CLOSE @TestClassCursor;
  DEALLOCATE @TestClassCursor;
  
  EXEC tSQLt.Private_OutputTestResults @TestResultFormatter;
END;
GO
PRINT N'Creating [SQLCop].[test Columns with float data type]'
GO
CREATE PROCEDURE [SQLCop].[test Columns with float data type]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-the-float-data-type
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''
			
	SELECT 	@Output = @Output + TABLE_SCHEMA + '.' + TABLE_NAME + '.' + COLUMN_NAME + Char(13) + Char(10)
	FROM	INFORMATION_SCHEMA.COLUMNS
	WHERE	DATA_TYPE IN ('float', 'real')
			AND TABLE_SCHEMA <> 'tSQLt'
	Order By TABLE_SCHEMA,TABLE_NAME,COLUMN_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-the-float-data-type' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	    
END;
GO
PRINT N'Creating [dspconst].[TemporalType_Temporal]'
GO

CREATE   FUNCTION [dspconst].[TemporalType_Temporal]() 
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;

GO
PRINT N'Creating [dspconst].[TemporalType_Lookup]'
GO
CREATE    FUNCTION [dspconst].[TemporalType_Lookup] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;




GO
PRINT N'Creating [dsp].[SplitString]'
GO
CREATE   FUNCTION [dsp].[SplitString] (@Exprission TSTRING,
    @Seprator NCHAR(1))
RETURNS TABLE
AS
RETURN (   SELECT   [value]
             FROM   STRING_SPLIT(@Exprission, @Seprator)
            WHERE  [value] <> ''
			);

GO
PRINT N'Creating [dsp].[Json_ReadNested]'
GO
CREATE FUNCTION [dsp].[Json_ReadNested] (@RootPath NVARCHAR(MAX),
    @JsonToRead NVARCHAR(MAX))
RETURNS TABLE
WITH SCHEMABINDING
AS
-- SQL Prompt Formatting Off
RETURN (WITH Root_Json 
		AS (
			SELECT	OJ.[key] AS JKey
					,OJ.value AS JValue
					,OJ.type AS JType
					,JPath = @RootPath COLLATE DATABASE_DEFAULT
					,JAddress = @RootPath COLLATE DATABASE_DEFAULT
					,JIndex = IIF(ISNUMERIC(OJ.[key]) = 1, OJ.[key], NULL)
			FROM	OPENJSON( @JsonToRead, @RootPath) OJ
			UNION ALL
			SELECT	Sub_Json.[key] AS JKey
					,Sub_Json.value AS JValue
					,Sub_Json.type AS JType
					,JPath = (Root_Json.JPath + IIF(ISNUMERIC( Root_Json.JKey ) = 1, '', '.' + Root_Json.JKey))
					,JAddress = (Root_Json.JAddress + IIF(ISNUMERIC( Root_Json.JKey ) = 1, '[' + Root_Json.JKey + ']', '.' + Root_Json.JKey))
					,JIndex = IIF(ISNUMERIC( Root_Json.JKey ) = 1, Root_Json.JKey , NULL)
			FROM	Root_Json
			CROSS APPLY OPENJSON( JValue ) Sub_Json
			WHERE	Root_Json.JType IN (4, 5)
		)
	SELECT	Root_Json.JKey
			,Root_Json.JValue
			,Root_Json.JType
			,Root_Json.JPath
			,Root_Json.JAddress + IIF(ISNUMERIC(Root_Json.JKey) = 1, '[' + Root_Json.JKey + ']', '.' + Root_Json.JKey) AS JAddress
			,Root_Json.JIndex
	FROM	Root_Json
	WHERE Root_Json.JType <> 5);
GO
PRINT N'Creating [dsp].[Json_Getproperties]'
GO
CREATE FUNCTION [dsp].[Json_Getproperties] (@Json NVARCHAR(MAX),
    @WithTypes BIT = 0)
RETURNS NVARCHAR(MAX)
WITH SCHEMABINDING
AS
BEGIN
    DECLARE @PropertiesName NVARCHAR(MAX);
    SELECT  @PropertiesName = COALESCE(@PropertiesName + ', ', '') + JRN.JKey + IIF(ISNULL(@WithTypes, 0) = 1,
                                                                                    (CASE
                                                                                         WHEN JRN.JType IN ( 1, 2 )
                                                                                             THEN ' NVARCHAR(MAX)' --
                                                                                         WHEN JRN.JType = 3
                                                                                             THEN ' BIT' --
                                                                                         WHEN JRN.JType = 4
                                                                                             THEN ' NVARCHAR(MAX) AS JSON' --
                                                                                     END),
                                                                                    '')
      FROM  dsp.Json_ReadNested('$', @Json) AS JRN
     WHERE  JRN.JPath = '$' AND JRN.JIndex = 0;

    RETURN @PropertiesName;
END;

GO
PRINT N'Creating [dsp].[Json_GetSelectScript]'
GO
CREATE FUNCTION [dsp].[Json_GetSelectScript] (@Json NVARCHAR(MAX)/*NQC*/)
RETURNS NVARCHAR(MAX) /*NQC*/
AS
BEGIN
    IF (LEN(ISNULL(@Json, '')) < 3)
        RETURN '';

    DECLARE @WithClause TSTRING = 'WITH (' + dsp.Json_Getproperties(@Json, 1) + ')';
    DECLARE @Query TSTRING = N'SELECT * FROM OPENJSON(''' + @Json + N''') ' + ISNULL(@WithClause, '') + N' AS OJ';

    RETURN @Query;
END;

GO
PRINT N'Creating [DatabaseVersioning].[Table_SyncDataScript]'
GO
CREATE FUNCTION [DatabaseVersioning].[Table_SyncDataScript] (@SchemaName NVARCHAR(MAX), /*NQC*/
    @TableName NVARCHAR(MAX), /*NQC*/
    @TemporalTypeIdValue INT,
    @SrcJson NVARCHAR(MAX)/*NQC*/

)
RETURNS NVARCHAR(MAX) /*NQC*/
AS
BEGIN
    DECLARE @Script NVARCHAR(MAX)/*NQC*/;
    DECLARE @OBJECT_ID INT = OBJECT_ID(@SchemaName + '.' + @TableName);
    DECLARE @DeleteScript TSTRING = '';
    IF @TemporalTypeIdValue = dspconst.TemporalType_Lookup()
        SET @DeleteScript = ' WHEN NOT MATCHED BY SOURCE THEN DELETE ';

    WITH MyClustered -- this tables have a primary key
        AS (SELECT  value COLUMN_NAME
              FROM  dsp.SplitString(
                        IIF(@TableName LIKE '%History',
                            N'VersioningStartTime,VersioningEndTime',
                        (   SELECT  s.ClusterColumnsName
                              FROM  dsp.SystemTable s
                             WHERE s.SchemaName = @SchemaName AND s.TableName = @TableName)), ',') ), --
    MyColumns
        AS (SELECT  name AS COLUMN_NAME
              FROM  sys.columns
             WHERE  object_id = @OBJECT_ID AND  is_computed = 0)
    SELECT  @Script =
        IIF(EXISTS (SELECT  1 FROM  sys.identity_columns IC WHERE   IC.object_id = @OBJECT_ID),
        'SET IDENTITY_INSERT ' + @SchemaName + '.' + @TableName + ' ON;',
        '') + N'MERGE INTO ' + @SchemaName + N'.' + @TableName + N' AS TGT USING (' + dsp.Json_GetSelectScript(@SrcJson) + N') AS Merge_Source ON '
        +   (SELECT STUFF((   SELECT    CAST( --
                                  IIF((SELECT   COUNT(*) FROM   MyClustered) = 1, ' ', ' and ') AS VARCHAR(MAX)) --
                                        + 'Merge_Source.' + clm.COLUMN_NAME + '= TGT.' + clm.COLUMN_NAME
                                FROM    MyColumns clm
                               WHERE EXISTS (SELECT 1 FROM  MyClustered WHERE   MyClustered.COLUMN_NAME = clm.COLUMN_NAME)
                              FOR XML PATH('')), 1, IIF((SELECT COUNT(*) FROM   MyClustered) = 1, 1, 4), ''))
        + N' WHEN MATCHED AND EXISTS( SELECT Merge_Source.* EXCEPT SELECT TGT.* )     
THEN   UPDATE     SET ' + -- in this case check updated data and choosing columns of table without primary key
            (SELECT STUFF((   SELECT    CAST(',' AS VARCHAR(MAX)) + 'TGT.' + clm.COLUMN_NAME + '= Merge_Source.' + clm.COLUMN_NAME
                                FROM    MyColumns clm
                               WHERE NOT EXISTS (SELECT 1 FROM  MyClustered WHERE   MyClustered.COLUMN_NAME = clm.COLUMN_NAME)
                              FOR XML PATH('')), 1, 1, '')) + N' WHEN
NOT MATCHED THEN  INSERT (' + --in this case for insert.
            (SELECT STUFF((   SELECT    CAST(',' AS VARCHAR(MAX)) + clm.COLUMN_NAME
                                FROM    MyColumns clm
                              FOR XML PATH('')), 1, 1, '')) + N') VALUES ('
        +   (SELECT     STUFF((   SELECT    CAST(',' AS VARCHAR(MAX)) + 'Merge_Source.' + clm.COLUMN_NAME
                                    FROM    MyColumns clm
                                  FOR XML PATH('')), 1, 1, '')) + N')
'                     + @DeleteScript + N'
;'
        + IIF(EXISTS (SELECT    1 FROM  sys.identity_columns IC WHERE   IC.object_id = @OBJECT_ID),
          'SET IDENTITY_INSERT ' + @SchemaName + '.' + @TableName + ' OFF;',
          '');

    RETURN @Script;

END;

GO
PRINT N'Creating [DatabaseVersioning].[Table_SyncData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_SyncData]
    @SchemaName TSTRING, @TableName TSTRING, @TemporalTypeIdValue INT, @MainItemJson TJSON, @HistoryItemJson TJSON = NULL
AS
BEGIN
    -- Prepare parameters
    DECLARE @Query TBIGSTRING;

    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;

    BEGIN TRY
        -- Get merge script to sync datas
        SET @Query = DatabaseVersioning.Table_SyncDataScript(@SchemaName, @TableName, @TemporalTypeIdValue, @MainItemJson);

        -- Call merge command to sync datas        
        EXEC (@Query);

        -- For temporal tables, sync history table datas
        IF (@TemporalTypeIdValue = dspconst.TemporalType_Temporal())
        BEGIN
            SET @Query = DatabaseVersioning.Table_SyncDataScript(@SchemaName, @TableName + 'History', @TemporalTypeIdValue, @HistoryItemJson);
			--SELECT @SchemaName , @TableName , @TemporalTypeIdValue , @HistoryItemJson
			--PRINT @Query
            EXEC (@Query);
			
        END;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH;

END;



GO
PRINT N'Creating [dsperr].[InvalidArgumentId]'
GO

CREATE FUNCTION [dsperr].[InvalidArgumentId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55006;  
END
			
GO
PRINT N'Creating [dsp].[Exception_BuildMessage]'
GO
CREATE	FUNCTION [dsp].[Exception_BuildMessage] (@ProcId INT,
	@ExceptionId INT,
	@Message TSTRING = NULL)
RETURNS TJSON
AS
BEGIN
	RETURN	dsp.Exception_BuildMessageParam4(@ProcId, @ExceptionId, @Message, DEFAULT, DEFAULT, DEFAULT, DEFAULT);
END;
GO
PRINT N'Creating [dsp].[Exception_BuildInvalidArgument]'
GO
CREATE FUNCTION [dsp].[Exception_BuildInvalidArgument] (@ProcId INT,
    @ArgumentName TSTRING,
    @ArgumentValue TSTRING,
    @Message TSTRING)
RETURNS TSTRING
AS
BEGIN
    DECLARE @ArgMessage TSTRING;
    EXEC @ArgMessage = dsp.Formatter_FormatMessage @Message = N'{"ArgumentName": "{0}", "ArgumentValue": "{1}"}', @Param0 = @ArgumentName,
        @Param1 = @ArgumentValue;

    IF (@Message IS NOT NULL)
        SET @ArgMessage = JSON_MODIFY(@ArgMessage, '$.Message', @Message);

    DECLARE @ExceptionId INT = dsperr.InvalidArgumentId();
    RETURN dsp.Exception_BuildMessage(@ProcId, @ExceptionId, @ArgMessage);
END;

GO
PRINT N'Creating [dsp].[ThrowInvalidArgument]'
GO

CREATE	PROCEDURE [dsp].[ThrowInvalidArgument]
	@ProcId INT, @ArgumentName TSTRING, @ArgumentValue TSTRING, @Message TSTRING = NULL
AS
BEGIN
	SET NOCOUNT ON;
	DECLARE @Exception TJSON;
	EXEC @Exception = dsp.Exception_BuildInvalidArgument @ProcId = @ProcId, @ArgumentName = @ArgumentName, @ArgumentValue = @ArgumentValue, @Message = @Message;
	EXEC dsp.ThrowException @Exception = @Exception;
END;











GO
PRINT N'Creating [dsp].[Validate_CheckNotNull]'
GO

CREATE PROCEDURE [dsp].[Validate_CheckNotNull]
    @ProcId INT, @ArgumentName TSTRING, @ArgumentValue TSTRING, @Message TSTRING = NULL
AS
BEGIN
    IF (@ArgumentValue IS NULL) --
        EXEC dsp.ThrowInvalidArgument @ProcId = @ProcId, @ArgumentName = @ArgumentName, @ArgumentValue = @ArgumentValue, @Message = @Message;
END;









GO
PRINT N'Creating [dspconst].[TemporalType_Transactional]'
GO

CREATE FUNCTION [dspconst].[TemporalType_Transactional]() 
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;





GO
PRINT N'Creating [DatabaseVersioning].[Table_Columns]'
GO
CREATE FUNCTION [DatabaseVersioning].[Table_Columns] (@SchemaName NVARCHAR(255),
    @TableName NVARCHAR(255))
RETURNS NVARCHAR(MAX /*NQC*/)
AS
BEGIN
    RETURN (   SELECT   STRING_AGG(C.name, ',')
                 FROM   sys.columns AS C
                WHERE   C.object_id = OBJECT_ID(@SchemaName + '.' + @TableName));
END;
GO
PRINT N'Creating [DatabaseVersioning].[Setting]'
GO
CREATE TABLE [DatabaseVersioning].[Setting]
(
[Id] [int] NOT NULL,
[GetDataRowCount] [int] NOT NULL CONSTRAINT [DF_Setting_IsFeatureEnabled] DEFAULT ((1000)),
[MirroringIsEnabled] [bit] NOT NULL CONSTRAINT [DF_Setting_MirroringIsEnabled] DEFAULT ((0))
)
GO
PRINT N'Creating primary key [PK_Setting_1] on [DatabaseVersioning].[Setting]'
GO
ALTER TABLE [DatabaseVersioning].[Setting] ADD CONSTRAINT [PK_Setting_1] PRIMARY KEY CLUSTERED  ([Id])
GO
PRINT N'Creating [DatabaseVersioning].[Setting_GetProps]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Setting_GetProps]
    @GetDataRowCount INT = NULL OUT, @MirroringIsEnabled INT = NULL OUT
AS
BEGIN
    SELECT --
        @GetDataRowCount = GetDataRowCount, --
        @MirroringIsEnabled = ISNULL(MirroringIsEnabled, 10000)
      FROM  DatabaseVersioning.Setting;
END;
GO
PRINT N'Creating [DatabaseVersioning].[Table_GetTransactionalData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetTransactionalData]
    @SchemaName TSTRING = NULL, @TableName TSTRING, @EndTime DATETIME, @CreatedStartTime DATETIME, @ResultItems TJSON = NULL OUTPUT
AS
BEGIN
    -- Provisiong parameters
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;
	DECLARE @MaxRecords INT;
	DECLARE @Columns TSTRING;

    SET @SchemaName = ISNULL(@SchemaName, 'dbo');

	-- Get maxrecord
	DECLARE @GetDataRowCount INT, @MirroringIsEnabled INT;
	EXEC DatabaseVersioning.Setting_GetProps @GetDataRowCount = @GetDataRowCount OUTPUT, @MirroringIsEnabled = @MirroringIsEnabled OUTPUT
	SET @MaxRecords =  @GetDataRowCount

	-- Get Columns
	SET @Columns = (SELECT DatabaseVersioning.Table_Columns(@SchemaName,@TableName))

    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- TableName must be exists
    IF NOT EXISTS (SELECT TOP 1 1 FROM  sys.tables WHERE name = @TableName) --
        EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName,
            @Message = 'TableName does not exists in tables list';

    -- Table must have Transactional attribute in TemporalType extended property
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dsp.SystemTable TLBOTT
                       WHERE TLBOTT.SchemaName = @SchemaName AND TLBOTT.TableName = @TableName AND
                             ISNULL(TLBOTT.TemporalTypeId, 0) = dspconst.TemporalType_Transactional())
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table has not Transactional TemporalType attribute,TableName is {0}.{1}',
            @Param0 = @SchemaName, @Param1 = @TableName;

	    -- Get data by parameters
    SET @Query =
        CONCAT(
            '
	SET @Result = (SELECT Top (',@MaxRecords,  ' )' ,@Columns,   ' FROM ', @SchemaName, '.', @TableName, ' WHERE CreatedTime > ', '''', CONVERT(VARCHAR, @CreatedStartTime, 121), '''',
            ' AND CreatedTime <= ', '''', CONVERT(VARCHAR, @EndTime, 121), '''', '
	FOR JSON AUTO,INCLUDE_NULL_VALUES)
	');
    SET @Params = '@Result NVARCHAR(MAX) OUTPUT';
	EXEC sys.sp_executesql @Query, @Params, @Result = @ResultItems OUTPUT;
END;








GO
PRINT N'Creating [dspconst].[ReferenceTime]'
GO

create FUNCTION [dspconst].[ReferenceTime] ()
RETURNS DATETIME
WITH SCHEMABINDING
AS
BEGIN
	DECLARE @ReferenceTime DATETIME = '1753-01-01';
	RETURN @ReferenceTime;
END;


GO
PRINT N'Creating [dsp].[DateTime_ConvertLocalToUTC]'
GO
CREATE   FUNCTION [dsp].[DateTime_ConvertLocalToUTC] (@LocalDate DATETIME)
RETURNS DATETIME2
WITH SCHEMABINDING
AS
BEGIN

    RETURN DATEADD(MINUTE, -DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), @LocalDate);

END;
GO
PRINT N'Creating [DatabaseVersioning].[Table_GetTemporalData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetTemporalData]
    @SchemaName TSTRING, @TableName TSTRING, @CreatedStartTime DATETIME2, @EndTime DATETIME2, @MainJsonResult TJSON = NULL OUTPUT,
    @HistoryJsonResult TJSON = NULL OUTPUT
AS
BEGIN
    DECLARE @MainQuery TSTRING;
    DECLARE @HistoryQuery TSTRING;
    DECLARE @Params TSTRING;
    DECLARE @Params1 TSTRING;
	DECLARE @MaxRecords INT;
	DECLARE @Columns TSTRING;

	-- Get maxrecord
	DECLARE @GetDataRowCount INT, @MirroringIsEnabled INT;
	EXEC DatabaseVersioning.Setting_GetProps @GetDataRowCount = @GetDataRowCount OUTPUT, @MirroringIsEnabled = @MirroringIsEnabled OUTPUT
	SET @MaxRecords =  @GetDataRowCount

	-- Get Columns
	SET @Columns = (SELECT DatabaseVersioning.Table_Columns(@SchemaName,@TableName))

    SET @CreatedStartTime = ISNULL(dsp.DateTime_ConvertLocalToUTC(@CreatedStartTime), dspconst.ReferenceTime());
    SET @EndTime = ISNULL(dsp.DateTime_ConvertLocalToUTC(@EndTime), GETDATE());

    -- Validate SchemaName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'SchemaName', @ArgumentValue = @SchemaName,
    @Message = 'SchemaName could not be allow null';

    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- Get TemporalTypeId attribute
    DECLARE @TemporalTypeId TSTRING;
    SELECT  @TemporalTypeId = TemporalTypeId
      FROM  dsp.SystemTable
     WHERE  SchemaName = @SchemaName AND TableName = @TableName;

    -- Validate ExtendedPropertyKey 
    IF (ISNULL(@TemporalTypeId, 0) <> dspconst.TemporalType_Temporal()) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table has not TemporalTypeId extended property with Temporal value';

    -- Set Main json for result 
    SET @MainQuery =
        CONCAT(
            '
  SET @Result = (SELECT  Top (  ',@MaxRecords, ')' ,@Columns,' FROM  ', @SchemaName, '.', @TableName, ' M ', --

            ' WHERE (M.VersioningStartTime > ', '''', CONVERT(VARCHAR, @CreatedStartTime, 121) + '''', 'AND  M.VersioningStartTime <=',
            '''' + CONVERT(VARCHAR, @EndTime, 121), ''')', ' FOR JSON AUTO ,INCLUDE_NULL_VALUES)');

    SET @Params = '@Result NVARCHAR(MAX) OUTPUT';
    EXEC sys.sp_executesql @MainQuery, @Params, @Result = @MainJsonResult OUTPUT;
	
    -- Set History json for result
    SET @HistoryQuery =
        CONCAT(
            ' SET @Result = (SELECT  Top ( ' ,@MaxRecords, ')',@Columns,' FROM  ' , @SchemaName, '.', @TableName, 'History H', --

            ' WHERE ( H.VersioningEndTime > ', '''', CONVERT(VARCHAR, @CreatedStartTime, 121) + '''', 'AND  H.VersioningEndTime <=',
            '''' + CONVERT(VARCHAR, @EndTime, 121), '''', ')
             FOR JSON AUTO ,INCLUDE_NULL_VALUES)');

    SET @Params1 = '@Result NVARCHAR(MAX) OUTPUT';
    EXEC sys.sp_executesql @HistoryQuery, @Params1, @Result = @HistoryJsonResult OUTPUT;

END;



GO
PRINT N'Creating [dspconst].[TemporalType_Ordinary]'
GO
CREATE   FUNCTION [dspconst].[TemporalType_Ordinary] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;




GO
PRINT N'Creating [DatabaseVersioning].[Table_GetOrdinaryData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetOrdinaryData]
    @SchemaName TSTRING = NULL, @TableName TSTRING = NULL, @CreatedStartTime DATETIME, @ModifiedStartTime DATETIME, @EndTime DATETIME,
    @ResultItems TSTRING = NULL OUTPUT
AS
BEGIN
    -- Provisiong parameters
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;
	DECLARE @MaxRecords INT;
	DECLARE @Columns TSTRING;
	
    SET @SchemaName = ISNULL(@SchemaName, 'dbo');
	-- Get maxrecord
	DECLARE @GetDataRowCount INT, @MirroringIsEnabled INT;
	EXEC DatabaseVersioning.Setting_GetProps @GetDataRowCount = @GetDataRowCount OUTPUT, @MirroringIsEnabled = @MirroringIsEnabled OUTPUT
	SET @MaxRecords =  @GetDataRowCount
	-- Get columns
	SET @Columns = (SELECT DatabaseVersioning.Table_Columns(@SchemaName,@TableName))


    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- TableName must be exists
    IF NOT EXISTS (SELECT TOP 1 1 FROM  sys.tables WHERE name = @TableName) --
        EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName,
            @Message = 'TableName does not exists in tables list';

    -- Table must have Ordinary attribute in TemporalType extended property
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dsp.SystemTable TLBOTT
                       WHERE TLBOTT.SchemaName = @SchemaName AND TLBOTT.TableName = @TableName AND
                             ISNULL(TLBOTT.TemporalTypeId, 0) = dspconst.TemporalType_Ordinary())
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table has not Ordinary TemporalType attribute,TableName is {0}.{1}',
            @Param0 = @SchemaName, @Param1 = @TableName;

    -- Get data by parameters
    SET @Query =
        CONCAT(
            '
	SET @Result = (SELECT Top (',@MaxRecords,') ' ,@Columns, ' FROM  '                        , @SchemaName, '.', @TableName, --
            ' WHERE (CreatedTime > ''', CONVERT(VARCHAR, @CreatedStartTime, 121), ''' AND CreatedTime <= ', '''', CONVERT(VARCHAR, @EndTime, 121), ''')',
            ' OR ', --
            '(ModifiedTime IS NOT NULL AND ModifiedTime > ''', CONVERT(VARCHAR, @ModifiedStartTime, 121), ''' AND ModifiedTime <= ', '''',
            CONVERT(VARCHAR, @EndTime, 121), ''')', ' FOR JSON AUTO,INCLUDE_NULL_VALUES)
	');
    SET @Params = '@Result NVARCHAR(MAX) OUTPUT';
	SELECT @Query
    EXEC sys.sp_executesql @Query, @Params, @Result = @ResultItems OUTPUT;

END;








GO
PRINT N'Creating [DatabaseVersioning].[Table_GetMaxTimeValue]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetMaxTimeValue]
    @SchemaName TSTRING, @TableName TSTRING, @TemporalTypeIdValue INT, @MaxCreatedTime DATETIME = NULL OUTPUT, @MaxModifiedTime DATETIME = NULL OUTPUT
AS
BEGIN
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;

    SET @MaxCreatedTime = NULL;
    SET @MaxModifiedTime = NULL;

    -- Get max value of CreateTime and ModifiedTime for ordinary table
    IF @TemporalTypeIdValue = /*dspconst.TemporalType_Ordinary()*/ 1
    BEGIN
        SET @Query = CONCAT('
				SELECT @MaxCreatedTime = MAX(CreatedTime), @MaxModifiedTime = MAX(ModifiedTime)
				FROM ', @SchemaName, '.' + @TableName);
        SET @Params = '@MaxCreatedTime DATETIME OUTPUT, @MaxModifiedTime DATETIME OUTPUT';
        EXEC sys.sp_executesql @stmt = @Query, @params = @Params, @MaxCreatedTime = @MaxCreatedTime OUTPUT, @MaxModifiedTime = @MaxModifiedTime OUTPUT;
    END;

    -- Get max value of VersioningStartTime and ModifiedTime for temporal table
    IF @TemporalTypeIdValue = /*dspconst.TemporalType_Temporal()*/ 2
    BEGIN
        SET @Query = CONCAT('
				SELECT @MaxCreatedTime = MAX(VersioningStartTime)
				FROM ', @SchemaName, '.' + @TableName);
        SET @Params = '@MaxCreatedTime DATETIME OUTPUT';
        EXEC sys.sp_executesql @stmt = @Query, @params = @Params, @MaxCreatedTime = @MaxCreatedTime OUTPUT;
    END;

    -- Get max value of CreatedTime and ModifiedTime for transactional table
    IF @TemporalTypeIdValue = /*dspconst.TemporalType_Transactional()*/ 3
    BEGIN
        SET @Query = CONCAT('
				SELECT @MaxCreatedTime = MAX(CreatedTime)
				FROM ', @SchemaName, '.' + @TableName);
        SET @Params = '@MaxCreatedTime DATETIME OUTPUT';
        EXEC sys.sp_executesql @stmt = @Query, @params = @Params, @MaxCreatedTime = @MaxCreatedTime OUTPUT;
    END;
END;

GO
PRINT N'Creating [DatabaseVersioning].[Table_GetLookupData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetLookupData]
    @SchemaName TSTRING = NULL, @TableName TSTRING = NULL, @ResultItems TSTRING = NULL OUTPUT
AS
BEGIN

    -- Provisiong parameters
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;
	DECLARE @Columns TSTRING; 
    SET @SchemaName = ISNULL(@SchemaName, 'dbo');
	-- Get columns
	SET @Columns = (SELECT DatabaseVersioning.Table_Columns(@SchemaName,@TableName))

    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- TableName must be exists
    IF NOT EXISTS (SELECT TOP 1 1 FROM  sys.tables WHERE name = @TableName) --
        EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName,
            @Message = 'TableName does not exists in tables list';

    -- Table must have Lookup attribute in TemporalType extended property
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dsp.SystemTable ST
                       WHERE ST.SchemaName = @SchemaName AND ST.TableName = @TableName AND  ISNULL(ST.TemporalTypeId, 0) = dspconst.TemporalType_Lookup())
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table has not Lookup TemporalType attribute,TableName is {0}.{1}',
            @Param0 = @SchemaName, @Param1 = @TableName;

    -- Get data by parameters
    SET @Query = CONCAT('
	SET @Result = (SELECT' ,@Columns,    ' FROM ', @SchemaName, '.', @TableName, '
	FOR JSON AUTO,INCLUDE_NULL_VALUES)
	');
    SET @Params = '@Result NVARCHAR(MAX) OUTPUT';

    EXEC sys.sp_executesql @Query, @Params, @Result = @ResultItems OUTPUT;

END;








GO
PRINT N'Creating [DatabaseVersioning].[Table_GetData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_GetData]
    @SnapshotTime DATETIME, @SchemaName TSTRING, @TableName TSTRING, @TemporalTypeIdValue INT, @MainItemJson TJSON OUTPUT, @HistoryItemJson TJSON = NULL OUTPUT
AS
BEGIN
    SET @MainItemJson = NULL;
    SET @HistoryItemJson = NULL;
    DECLARE @MaxCreatedTime DATETIME;
    DECLARE @MaxModifiedTime DATETIME;

    -- Get max data
    EXEC DatabaseVersioning.Table_GetMaxTimeValue @SchemaName = @SchemaName, @TableName = @TableName, @TemporalTypeIdValue = @TemporalTypeIdValue,
        @MaxCreatedTime = @MaxCreatedTime OUTPUT, @MaxModifiedTime = @MaxModifiedTime OUTPUT;

    -- Get Ordinary Data
    IF (@TemporalTypeIdValue = /*dspconst.TemporalType_Ordinary()*/ 1)
        EXEC DatabaseVersioning.Table_GetOrdinaryData @SchemaName = @SchemaName, @TableName = @TableName, @EndTime = @SnapshotTime,
            @CreatedStartTime = @MaxCreatedTime, @ModifiedStartTime = @MaxModifiedTime, @ResultItems = @MainItemJson OUTPUT;

    -- Get Transactional Data
    IF (@TemporalTypeIdValue = /*dspconst.TemporalType_Transactional()*/ 3)
        EXEC DatabaseVersioning.Table_GetTransactionalData @SchemaName = @SchemaName, @TableName = @TableName, @EndTime = @SnapshotTime,
            @CreatedStartTime = @MaxCreatedTime, @ResultItems = @MainItemJson OUTPUT;

    --Get Temporal Data
    IF (@TemporalTypeIdValue = /*dspconst.TemporalType_Temporal()*/ 2)
        DECLARE @MainJsonResult TJSON, @HistoryJsonResult TJSON;
    EXEC DatabaseVersioning.Table_GetTemporalData @SchemaName = @SchemaName, @TableName = @TableName, @CreatedStartTime = @MaxCreatedTime,
        @EndTime = @SnapshotTime, @MainJsonResult = @MainItemJson OUTPUT, @HistoryJsonResult = @HistoryItemJson OUTPUT;

    --Get Lookup Data
	IF(@TemporalTypeIdValue = /*[dspconst].[TemporalType_Lookup]*/4)
	DECLARE @ResultItems TSTRING;
	EXEC DatabaseVersioning.Table_GetLookupData @SchemaName = @SchemaName, @TableName = @TableName, @ResultItems = @ResultItems OUTPUT

END;
GO
PRINT N'Creating [DatabaseVersioning].[Table_SyncAllData]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Table_SyncAllData]
    @SnapshotTime DATETIME
AS
BEGIN
    DECLARE @MaxRecords INT;
    DECLARE @Counter INT;
    SET @SnapshotTime = ISNULL(@SnapshotTime, GETDATE());

    -- Get maxrecord
    EXEC DatabaseVersioning.Setting_GetProps @GetDataRowCount = @MaxRecords OUTPUT;

    -- Provisiong table in order to call engine
    DECLARE _Cursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  SchemaName, TableName, LevelPriority, TemporalTypeId
      FROM  dsp.SystemTable
     ORDER BY LevelPriority;

    OPEN _Cursor;

    DECLARE @SchemaName TSTRING;
    DECLARE @TableName TSTRING;
    DECLARE @LevelPriority TSTRING;
    DECLARE @TemporalTypeId INT;
    DECLARE @MainItemJson TJSON;
    DECLARE @HistoryItemJson TJSON;
    DECLARE @MainTableRecordCount INT;
    DECLARE @HistoryTableRecordCount INT;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM _Cursor
         INTO @SchemaName, @TableName, @LevelPriority, @TemporalTypeId;

        IF (@@FETCH_STATUS <> 0)
            BREAK;

        SET @Counter = @MaxRecords;
        WHILE (@Counter = @MaxRecords)
        BEGIN
            -- Get data from source
            EXEC DatabaseVersioning.Table_GetData @SnapshotTime = @SnapshotTime, @SchemaName = @SchemaName, @TableName = @TableName,
                @TemporalTypeIdValue = @TemporalTypeId, @MainItemJson = @MainItemJson OUTPUT, @HistoryItemJson = @HistoryItemJson OUTPUT;

            -- Set counter
            SET @MainTableRecordCount = (SELECT COUNT(*) FROM   OPENJSON(@MainItemJson));
            SET @HistoryTableRecordCount = (SELECT  COUNT(*) FROM   OPENJSON(@HistoryItemJson));
            SET @Counter = IIF(@MainTableRecordCount > @HistoryTableRecordCount, @MainTableRecordCount, @HistoryTableRecordCount);

            -- Insert Data
            EXEC DatabaseVersioning.Table_SyncData @SchemaName = @SchemaName, @TableName = @TableName, @TemporalTypeIdValue = @TemporalTypeId,
                @MainItemJson = @MainItemJson, @HistoryItemJson = @HistoryItemJson;
        END;
    END;
    CLOSE _Cursor;
    DEALLOCATE _Cursor;

END;

GO
PRINT N'Creating [dsperr].[ArgumentsAreNotSameId]'
GO

CREATE FUNCTION [dsperr].[ArgumentsAreNotSameId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55027;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowArgumentsAreNotSame]'
GO

CREATE PROCEDURE [dsperr].[ThrowArgumentsAreNotSame] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.ArgumentsAreNotSameId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Json_Compare]'
GO
CREATE PROCEDURE [dsp].[Json_Compare]
    @Json1 TJSON, @Json2 TJSON, @TwoSided BIT = NULL, @IncludeValue BIT = NULL, @IsThrow BIT = NULL, @CaseSencitive BIT = NULL,
    @ExceptionMessage TSTRING = NULL, @AreSame BIT = NULL OUTPUT
AS
BEGIN
    -- Call funtion
    SET @TwoSided = ISNULL(@TwoSided, 0);
    SET @IncludeValue = ISNULL(@IncludeValue, 0);
    SET @IsThrow = ISNULL(@IsThrow, 1);
    SET @CaseSencitive = ISNULL(@CaseSencitive, 0);

    SET @AreSame = 1;

    IF (@CaseSencitive = 0) --
    BEGIN
        SET @Json1 = LOWER(@Json1);
        SET @Json2 = LOWER(@Json2);
    END;

    IF (ISNULL(ISJSON(@Json1), 0) <> 1) -- 
        SET @AreSame = 0;

    IF (ISNULL(ISJSON(@Json2), 0) <> 1) -- 
        SET @AreSame = 0;

	-- SQL Prompt Formatting Off
	-- Compare Json2 with Json1
	IF @AreSame = 1
	AND EXISTS (SELECT		TOP 1
							1
				FROM		dsp.Json_ReadNested( '$', @Json2 ) AS JR2
				LEFT JOIN	dsp.Json_ReadNested( '$', @Json1 ) AS JR1 ON JR1.JKey = JR2.JKey
																		AND JR1.JPath = JR2.JPath
																		AND (	@IncludeValue = 0
																				OR (@IncludeValue = 1 AND ISNULL(JR1.JValue, '-1') = ISNULL(JR2.JValue ,'-1'))
																			)
				WHERE		JR1.JKey IS NULL
							AND (@IncludeValue = 1 OR (@IncludeValue = 0 AND ISNUMERIC ( JR2.JKey ) <> 1 AND ISNUMERIC ( JR1.JKey ) <> 1))
			)
		SET @AreSame = 0;

	-- Compare Json1 with Json2
	IF @TwoSided = 1
	AND @AreSame = 1
	AND EXISTS (SELECT		TOP 1
							1
				FROM		dsp.Json_ReadNested( '$', @Json1 ) AS JR1
				LEFT JOIN	dsp.Json_ReadNested( '$', @Json2 ) AS JR2 ON JR2.JKey = JR1.JKey
																		AND JR2.JPath = JR1.JPath
																		AND (	@IncludeValue = 0
																				OR (@IncludeValue = 1 AND ISNULL(JR2.JValue, '-1') = ISNULL(JR1.JValue ,'-1'))
																			)
				WHERE		JR2.JKey IS NULL
							AND (@IncludeValue = 1 OR (@IncludeValue = 0 AND ISNUMERIC ( JR1.JKey ) <> 1 AND ISNUMERIC ( JR2.JKey ) <> 1))
			)
		SET @AreSame = 0;

	-- SQL Prompt formatting on

    IF (@AreSame = 0 AND @IsThrow = 1) --
        EXEC dsperr.ThrowArgumentsAreNotSame @ProcId = @@PROCID, @Message = @ExceptionMessage;
END;


GO
PRINT N'Creating [dsp].[vw_SystemTable]'
GO
CREATE VIEW [dsp].[vw_SystemTable]
AS
SELECT  T.name TableName, T.object_id, T.principal_id, T.schema_id, T.parent_object_id, T.type, T.type_desc, T.create_date, T.modify_date, T.is_ms_shipped,
    T.is_published, T.is_schema_published, T.lob_data_space_id, T.filestream_data_space_id, T.max_column_id_used, T.lock_on_bulk_load, T.uses_ansi_nulls,
    T.is_replicated, T.has_replication_filter, T.is_merge_published, T.is_sync_tran_subscribed, T.has_unchecked_assembly_data, T.text_in_row_limit,
    T.large_value_types_out_of_row, T.is_tracked_by_cdc, T.lock_escalation, T.lock_escalation_desc, T.is_filetable, T.is_memory_optimized, T.durability,
    T.durability_desc, T.temporal_type, T.temporal_type_desc, T.history_table_id, T.is_remote_data_archive_enabled, T.is_external, T.history_retention_period,
    T.history_retention_period_unit, T.history_retention_period_unit_desc, T.is_node, T.is_edge, S.name SchemaName, ST.TemporalTypeId, ST.LevelPriority
  FROM  dsp.SystemTable AS ST
        INNER JOIN sys.tables T ON T.object_id = OBJECT_ID(ST.SchemaName + '.' + ST.TableName)
        INNER JOIN sys.schemas S ON S.schema_id = T.schema_id;
GO
PRINT N'Creating [dsp].[Database_Tables]'
GO
CREATE PROCEDURE [dsp].[Database_Tables]
    @SchemaName TSTRING = NULL, @TableName TSTRING = NULL, @TablesJsonResult TJSON = NULL OUTPUT
AS
BEGIN
    -- Set json fro result
    SET @TablesJsonResult =
    (   SELECT  ST.object_id AS TableId,ST.TableName, ST.SchemaName, --
            JSON_QUERY(dsp.Table_GetParamsJson(ST.object_id)) AS Params,--
			ST.TemporalTypeId, ST.LevelPriority
			--JSON_QUERY(dsp.Table_ExtendedProperty(ST.object_id)) AS ExtendedProperties
          FROM  dsp.vw_SystemTable AS ST
         WHERE  ST.SchemaName <> 'tSQLt' --
            AND (@SchemaName IS NULL OR ST.SchemaName = @SchemaName) --
            AND (@TableName IS NULL OR  ST.TableName = @TableName)
        FOR JSON AUTO);
END;
GO
PRINT N'Creating [DatabaseVersioning].[Database_CompareTablesStructure]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Database_CompareTablesStructure]
    @TablesJsonResult TJSON = NULL OUTPUT
AS
BEGIN
    -- Get Destination structure
    DECLARE @SourceTablesJsonResult TJSON;
    EXEC dsp.Database_Tables @TablesJsonResult = @TablesJsonResult OUTPUT;

    -- Get Source structure
    EXEC syn.Database_Tables @TablesJsonResult = @SourceTablesJsonResult OUTPUT;

    EXEC dsp.Json_Compare @Json1 = @TablesJsonResult, @Json2 = @SourceTablesJsonResult, @TwoSided = 1, @IncludeValue = 1, @IsThrow = 1, @CaseSencitive = 1;
END;
GO
PRINT N'Creating [dsp].[DatabaseVersioning_Refresh]'
GO
CREATE PROCEDURE [dsp].[DatabaseVersioning_Refresh]
    @SnapshotTime DATETIME = NULL
AS
BEGIN

    -- Check MirroringIsEnabled
    DECLARE @MirroringIsEnabled INT;
    EXEC DatabaseVersioning.Setting_GetProps @MirroringIsEnabled = @MirroringIsEnabled OUTPUT;
    IF @MirroringIsEnabled = 0
        RETURN;

    -- Satisfied source and destionatin structure
    DECLARE @TablesJsonResult TJSON;
    EXEC DatabaseVersioning.Database_CompareTablesStructure @TablesJsonResult = @TablesJsonResult OUTPUT;

    -- Call sync engine
    EXEC DatabaseVersioning.Table_SyncAllData @SnapshotTime = @SnapshotTime;

END;

GO
PRINT N'Creating [tSQLt].[Private_RunAll]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunAll]
  @TestResultFormatter NVARCHAR(MAX)
AS
BEGIN
  EXEC tSQLt.Private_RunCursor @TestResultFormatter = @TestResultFormatter, @GetCursorCallback = 'tSQLt.Private_GetCursorForRunAll';
END;
GO
PRINT N'Creating [SQLCop].[test Columns with image data type]'
GO
CREATE PROCEDURE [SQLCop].[test Columns with image data type]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/don-t-use-text-datatype-for-sql-2005-and
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT  @Output = @Output + SCHEMA_NAME(o.uid) + '.' + o.Name + '.' + col.name
	from    syscolumns col         
			Inner Join sysobjects o
				On col.id = o.id         
			inner join systypes           
	 			On col.xtype = systypes.xtype 
	Where   o.type = 'U'         
			And ObjectProperty(o.id, N'IsMSShipped') = 0         
			And systypes.name In ('image') 
			And SCHEMA_NAME(o.uid) <> 'tSQLt'
	Order By SCHEMA_NAME(o.uid),o.Name, col.Name
			
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/don-t-use-text-datatype-for-sql-2005-and' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	    
END;
GO
PRINT N'Creating [dsperr].[UnHandledExceptionId]'
GO

CREATE FUNCTION [dsperr].[UnHandledExceptionId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55028;  
END
			
GO
PRINT N'Creating [dsp].[Exception_ThrowWithCommonFormat]'
GO

CREATE PROCEDURE [dsp].[Exception_ThrowWithCommonFormat]
    @ProcId INT, @ErrorMessage TJSON
AS
BEGIN
    -- Get exception from json
    DECLARE @Exception TJSON;
    DECLARE @ExceptionId INT = IIF(ISJSON(@ErrorMessage) = 1, JSON_VALUE(@ErrorMessage, '$.errorId'), NULL);

    IF (@ExceptionId IS NOT NULL)
        SET @Exception = @ErrorMessage;
    ELSE
        SET @Exception = dsp.Exception_BuildMessageParam4(@ProcId, dsperr.UnHandledExceptionId(), @ErrorMessage, DEFAULT, DEFAULT, DEFAULT, DEFAULT);

    EXEC dsp.ThrowException @Exception = @Exception;
END;

GO
PRINT N'Creating [dspconst].[MessagePatternStepType_Confirm]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_Confirm] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 5;
END;
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_HasCustomConfirmValidation]'
GO

CREATE FUNCTION [dspInboxMessage].[MessagePatternStep_HasCustomConfirmValidation] (@MessagePatternId INT)
RETURNS BIT
WITH SCHEMABINDING
AS
BEGIN
    IF EXISTS (   SELECT    1
                    FROM    dspInboxMessage.MessagePatternStep
                   WHERE MessagePatternId = @MessagePatternId --
                      AND   MessagePatternStepTypeId = dspconst.MessagePatternStepType_Confirm() --
                      AND   ConfirmHasCustomValidation = 1)
        RETURN (1);
    ELSE
        RETURN (0);

    RETURN (0);
END;

GO
PRINT N'Creating [tSQLt].[Private_RunMethodHandler]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunMethodHandler]
  @RunMethod NVARCHAR(MAX),
  @TestResultFormatter NVARCHAR(MAX) = NULL,
  @TestName NVARCHAR(MAX) = NULL
AS
BEGIN
  SELECT @TestResultFormatter = ISNULL(@TestResultFormatter,tSQLt.GetTestResultFormatter());

  EXEC tSQLt.Private_Init;
  IF(@@ERROR = 0)
  BEGIN  
    IF(EXISTS(SELECT * FROM sys.parameters AS P WHERE P.object_id = OBJECT_ID(@RunMethod) AND name = '@TestName'))
    BEGIN
      EXEC @RunMethod @TestName = @TestName, @TestResultFormatter = @TestResultFormatter;
    END;
    ELSE
    BEGIN  
      EXEC @RunMethod @TestResultFormatter = @TestResultFormatter;
    END;
  END;
END;
GO
PRINT N'Creating [SQLCop].[test Compatibility Level]'
GO
CREATE PROCEDURE [SQLCop].[test Compatibility Level]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Database_compatibilty_level
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

	Select @Output = @Output + Name + Char(13) + Char(10)
	FROM   master.dbo.sysdatabases
	WHERE  cmptlevel != 10 * CONVERT(Int, CONVERT(FLOAT, CONVERT(VARCHAR(3), SERVERPROPERTY('productversion'))))

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Database_compatibilty_level'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
  
END;
GO
PRINT N'Creating [dsp].[Init_$IncreaseAppVersion]'
GO
CREATE PROCEDURE [dsp].[Init_$IncreaseAppVersion]
    @AppVersionId INT = NULL OUT
AS
BEGIN

    -- Get max version number
    DECLARE @MaxVersionNumber INT;
    SELECT  TOP 1 @MaxVersionNumber = AV.VersionNumber
      FROM  dsp.AppVersion AS AV
     ORDER BY AV.AppVersionId DESC;

    SET @MaxVersionNumber = ISNULL(@MaxVersionNumber, 0);
    SET @MaxVersionNumber = @MaxVersionNumber + 1;

    -- Insert new app version into the table
    INSERT INTO dsp.AppVersion (VersionNumber)
    VALUES (@MaxVersionNumber);

    SET @AppVersionId = @@IDENTITY;
END;

GO
PRINT N'Creating [tSQLt].[Private_RunNew]'
GO
CREATE PROCEDURE [tSQLt].[Private_RunNew]
  @TestResultFormatter NVARCHAR(MAX)
AS
BEGIN
  EXEC tSQLt.Private_RunCursor @TestResultFormatter = @TestResultFormatter, @GetCursorCallback = 'tSQLt.Private_GetCursorForRunNew';
END;
GO
PRINT N'Creating [SQLCop].[test Database and Log files on the same disk]'
GO
CREATE PROCEDURE [SQLCop].[test Database and Log files on the same disk]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.brentozar.com/archive/2009/02/when-should-you-put-data-and-logs-on-the-same-drive/
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    Select @Output = @Output + db_name() + Char(13) + Char(10)
    FROM   sys.database_files
    Having Count(*) != Count(Distinct Left(Physical_Name, 3)) 
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.brentozar.com/archive/2009/02/when-should-you-put-data-and-logs-on-the-same-drive/'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_List]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_List] (@SchemaName TSTRING)
RETURNS TABLE
RETURN SELECT --
            P.object_id StoredProcedureId, --
           JSON_VALUE(SPM.Metadata, '$.ApiKey') StoredProcedureKey, --
           CONVERT(DATETIME, JSON_VALUE(SPM.Metadata, '$.CreatedTime')) CreatedTime, --
           SCHEMA_NAME(P.schema_id) AS StoredProcedureSchemaName, --
           P.name AS StoredProcedureName, --
           OBJECT_DEFINITION(P.object_id) AS StoredProcedureDefinitionCode, --
           SPM.Metadata StoredProcedureMetadata --
         FROM   sys.procedures AS P
                OUTER APPLY dsp.StoredProcedure_Metadata(SCHEMA_NAME(P.schema_id), P.name) AS SPM
        WHERE   P.type <> 'PC' --
           AND  (@SchemaName IS NULL OR P.schema_id = SCHEMA_ID(@SchemaName));









GO
PRINT N'Creating [dsp].[Setting_VersioningSchemaName]'
GO
CREATE FUNCTION [dsp].[Setting_VersioningSchemaName] ()
RETURNS TSTRING
AS
BEGIN
    DECLARE @VersioningSchemaName TSTRING = 'api';

    RETURN @VersioningSchemaName;
END;
GO
PRINT N'Creating [dsp].[Init_NewAppVersion]'
GO
CREATE PROCEDURE [dsp].[Init_NewAppVersion]
    @AppVersionId INT = NULL OUT
AS
BEGIN
    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;
    BEGIN TRY

        -- Increase the application version
        EXEC dsp.[Init_$IncreaseAppVersion] @AppVersionId = @AppVersionId OUT;

        -- Get the schema name
        DECLARE @SchemaName TSTRING = dsp.Setting_VersioningSchemaName();

        -- Insert all the procedures with the API schema name to the AppVersionDetail table 
        INSERT INTO dsp.AppVersionDetail (AppVersionId, StoredProcedureId, StoredProcedureName, StoredProcedurePhysicalName, SchemaName,
            StoredProcedureVersionNumber, ExpirationTime, CreatedTime)
        SELECT  @AppVersionId, --
            SPM.StoredProcedureId, --
            ISNULL(JSON_VALUE(SPM.StoredProcedureMetadata, '$.StoredProcedureName'), SPM.StoredProcedureName), --
            SPM.StoredProcedureName, --
            SPM.StoredProcedureSchemaName, --
            SPVN.VersionNumber, NULL, --
            GETDATE()
          FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
                OUTER APPLY dsp.StoredProcedure_VersionNumber(StoredProcedureName) AS SPVN
         ORDER BY SPVN.VersionNumber;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH;

END;


GO
PRINT N'Creating [tSQLt].[Private_SetConfiguration]'
GO
CREATE PROCEDURE [tSQLt].[Private_SetConfiguration]
  @Name NVARCHAR(100),
  @Value SQL_VARIANT
AS
BEGIN
  IF(EXISTS(SELECT 1 FROM tSQLt.Private_Configurations WITH(ROWLOCK,UPDLOCK) WHERE Name = @Name))
  BEGIN
    UPDATE tSQLt.Private_Configurations SET
           Value = @Value
     WHERE Name = @Name;
  END;
  ELSE
  BEGIN
     INSERT tSQLt.Private_Configurations(Name,Value)
     VALUES(@Name,@Value);
  END;
END;
GO
PRINT N'Creating [SQLCop].[test Database collation]'
GO
CREATE PROCEDURE [SQLCop].[test Database collation]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/collation-conflicts-with-temp-tables-and
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    Select  @Output = @Output + 'Warning: Collation conflict between user database and TempDB' + Char(13) + Char(10)
    Where   DatabasePropertyEx('TempDB', 'Collation') <> DatabasePropertyEx(db_name(), 'Collation')
        
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/collation-conflicts-with-temp-tables-and'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsp].[Table_ValidateExistance]'
GO
CREATE PROCEDURE [dsp].[Table_ValidateExistance]
    @SchemaName TSTRING, @TableName TSTRING
AS
BEGIN
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    sys.tables t
                                INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
                       WHERE s.name = @SchemaName AND   t.name = @TableName)
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = 'Table {0}.{1}', @Param0 = @SchemaName, @Param1 = @TableName;
END;


GO
PRINT N'Creating [dsp].[Table_EnableTemporalAttribute]'
GO
CREATE PROCEDURE [dsp].[Table_EnableTemporalAttribute]
    @SchemaName TSTRING, @TableName TSTRING
AS
BEGIN
    SET NOCOUNT ON;

    SET @SchemaName = ISNULL(@SchemaName, 'dbo');

    -- Vaidate for existance
    EXEC dsp.Table_ValidateExistance @SchemaName = @SchemaName, @TableName = @TableName;

    -- Check if Temporal Table Exisits
    IF EXISTS (   SELECT    *
                    FROM    sys.tables
                   WHERE name = @TableName AND  temporal_type = 2)
        RETURN;

    -- Check PERIOD FOR SYSTEM_TIME 
    DECLARE @Query TSTRING;
    -- 
    IF EXISTS (   SELECT    1
                    FROM    sys.columns
                   WHERE (name = N'VersioningStartTime' OR  name = N'VersioningEndTime') AND object_id = OBJECT_ID(@SchemaName + '.' + @TableName))
    BEGIN
        SET @Query = 'ALTER TABLE ' + @SchemaName + '.' + @TableName + ' ADD PERIOD FOR SYSTEM_TIME(VersioningStartTime, VersioningEndTime)';
        EXEC (@Query);
    END;

    -- check for exists version columns
    SET @Query = NULL;
    IF NOT EXISTS (   SELECT    *
                        FROM    sys.columns
                       WHERE (name = N'VersioningStartTime' OR  name = N'VersioningEndTime') AND object_id = OBJECT_ID(@SchemaName + '.' + @TableName))
    BEGIN
        SET @Query =
            'ALTER TABLE ' + @SchemaName + '.' + @TableName
            + ' Add  
							   VersioningStartTime DATETIME2 GENERATED ALWAYS AS ROW START HIDDEN DEFAULT GETUTCDATE(),
							   VersioningEndTime  DATETIME2 GENERATED ALWAYS AS ROW END   HIDDEN DEFAULT  CONVERT(DATETIME2, ''9999-12-31 23:59:59.9999999''),
							   PERIOD FOR SYSTEM_TIME (VersioningStartTime, VersioningEndTime) ';
        EXEC (@Query);

    END;

    -- Add HistoricalTable
    SET @Query = NULL;
    SET @Query =
        'ALTER TABLE ' + @SchemaName + '.' + @TableName + ' set  (SYSTEM_VERSIONING = ON (HISTORY_TABLE=' + @SchemaName + '.' + @TableName + 'History' + ')) ';
    EXEC (@Query);

END;
GO
PRINT N'Creating [dsp].[Table_DisableTemporalAttribute]'
GO
CREATE PROCEDURE [dsp].[Table_DisableTemporalAttribute]
    @SchemaName TSTRING = NULL, @TableName TSTRING = NULL
AS
BEGIN
    SET NOCOUNT ON;

    -- Vaidate for existance
    EXEC dsp.Table_ValidateExistance @SchemaName = @SchemaName, @TableName = @TableName;

    DECLARE @Column TSTRING;
    DECLARE @Sql TSTRING;
    DECLARE @Temporal_Type INT;
    DECLARE @Name TSTRING;

    -- Get list table name by input parameter
    DECLARE @Temp TABLE (TableName TSTRING);
    INSERT INTO @Temp (TableName)
    SELECT  s.name + '.' + t.name
      FROM  sys.tables t
            INNER JOIN sys.schemas s ON t.schema_id = s.schema_id
     WHERE  (@TableName IS NULL OR  t.name = @TableName) --
        AND t.temporal_type = 2;

    IF NOT EXISTS (SELECT TOP 1 1 FROM  @Temp)
        RETURN;

    DECLARE db_cursor CURSOR FOR --
    SELECT  TableName
      FROM  @Temp;

    OPEN db_cursor;
    FETCH NEXT FROM db_cursor
     INTO @Name;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- Disable the system versioning
        SET @Column = '(SYSTEM_VERSIONING = OFF)';
        SET @Sql = 'ALTER TABLE ' + @Name + ' set ' + @Column;
        EXEC (@Sql);
        SET @Sql = 'ALTER TABLE ' + @Name + ' DROP PERIOD FOR SYSTEM_TIME';
        EXEC (@Sql);


        FETCH NEXT FROM db_cursor
         INTO @Name;
    END;
    CLOSE db_cursor;
    DEALLOCATE db_cursor;
END;





GO
PRINT N'Creating [dsp].[Init_SystemTable]'
GO

CREATE PROCEDURE [dsp].[Init_SystemTable]
    @DoNotDisableTemporalForActiveTemporal BIT
AS
BEGIN
    DECLARE @Message TSTRING;

    DECLARE @MirroringIsEnabled INT;
    EXEC DatabaseVersioning.Setting_GetProps @MirroringIsEnabled = @MirroringIsEnabled OUTPUT;


    IF @MirroringIsEnabled = 1
    BEGIN
        -- Check LevelPriority existance for all tables
        SET @Message = NULL;
        SELECT  @Message = STRING_AGG(SchemaName + '.' + TableName, ', ')
          FROM  dsp.SystemTable
         WHERE  LevelPriority IS NULL;

        IF @Message IS NOT NULL
            EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Identify LevelPriority in SystemTables for these tables: {0}', @Param0 = @Message;

        -- Check TemporalType existance for all tables
        SET @Message = NULL;
        SELECT  @Message = STRING_AGG(SchemaName + '.' + TableName, ', ')
          FROM  dsp.SystemTable
         WHERE  TemporalTypeId IS NULL;

        IF @Message IS NOT NULL
            EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Identify TemporalType in SystemTables for these tables: {0}', @Param0 = @Message;

        -- Check ClusterColumnName existance for all tables
        SET @Message = NULL;
        SELECT  @Message = STRING_AGG(SchemaName + '.' + TableName, ', ')
          FROM  dsp.SystemTable
         WHERE  ClusterColumnsName IS NULL;

        IF @Message IS NOT NULL
            EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Identify cluster coilumn(s) for these tables: {0}', @Param0 = @Message;
    END;

    DECLARE _Cursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  SystemTableId, SchemaName, TableName, IsTemporal
      FROM  dsp.SystemTable;

    OPEN _Cursor;

    DECLARE @SchemaName TSTRING;
    DECLARE @TableName TSTRING;
    DECLARE @IsTemporal BIT;
    DECLARE @object_id INT;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM _Cursor
         INTO @object_id, @SchemaName, @TableName, @IsTemporal;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        -- Enable temporal for all tables that Istemporal is set
        IF @IsTemporal = 1
            EXEC dsp.Table_EnableTemporalAttribute @SchemaName = @SchemaName, @TableName = @TableName;

        -- Disable temporal for all tables that Istemporal is not set
        IF @IsTemporal = 0
        BEGIN
            IF @DoNotDisableTemporalForActiveTemporal = 1
                IF EXISTS (   SELECT    *
                                FROM    sys.tables
                               WHERE object_id = @object_id AND temporal_type <> 0)
                    EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID,
                        @Message = 'Temporal is active for table {0}.{1}, it is depend on Init argument, you can not disable it', @Param0 = @SchemaName,
                        @Param1 = @TableName;
            EXEC dsp.Table_DisableTemporalAttribute @SchemaName = @SchemaName, @TableName = @TableName;
        END;
    END;
    CLOSE _Cursor;
    DEALLOCATE _Cursor;
END;
GO
PRINT N'Creating [str].[String1]'
GO

CREATE FUNCTION [str].[String1]() 
RETURNS TSTRING
AS 
BEGIN
	RETURN dsp.StringTable_Value('String1');
END
GO
PRINT N'Creating [tSQLt].[SuppressOutput]'
GO
SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS OFF
GO
CREATE PROCEDURE [tSQLt].[SuppressOutput] (@command [nvarchar] (max))
WITH EXECUTE AS CALLER
AS EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.StoredProcedures].[SuppressOutput]
GO
PRINT N'Creating [tSQLt].[Private_RenamedObjectLog]'
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE TABLE [tSQLt].[Private_RenamedObjectLog]
(
[Id] [int] NOT NULL IDENTITY(1, 1),
[ObjectId] [int] NOT NULL,
[OriginalName] [nvarchar] (max) NOT NULL
)
GO
PRINT N'Creating primary key [PK__Private_RenamedObjectLog__Id] on [tSQLt].[Private_RenamedObjectLog]'
GO
ALTER TABLE [tSQLt].[Private_RenamedObjectLog] ADD CONSTRAINT [PK__Private_RenamedObjectLog__Id] PRIMARY KEY CLUSTERED  ([Id])
GO
PRINT N'Creating [tSQLt].[Private_MarkObjectBeforeRename]'
GO
CREATE PROCEDURE [tSQLt].[Private_MarkObjectBeforeRename]
    @SchemaName NVARCHAR(MAX), 
    @OriginalName NVARCHAR(MAX)
AS
BEGIN
  INSERT INTO tSQLt.Private_RenamedObjectLog (ObjectId, OriginalName) 
  VALUES (OBJECT_ID(@SchemaName + '.' + @OriginalName), @OriginalName);
END;
GO
PRINT N'Creating [tSQLt].[Private_RenameObjectToUniqueName]'
GO
CREATE PROCEDURE [tSQLt].[Private_RenameObjectToUniqueName]
    @SchemaName NVARCHAR(MAX),
    @ObjectName NVARCHAR(MAX),
    @NewName NVARCHAR(MAX) = NULL OUTPUT
AS
BEGIN
   SET @NewName=tSQLt.Private::CreateUniqueObjectName();

   DECLARE @RenameCmd NVARCHAR(MAX);
   SET @RenameCmd = 'EXEC sp_rename ''' + 
                          @SchemaName + '.' + @ObjectName + ''', ''' + 
                          @NewName + ''';';
   
   EXEC tSQLt.Private_MarkObjectBeforeRename @SchemaName, @ObjectName;


   EXEC tSQLt.SuppressOutput @RenameCmd;

END;
GO
PRINT N'Creating [tSQLt].[Private_RenameObjectToUniqueNameUsingObjectId]'
GO
CREATE PROCEDURE [tSQLt].[Private_RenameObjectToUniqueNameUsingObjectId]
    @ObjectId INT,
    @NewName NVARCHAR(MAX) = NULL OUTPUT
AS
BEGIN
   DECLARE @SchemaName NVARCHAR(MAX);
   DECLARE @ObjectName NVARCHAR(MAX);
   
   SELECT @SchemaName = QUOTENAME(OBJECT_SCHEMA_NAME(@ObjectId)), @ObjectName = QUOTENAME(OBJECT_NAME(@ObjectId));
   
   EXEC tSQLt.Private_RenameObjectToUniqueName @SchemaName,@ObjectName, @NewName OUTPUT;
END;
GO
PRINT N'Creating [tSQLt].[RemoveObject]'
GO
CREATE PROCEDURE [tSQLt].[RemoveObject] 
    @ObjectName NVARCHAR(MAX),
    @NewName NVARCHAR(MAX) = NULL OUTPUT,
    @IfExists INT = 0
AS
BEGIN
  DECLARE @ObjectId INT;
  SELECT @ObjectId = OBJECT_ID(@ObjectName);
  
  IF(@ObjectId IS NULL)
  BEGIN
    IF(@IfExists = 1) RETURN;
    RAISERROR('%s does not exist!',16,10,@ObjectName);
  END;

  EXEC tSQLt.Private_RenameObjectToUniqueNameUsingObjectId @ObjectId, @NewName = @NewName OUTPUT;
END;
GO
PRINT N'Creating [tSQLt].[RemoveObjectIfExists]'
GO
CREATE PROCEDURE [tSQLt].[RemoveObjectIfExists] 
    @ObjectName NVARCHAR(MAX),
    @NewName NVARCHAR(MAX) = NULL OUTPUT
AS
BEGIN
  EXEC tSQLt.RemoveObject @ObjectName = @ObjectName, @NewName = @NewName OUT, @IfExists = 1;
END;
GO
PRINT N'Creating [SQLCop].[test Database Mail]'
GO
CREATE PROCEDURE [SQLCop].[test Database Mail]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Database_Mail_XPs
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    select @Output = @Output + 'Status: Database Mail procedures are enabled' + Char(13) + Char(10)
    from   sys.configurations
    where  name = 'Database Mail XPs'
           and value_in_use = 1
                   
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Database_Mail_XPs'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
  
END;
GO
PRINT N'Creating [dsp].[Init_FillSystemTableData]'
GO

CREATE PROCEDURE [dsp].[Init_FillSystemTableData]
AS
BEGIN
    -- It should implemnetd by Merg
    --Target is dsp.SystemTable
    MERGE dsp.SystemTable AS target
    USING (
              -- Source is sys.Tables
              SELECT    T.object_id, T.name TableName, S.name SchemaName,
                  ClusterColumnsName = (
                                           -- Get each table clustered columns name in comma seprator format
                                           SELECT   STRING_AGG(c.name, ',')
                                             FROM   sys.indexes i
                                                    JOIN sys.index_columns AS ic ON ic.index_id = i.index_id AND ic.object_id = i.object_id
                                                    JOIN sys.columns AS c ON c.column_id = ic.column_id AND c.object_id = ic.object_id
                                            WHERE  i.object_id = T.object_id AND   ic.is_included_column = 0 AND   i.type_desc = 'CLUSTERED') --
                /*IsHistoryTable = IIF(T.temporal_type = 1, 1, 0)*/
                FROM    sys.tables T
                        INNER JOIN sys.schemas S ON S.schema_id = T.schema_id
               WHERE S.name NOT LIKE 't%' AND   LOWER(T.name) NOT LIKE '%history') AS source (object_id, TableName, SchemaName, ClusterColumnsName)
       ON (target.SystemTableId = source.object_id)

     -- If not exists then insert
     WHEN NOT MATCHED
        THEN INSERT (SystemTableId, TableName, SchemaName, ClusterColumnsName)
             VALUES (source.object_id, source.TableName, source.SchemaName, source.ClusterColumnsName)

     -- If exists but has any change then update
     WHEN MATCHED AND EXISTS (   SELECT source.TableName, source.SchemaName, source.ClusterColumnsName /*, source.IsHistoryTable*/
                                 EXCEPT
                                 SELECT target.TableName, target.SchemaName, target.ClusterColumnsName /*, target.IsHistoryTable*/)
        THEN UPDATE SET --
                 target.SchemaName = source.SchemaName, --
                 target.TableName = source.TableName, --
                 target.ClusterColumnsName = source.ClusterColumnsName --
     /*target.IsHistoryTable = source.IsHistoryTable*/

     -- if not exists in the source then delete from target
     WHEN NOT MATCHED BY SOURCE
        THEN DELETE;
END;
GO
PRINT N'Creating [str].[String2]'
GO

CREATE FUNCTION [str].[String2]() 
RETURNS TSTRING
AS 
BEGIN
	RETURN dsp.StringTable_Value('String2');
END
GO
PRINT N'Creating [tSQLt].[RenameClass]'
GO
CREATE PROCEDURE [tSQLt].[RenameClass]
   @SchemaName NVARCHAR(MAX),
   @NewSchemaName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @MigrateObjectsCommand NVARCHAR(MAX);

  SELECT @NewSchemaName = PARSENAME(@NewSchemaName, 1),
         @SchemaName = PARSENAME(@SchemaName, 1);

  EXEC tSQLt.NewTestClass @NewSchemaName;

  SELECT @MigrateObjectsCommand = (
    SELECT Cmd AS [text()] FROM (
    SELECT 'ALTER SCHEMA ' + QUOTENAME(@NewSchemaName) + ' TRANSFER ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(name) + ';' AS Cmd
      FROM sys.objects
     WHERE schema_id = SCHEMA_ID(@SchemaName)
       AND type NOT IN ('PK', 'F')
    UNION ALL 
    SELECT 'ALTER SCHEMA ' + QUOTENAME(@NewSchemaName) + ' TRANSFER XML SCHEMA COLLECTION::' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(name) + ';' AS Cmd
      FROM sys.xml_schema_collections
     WHERE schema_id = SCHEMA_ID(@SchemaName)
    UNION ALL 
    SELECT 'ALTER SCHEMA ' + QUOTENAME(@NewSchemaName) + ' TRANSFER TYPE::' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(name) + ';' AS Cmd
      FROM sys.types
     WHERE schema_id = SCHEMA_ID(@SchemaName)
    ) AS Cmds
       FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)');

  EXEC (@MigrateObjectsCommand);

  EXEC tSQLt.DropClass @SchemaName;
END;
GO
PRINT N'Creating [SQLCop].[test Decimal Size Problem]'
GO
CREATE PROCEDURE [SQLCop].[test Decimal Size Problem]
AS
BEGIN
    -- Written by George Mastros
    -- February 25, 2012
    -- http://sqlcop.lessthandot.com
    -- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/always-include-precision-and-scale-with
    
    SET NOCOUNT ON  

    Declare @Output VarChar(max)
    Set @Output = ''
  
    Select @Output = @Output + Schema_Name(schema_id) + '.' + name + Char(13) + Char(10)
    From	sys.objects
    WHERE	schema_id <> Schema_ID('SQLCop')
            And schema_id <> Schema_Id('tSQLt')
            and (
            REPLACE(REPLACE(Object_Definition(object_id), ' ', ''), 'decimal]','decimal') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE '%decimal[^(]%'
            Or REPLACE(REPLACE(Object_Definition(object_id), ' ', ''), 'numeric]','numeric') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE '%[^i][^s]numeric[^(]%'
            )
    Order By Schema_Name(schema_id), name  

    If @Output > '' 
        Begin
            Set @Output = Char(13) + Char(10) 
                          + 'For more information:  '
                          + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/always-include-precision-and-scale-with'
                          + Char(13) + Char(10) 
                          + Char(13) + Char(10) 
                          + @Output
            EXEC tSQLt.Fail @Output
        End  
END;
GO
PRINT N'Creating [dsp].[Init_FillData]'
GO
CREATE PROCEDURE [dsp].[Init_FillData]
AS
BEGIN
    SET NOCOUNT ON;

    -- TODO: Initialize the app 
    EXEC dsp.Setting_SetProps @AppName = 'MyAppName', @AppVersion = '1.0.*';

    -- Fill SystemTable
    EXEC dsp.Init_FillSystemTableData;
END;

GO
PRINT N'Creating [dsperr].[ObjectIsInUseId]'
GO

CREATE FUNCTION [dsperr].[ObjectIsInUseId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55004;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowObjectIsInUse]'
GO

CREATE PROCEDURE [dsperr].[ThrowObjectIsInUse] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.ObjectIsInUseId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Reset]'
GO
CREATE PROCEDURE [tSQLt].[Reset]
AS
BEGIN
  EXEC tSQLt.Private_ResetNewTestClassList;
END;
GO
PRINT N'Creating [SQLCop].[test Forwarded Records]'
GO
CREATE PROCEDURE [SQLCop].[test Forwarded Records]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Finding_Forwarded_Records_SQL_Server_2008
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

    If Exists(Select cmptlevel from master.dbo.sysdatabases Where dbid = db_ID() And cmptlevel > 80)
		Begin
			Create Table #Results(ProblemItem VarChar(1000))
			
			Insert Into #Results(ProblemItem)
			Exec ('	SELECT	SCHEMA_NAME(O.Schema_Id) + ''.'' + O.name As ProblemItem
					FROM	sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL, NULL, ''DETAILED'') AS ps
							INNER JOIN sys.indexes AS i      
								ON ps.OBJECT_ID = i.OBJECT_ID
								AND ps.index_id = i.index_id
							INNER JOIN sys.objects as O
								On i.OBJECT_ID = O.OBJECT_ID
					WHERE  ps.forwarded_record_count > 0
					Order By SCHEMA_NAME(O.Schema_Id),O.name')
			
			If Exists(Select 1 From #Results)
				Select	@Output = @Output + ProblemItem + Char(13) + Char(10)
				From	#Results
			
		End
    Else
      Set @Output = 'Unable to check index forwarded records when compatibility is set to 80 or below'

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Finding_Forwarded_Records_SQL_Server_2008'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
  
END;
GO
PRINT N'Creating [dsperr].[PageSizeTooLargeId]'
GO

CREATE FUNCTION [dsperr].[PageSizeTooLargeId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55005;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowPageSizeTooLarge]'
GO

CREATE PROCEDURE [dsperr].[ThrowPageSizeTooLarge] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.PageSizeTooLargeId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Run]'
GO
CREATE PROCEDURE [tSQLt].[Run]
   @TestName NVARCHAR(MAX) = NULL,
   @TestResultFormatter NVARCHAR(MAX) = NULL
AS
BEGIN
  EXEC tSQLt.Private_RunMethodHandler @RunMethod = 'tSQLt.Private_Run', @TestResultFormatter = @TestResultFormatter, @TestName = @TestName; 
END;
GO
PRINT N'Creating [SQLCop].[test Fragmented Indexes]'
GO
CREATE PROCEDURE [SQLCop].[test Fragmented Indexes]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Finding_Fragmentation_Of_An_Index_And_Fixing_It
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	Create Table #Result (ProblemItem VarChar(1000))
	
	If Exists(Select cmptlevel from master.dbo.sysdatabases Where dbid = db_ID() And cmptlevel > 80)
		If Exists(Select 1 From fn_my_permissions(NULL, 'DATABASE') WHERE permission_name = 'VIEW DATABASE STATE')
			Begin
				Insert Into #Result(ProblemItem)
				Exec('
						SELECT	OBJECT_NAME(OBJECT_ID) + ''.'' + s.name As ProblemItem
						FROM	sys.dm_db_index_physical_stats (DB_ID(), NULL, NULL , NULL, N''LIMITED'') d
								join sysindexes s
									ON	d.OBJECT_ID = s.id
									and d.index_id = s.indid
						Where	avg_fragmentation_in_percent >= 30
								And OBJECT_NAME(OBJECT_ID) + ''.'' + s.name > ''''
								And page_count > 1000
								Order By Object_Name(OBJECT_ID), s.name')
			End
		Else
			Set @Output = 'You do not have VIEW DATABASE STATE permissions within this database'
		Else
			Set @Output = 'Unable to check index fragmentation when compatibility is set to 80 or below'
			  
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Finding_Fragmentation_Of_An_Index_And_Fixing_It'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
END;
GO
PRINT N'Creating [dsperr].[ThrowInvalidArgument]'
GO

CREATE PROCEDURE [dsperr].[ThrowInvalidArgument] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvalidArgumentId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[RunAll]'
GO
CREATE PROCEDURE [tSQLt].[RunAll]
AS
BEGIN
  EXEC tSQLt.Private_RunMethodHandler @RunMethod = 'tSQLt.Private_RunAll';
END;
GO
PRINT N'Creating [SQLCop].[test Instant File Initialization]'
GO
CREATE PROCEDURE [SQLCop].[test Instant File Initialization]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.bradmcgehee.com/2010/07/instant-file-initialization-speeds-sql-server/#more-1704
	
    SET NOCOUNT ON

	DECLARE @Output VarChar(max)
	SET @Output = ''

    CREATE TABLE #Output(Value VarChar(8000))

	If Exists(select * from sys.configurations Where name='xp_cmdshell' and value_in_use = 1)
		Begin
			If Is_SrvRoleMember('sysadmin') = 1
				Begin
					Insert Into #Output EXEC ('xp_cmdshell ''whoami /priv''');

					If Not Exists(Select 1 From #Output Where Value LIKE '%SeManageVolumePrivilege%')
						Select @Output = 'Instant File Initialization disabled'
					Else
						Select	@Output = 'Instant File Initialization disabled'
						From	#Output
						Where	Value LIKE '%SeManageVolumePrivilege%'
								And Value Like '%disabled%'
				End
			Else
				Set @Output = 'You do not have the appropriate permissions to run xp_cmdshell'
		End
	Else
		Begin
			Set @Output = 'xp_cmdshell must be enabled to determine if instant file initialization is enabled.'
		End
	Drop Table #Output

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.bradmcgehee.com/2010/07/instant-file-initialization-speeds-sql-server/#more-1704'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsperr].[FatalErrorId]'
GO

CREATE FUNCTION [dsperr].[FatalErrorId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55007;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowFatalError]'
GO

CREATE PROCEDURE [dsperr].[ThrowFatalError] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.FatalErrorId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_GetOriginalTableInfo]'
GO
CREATE FUNCTION [tSQLt].[Private_GetOriginalTableInfo](@TableObjectId INT)
RETURNS TABLE
AS
  RETURN SELECT CAST(value AS NVARCHAR(4000)) OrgTableName,
                OBJECT_ID(QUOTENAME(OBJECT_SCHEMA_NAME(@TableObjectId)) + '.' + QUOTENAME(CAST(value AS NVARCHAR(4000)))) OrgTableObjectId
    FROM sys.extended_properties
   WHERE class_desc = 'OBJECT_OR_COLUMN'
     AND major_id = @TableObjectId
     AND minor_id = 0
     AND name = 'tSQLt.FakeTable_OrgTableName';
GO
PRINT N'Creating [tSQLt].[Private_FindConstraint]'
GO
CREATE FUNCTION [tSQLt].[Private_FindConstraint]
(
  @TableObjectId INT,
  @ConstraintName NVARCHAR(MAX)
)
RETURNS TABLE
AS
RETURN
  SELECT TOP(1) constraints.object_id AS ConstraintObjectId, type_desc AS ConstraintType
    FROM sys.objects constraints
    CROSS JOIN tSQLt.Private_GetOriginalTableInfo(@TableObjectId) orgTbl
   WHERE @ConstraintName IN (constraints.name, QUOTENAME(constraints.name))
     AND constraints.parent_object_id = orgTbl.OrgTableObjectId
   ORDER BY LEN(constraints.name) ASC;
GO
PRINT N'Creating [SQLCop].[test Login Language]'
GO
CREATE PROCEDURE [SQLCop].[test Login Language]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/setting-a-standard-dateformat-for-sql-se
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Declare @DefaultLanguage VarChar(100)  
    
	Set @Output = ''
    
    Select  @DefaultLanguage = L.Name
    From    master.dbo.sysconfigures C
            Inner Join master.dbo.syslanguages L
              On C.Value = L.LangId
              And C.Comment = 'default Language'

    Select  @Output = @Output + Name + Char(13) + Char(10)
    From    master..syslogins
    Where   Language <> @DefaultLanguage
    Order By Name
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/setting-a-standard-dateformat-for-sql-se'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsperr].[LockFailedId]'
GO

CREATE FUNCTION [dsperr].[LockFailedId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55008;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowLockFailed]'
GO

CREATE PROCEDURE [dsperr].[ThrowLockFailed] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.LockFailedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_InputBuffer]'
GO
CREATE PROCEDURE [tSQLt].[Private_InputBuffer]
  @InputBuffer NVARCHAR(MAX) OUTPUT
AS
BEGIN
  CREATE TABLE #inputbuffer(EventType SYSNAME, Parameters SMALLINT, EventInfo NVARCHAR(MAX));
  INSERT INTO #inputbuffer
  EXEC('DBCC INPUTBUFFER(@@SPID) WITH NO_INFOMSGS;');
  SELECT @InputBuffer = I.EventInfo FROM #inputbuffer AS I;
END;
GO
PRINT N'Creating [tSQLt].[RunC]'
GO
CREATE PROCEDURE [tSQLt].[RunC]
AS
BEGIN
  DECLARE @TestName NVARCHAR(MAX);SET @TestName = NULL;
  DECLARE @InputBuffer NVARCHAR(MAX);
  EXEC tSQLt.Private_InputBuffer @InputBuffer = @InputBuffer OUT;
  IF(@InputBuffer LIKE 'EXEC tSQLt.RunC;--%')
  BEGIN
    SET @TestName = LTRIM(RTRIM(STUFF(@InputBuffer,1,18,'')));
  END;
  EXEC tSQLt.Run @TestName = @TestName;
END;
GO
PRINT N'Creating [SQLCop].[test Max degree of parallelism]'
GO
CREATE PROCEDURE [SQLCop].[test Max degree of parallelism]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://sqlblog.com/blogs/adam_machanic/archive/2010/05/28/sql-university-parallelism-week-part-3-settings-and-options.aspx
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    select @Output = 'Warning: Max degree of parallelism is setup to use all cores'
    from   sys.configurations
    where  name = 'max degree of parallelism'
           and value_in_use = 0
               
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://sqlblog.com/blogs/adam_machanic/archive/2010/05/28/sql-university-parallelism-week-part-3-settings-and-options.aspx'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsperr].[ValidationErrorId]'
GO

CREATE FUNCTION [dsperr].[ValidationErrorId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55009;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowValidationError]'
GO

CREATE PROCEDURE [dsperr].[ThrowValidationError] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.ValidationErrorId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[RunNew]'
GO
CREATE PROCEDURE [tSQLt].[RunNew]
AS
BEGIN
  EXEC tSQLt.Private_RunMethodHandler @RunMethod = 'tSQLt.Private_RunNew';
END;
GO
PRINT N'Creating [SQLCop].[test Missing Foreign Key Indexes]'
GO
CREATE PROCEDURE [SQLCop].[test Missing Foreign Key Indexes]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.jasonstrate.com/2010/06/index-those-foreign-keys/
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	If Exists(Select 1 From fn_my_permissions(NULL, 'DATABASE') WHERE permission_name = 'VIEW DATABASE STATE')
		SELECT	@Output = @Output + Convert(VarChar(300), fk.foreign_key_name) + Char(13) + Char(10)
		FROM	(
				SELECT	fk.name AS foreign_key_name,
						'PARENT' as foreign_key_type,
						fkc.parent_object_id AS object_id,
						STUFF((	SELECT ', ' + QUOTENAME(c.name)
								FROM	sys.foreign_key_columns ifkc
										INNER JOIN sys.columns c
											ON ifkc.parent_object_id = c.object_id
											AND ifkc.parent_column_id = c.column_id
								WHERE fk.object_id = ifkc.constraint_object_id
								ORDER BY ifkc.constraint_column_id
								FOR XML PATH('')), 1, 2, '') AS fk_columns,
						(	SELECT	QUOTENAME(ifkc.parent_column_id,'(')
							FROM	sys.foreign_key_columns ifkc
							WHERE	fk.object_id = ifkc.constraint_object_id
							ORDER BY ifkc.constraint_column_id
							FOR XML PATH('')) AS fk_columns_compare
				FROM	sys.foreign_keys fk
						INNER JOIN sys.foreign_key_columns fkc
							ON fk.object_id = fkc.constraint_object_id
				WHERE fkc.constraint_column_id = 1

				UNION ALL

				SELECT	fk.name AS foreign_key_name,
						'REFERENCED' as foreign_key_type,
						fkc.referenced_object_id AS object_id,
						STUFF((	SELECT	', ' + QUOTENAME(c.name)
								FROM	sys.foreign_key_columns ifkc
										INNER JOIN sys.columns c
											ON ifkc.referenced_object_id = c.object_id
											AND ifkc.referenced_column_id = c.column_id
								WHERE fk.object_id = ifkc.constraint_object_id
								ORDER BY ifkc.constraint_column_id
								FOR XML PATH('')), 1, 2, '') AS fk_columns,
						(	SELECT	QUOTENAME(ifkc.referenced_column_id,'(')
							FROM	sys.foreign_key_columns ifkc
							WHERE	fk.object_id = ifkc.constraint_object_id
							ORDER BY ifkc.constraint_column_id
							FOR XML PATH('')) AS fk_columns_compare
				FROM	sys.foreign_keys fk
						INNER JOIN sys.foreign_key_columns fkc
							ON fk.object_id = fkc.constraint_object_id
				WHERE	fkc.constraint_column_id = 1
				) fk
				INNER JOIN (
					SELECT	object_id,
							SUM(row_count) AS row_count
					FROM	sys.dm_db_partition_stats ps
					WHERE	index_id IN (1,0)
					GROUP BY object_id
				) rc
					ON fk.object_id = rc.object_id
				LEFT OUTER JOIN (
					SELECT	i.object_id,
							i.name,
							(
							SELECT	QUOTENAME(ic.column_id,'(')
							FROM	sys.index_columns ic
							WHERE	i.object_id = ic.object_id
									AND i.index_id = ic.index_id
									AND is_included_column = 0
							ORDER BY key_ordinal ASC
							FOR XML PATH('')
							) AS indexed_compare
					FROM	sys.indexes i
					) i
				ON fk.object_id = i.object_id
				AND i.indexed_compare LIKE fk.fk_columns_compare + '%'
		WHERE	i.name IS NULL
		ORDER BY OBJECT_NAME(fk.object_id), fk.fk_columns
	Else
		Set @Output = 'You do not have VIEW DATABASE STATE permissions within this database'

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.jasonstrate.com/2010/06/index-those-foreign-keys/'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
END;
GO
PRINT N'Creating [tSQLt].[RunTestClass]'
GO
CREATE PROCEDURE [tSQLt].[RunTestClass]
   @TestClassName NVARCHAR(MAX)
AS
BEGIN
    EXEC tSQLt.Run @TestClassName;
END
GO
PRINT N'Creating [SQLCop].[test Missing Foreign Keys]'
GO
CREATE PROCEDURE [SQLCop].[test Missing Foreign Keys]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/missing-foreign-key-constraints
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
    DECLARE @AcceptableSymbols VARCHAR(100)

    SET @AcceptableSymbols = '_$'
	SET @Output = ''

	SELECT  @Output = @Output + C.TABLE_SCHEMA + '.' + C.TABLE_NAME + '.' + C.COLUMN_NAME + Char(13) + Char(10)
	FROM    INFORMATION_SCHEMA.COLUMNS C          
	        INNER Join INFORMATION_SCHEMA.TABLES T            
	          ON C.TABLE_NAME = T.TABLE_NAME    
	          AND T.TABLE_TYPE = 'BASE TABLE'
	          AND T.TABLE_SCHEMA = C.TABLE_SCHEMA        
	        LEFT Join INFORMATION_SCHEMA.CONSTRAINT_COLUMN_USAGE U            
	          ON C.TABLE_NAME = U.TABLE_NAME            
	          AND C.COLUMN_NAME = U.COLUMN_NAME
	          AND U.TABLE_SCHEMA = C.TABLE_SCHEMA
	WHERE   U.COLUMN_NAME IS Null          
			And C.TABLE_SCHEMA <> 'tSQLt'
	        AND C.COLUMN_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%id'
	ORDER BY C.TABLE_SCHEMA, C.TABLE_NAME, C.COLUMN_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/missing-foreign-key-constraints' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End			
  
END;
GO
PRINT N'Creating [dsperr].[NotSupportedId]'
GO

CREATE FUNCTION [dsperr].[NotSupportedId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55011;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowNotSupported]'
GO

CREATE PROCEDURE [dsperr].[ThrowNotSupported] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.NotSupportedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[RunWithNullResults]'
GO
CREATE PROCEDURE [tSQLt].[RunWithNullResults]
    @TestName NVARCHAR(MAX) = NULL
AS
BEGIN
  EXEC tSQLt.Run @TestName = @TestName, @TestResultFormatter = 'tSQLt.NullTestResultFormatter';
END;
GO
PRINT N'Creating [SQLCop].[test Old Backups]'
GO
CREATE PROCEDURE [SQLCop].[test Old Backups]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/the-sql-server-backup-foundation-of-any
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    Select  @Output = @Output + 'Outdated Backup For '+ D.Name + Char(13) + Char(10)
    FROM    master..sysdatabases As D         
            Left Join msdb.dbo.backupset As B             
              On  B.database_name = D.Name             
              And B.type = 'd' 
    WHERE   D.Status & 512 = 0 
    GROUP BY D.Name 
    Having Coalesce(DATEDIFF(D, Max(backup_finish_date), Getdate()), 1000) > 7 
    ORDER BY D.Name
                   
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/the-sql-server-backup-foundation-of-any'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsperr].[NotImplemetedId]'
GO

CREATE FUNCTION [dsperr].[NotImplemetedId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55012;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowNotImplemeted]'
GO

CREATE PROCEDURE [dsperr].[ThrowNotImplemeted] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.NotImplemetedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[RunWithXmlResults]'
GO
CREATE PROCEDURE [tSQLt].[RunWithXmlResults]
   @TestName NVARCHAR(MAX) = NULL
AS
BEGIN
  EXEC tSQLt.Run @TestName = @TestName, @TestResultFormatter = 'tSQLt.XmlResultFormatter';
END;
GO
PRINT N'Creating [SQLCop].[test Ole Automation Procedures]'
GO
CREATE PROCEDURE [SQLCop].[test Ole Automation Procedures]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Ole_Automation_Procedures
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    select @Output = @Output + 'Warning: Ole Automation procedures are enabled' + Char(13) + Char(10)
    from   sys.configurations
    where  name = 'Ole Automation Procedures'
           and value_in_use = 1
                   
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#Ole_Automation_Procedures'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dsperr].[UserIsDisabledId]'
GO

CREATE FUNCTION [dsperr].[UserIsDisabledId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55013;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowUserIsDisabled]'
GO

CREATE PROCEDURE [dsperr].[ThrowUserIsDisabled] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.UserIsDisabledId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_GetDataTypeOrComputedColumnDefinition]'
GO
CREATE FUNCTION [tSQLt].[Private_GetDataTypeOrComputedColumnDefinition](@UserTypeId INT, @MaxLength INT, @Precision INT, @Scale INT, @CollationName NVARCHAR(MAX), @ObjectId INT, @ColumnId INT, @ReturnDetails BIT)
RETURNS TABLE
AS
RETURN SELECT 
              COALESCE(cc.IsComputedColumn, 0) AS IsComputedColumn,
              COALESCE(cc.ComputedColumnDefinition, GFTN.TypeName) AS ColumnDefinition
        FROM (SELECT @UserTypeId, @MaxLength, @Precision, @Scale, @CollationName, @ObjectId, @ColumnId, @ReturnDetails) 
             AS V(UserTypeId, MaxLength, Precision, Scale, CollationName, ObjectId, ColumnId, ReturnDetails)
       CROSS APPLY tSQLt.Private_GetFullTypeName(V.UserTypeId, V.MaxLength, V.Precision, V.Scale, V.CollationName) AS GFTN
        LEFT JOIN (SELECT 1 AS IsComputedColumn,
                          ' AS '+ cci.definition + CASE WHEN cci.is_persisted = 1 THEN ' PERSISTED' ELSE '' END AS ComputedColumnDefinition,
                          cci.object_id,
                          cci.column_id
                     FROM sys.computed_columns cci
                  )cc
               ON cc.object_id = V.ObjectId
              AND cc.column_id = V.ColumnId
              AND V.ReturnDetails = 1;
GO
PRINT N'Creating [SQLCop].[test Orphaned Users]'
GO
CREATE PROCEDURE [SQLCop].[test Orphaned Users]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Fix_Orphaned_Database_Users
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    Set NOCOUNT ON
	If is_rolemember('db_owner') = 1
		Begin
			Declare @Temp Table(UserName sysname, UserSid VarBinary(85))

			Insert Into @Temp Exec sp_change_users_login 'report'

			Select @Output = @Output + UserName + Char(13) + Char(10)
			From   @Temp
			Order By UserName
		End
	Else
		Set @Output = 'Only members of db_owner can perform this check.'
                   
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Fix_Orphaned_Database_Users'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
		  
END;
GO
PRINT N'Creating [dsperr].[AmbiguousExceptionId]'
GO

CREATE FUNCTION [dsperr].[AmbiguousExceptionId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55014;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowAmbiguousException]'
GO

CREATE PROCEDURE [dsperr].[ThrowAmbiguousException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.AmbiguousExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_SetFakeViewOff_SingleView]'
GO
CREATE PROCEDURE [tSQLt].[Private_SetFakeViewOff_SingleView]
  @ViewName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @Cmd NVARCHAR(MAX),
          @SchemaName NVARCHAR(MAX),
          @TriggerName NVARCHAR(MAX);
          
  SELECT @SchemaName = QUOTENAME(OBJECT_SCHEMA_NAME(ObjId)),
         @TriggerName = QUOTENAME(OBJECT_NAME(ObjId) + '_SetFakeViewOn')
    FROM (SELECT OBJECT_ID(@ViewName) AS ObjId) X;
  
  SET @Cmd = 'DROP TRIGGER %SCHEMA_NAME%.%TRIGGER_NAME%;';
      
  SET @Cmd = REPLACE(@Cmd, '%SCHEMA_NAME%', @SchemaName);
  SET @Cmd = REPLACE(@Cmd, '%TRIGGER_NAME%', @TriggerName);
  
  EXEC(@Cmd);
END;
GO
PRINT N'Creating [tSQLt].[SetFakeViewOff]'
GO
CREATE PROCEDURE [tSQLt].[SetFakeViewOff]
  @SchemaName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @ViewName NVARCHAR(MAX);
    
  DECLARE viewNames CURSOR LOCAL FAST_FORWARD FOR
   SELECT QUOTENAME(OBJECT_SCHEMA_NAME(t.parent_id)) + '.' + QUOTENAME(OBJECT_NAME(t.parent_id)) AS viewName
     FROM sys.extended_properties ep
     JOIN sys.triggers t
       on ep.major_id = t.object_id
     WHERE ep.name = N'SetFakeViewOnTrigger'  
  OPEN viewNames;
  
  FETCH NEXT FROM viewNames INTO @ViewName;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    EXEC tSQLt.Private_SetFakeViewOff_SingleView @ViewName;
    
    FETCH NEXT FROM viewNames INTO @ViewName;
  END;
  
  CLOSE viewNames;
  DEALLOCATE viewNames;
END;
GO
PRINT N'Creating [SQLCop].[test Page life expectancy]'
GO
CREATE PROCEDURE [SQLCop].[test Page life expectancy]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/MSSQLServerAdmin/use-sys-dm_os_performance_counters-to-ge#PLE
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

	If Exists(Select 1 From fn_my_permissions(NULL, 'SERVER') WHERE permission_name = 'VIEW SERVER STATE')
		SELECT	@Output = @Output + Convert(VarChar(100), cntr_value) + Char(13) + Char(10)
		FROM	sys.dm_os_performance_counters  
		WHERE	counter_name collate SQL_LATIN1_GENERAL_CP1_CI_AI = 'Page life expectancy'
				AND OBJECT_NAME collate SQL_LATIN1_GENERAL_CP1_CI_AI like '%:Buffer Manager%'
				And cntr_value <= 300
	Else
		Set @Output = 'You do not have VIEW SERVER STATE permissions within this instance.'
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBAdmin/MSSQLServerAdmin/use-sys-dm_os_performance_counters-to-ge#PLE'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dsperr].[NoOperationId]'
GO

CREATE FUNCTION [dsperr].[NoOperationId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55015;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowNoOperation]'
GO

CREATE PROCEDURE [dsperr].[ThrowNoOperation] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.NoOperationId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [SQLCop].[test Procedures Named SP_]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures Named SP_]
AS
BEGIN
    -- Written by George Mastros
    -- February 25, 2012
    -- http://sqlcop.lessthandot.com
    -- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/don-t-start-your-procedures-with-sp_
    
    SET NOCOUNT ON
    
    Declare @Output VarChar(max)
    Set @Output = ''
  
    SELECT	@Output = @Output + SPECIFIC_SCHEMA + '.' + SPECIFIC_NAME + Char(13) + Char(10)
    From	INFORMATION_SCHEMA.ROUTINES
    Where	SPECIFIC_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE 'sp[_]%'
            And SPECIFIC_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI NOT LIKE '%diagram%'
            AND ROUTINE_SCHEMA <> 'tSQLt'
    Order By SPECIFIC_SCHEMA,SPECIFIC_NAME

    If @Output > '' 
        Begin
            Set @Output = Char(13) + Char(10) 
                          + 'For more information:  '
                          + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/don-t-start-your-procedures-with-sp_'
                          + Char(13) + Char(10) 
                          + Char(13) + Char(10) 
                          + @Output
            EXEC tSQLt.Fail @Output
        End 
END;
GO
PRINT N'Creating [dsperr].[InvalidCaptchaId]'
GO

CREATE FUNCTION [dsperr].[InvalidCaptchaId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55016;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowInvalidCaptcha]'
GO

CREATE PROCEDURE [dsperr].[ThrowInvalidCaptcha] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvalidCaptchaId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_GetForeignKeyRefColumns]'
GO
CREATE FUNCTION [tSQLt].[Private_GetForeignKeyRefColumns](
    @ConstraintObjectId INT
)
RETURNS TABLE
AS
RETURN SELECT STUFF((
                 SELECT ','+QUOTENAME(rci.name) FROM sys.foreign_key_columns c
                   JOIN sys.columns rci
                  ON rci.object_id = c.referenced_object_id
                  AND rci.column_id = c.referenced_column_id
                   WHERE @ConstraintObjectId = c.constraint_object_id
                   FOR XML PATH(''),TYPE
                   ).value('.','NVARCHAR(MAX)'),1,1,'')  AS ColNames;
GO
PRINT N'Creating [tSQLt].[Private_GetForeignKeyParColumns]'
GO
CREATE FUNCTION [tSQLt].[Private_GetForeignKeyParColumns](
    @ConstraintObjectId INT
)
RETURNS TABLE
AS
RETURN SELECT STUFF((
                 SELECT ','+QUOTENAME(pci.name) FROM sys.foreign_key_columns c
                   JOIN sys.columns pci
                   ON pci.object_id = c.parent_object_id
                  AND pci.column_id = c.parent_column_id
                   WHERE @ConstraintObjectId = c.constraint_object_id
                   FOR XML PATH(''),TYPE
                   ).value('.','NVARCHAR(MAX)'),1,1,'')  AS ColNames
GO
PRINT N'Creating [tSQLt].[Private_GetForeignKeyDefinition]'
GO
CREATE FUNCTION [tSQLt].[Private_GetForeignKeyDefinition](
    @SchemaName NVARCHAR(MAX),
    @ParentTableName NVARCHAR(MAX),
    @ForeignKeyName NVARCHAR(MAX),
    @NoCascade BIT
)
RETURNS TABLE
AS
RETURN SELECT 'CONSTRAINT ' + name + ' FOREIGN KEY (' +
              parCols + ') REFERENCES ' + refName + '(' + refCols + ')'+
              CASE WHEN @NoCascade = 1 THEN ''
                ELSE delete_referential_action_cmd + ' ' + update_referential_action_cmd 
              END AS cmd,
              CASE 
                WHEN RefTableIsFakedInd = 1
                  THEN 'CREATE UNIQUE INDEX ' + tSQLt.Private::CreateUniqueObjectName() + ' ON ' + refName + '(' + refCols + ');' 
                ELSE '' 
              END CreIdxCmd
         FROM (SELECT QUOTENAME(SCHEMA_NAME(k.schema_id)) AS SchemaName,
                      QUOTENAME(k.name) AS name,
                      QUOTENAME(OBJECT_NAME(k.parent_object_id)) AS parName,
                      QUOTENAME(SCHEMA_NAME(refTab.schema_id)) + '.' + QUOTENAME(refTab.name) AS refName,
                      parCol.ColNames AS parCols,
                      refCol.ColNames AS refCols,
                      'ON UPDATE '+
                      CASE k.update_referential_action
                        WHEN 0 THEN 'NO ACTION'
                        WHEN 1 THEN 'CASCADE'
                        WHEN 2 THEN 'SET NULL'
                        WHEN 3 THEN 'SET DEFAULT'
                      END AS update_referential_action_cmd,
                      'ON DELETE '+
                      CASE k.delete_referential_action
                        WHEN 0 THEN 'NO ACTION'
                        WHEN 1 THEN 'CASCADE'
                        WHEN 2 THEN 'SET NULL'
                        WHEN 3 THEN 'SET DEFAULT'
                      END AS delete_referential_action_cmd,
                      CASE WHEN e.name IS NULL THEN 0
                           ELSE 1 
                       END AS RefTableIsFakedInd
                 FROM sys.foreign_keys k
                 CROSS APPLY tSQLt.Private_GetForeignKeyParColumns(k.object_id) AS parCol
                 CROSS APPLY tSQLt.Private_GetForeignKeyRefColumns(k.object_id) AS refCol
                 LEFT JOIN sys.extended_properties e
                   ON e.name = 'tSQLt.FakeTable_OrgTableName'
                  AND e.value = OBJECT_NAME(k.referenced_object_id)
                 JOIN sys.tables refTab
                   ON COALESCE(e.major_id,k.referenced_object_id) = refTab.object_id
                WHERE k.parent_object_id = OBJECT_ID(@SchemaName + '.' + @ParentTableName)
                  AND k.object_id = OBJECT_ID(@SchemaName + '.' + @ForeignKeyName)
               )x;
GO
PRINT N'Creating [tSQLt].[Private_SetFakeViewOn_SingleView]'
GO
CREATE PROCEDURE [tSQLt].[Private_SetFakeViewOn_SingleView]
  @ViewName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @Cmd NVARCHAR(MAX),
          @SchemaName NVARCHAR(MAX),
          @TriggerName NVARCHAR(MAX);
          
  SELECT @SchemaName = OBJECT_SCHEMA_NAME(ObjId),
         @ViewName = OBJECT_NAME(ObjId),
         @TriggerName = OBJECT_NAME(ObjId) + '_SetFakeViewOn'
    FROM (SELECT OBJECT_ID(@ViewName) AS ObjId) X;

  SET @Cmd = 
     'CREATE TRIGGER $$SCHEMA_NAME$$.$$TRIGGER_NAME$$
      ON $$SCHEMA_NAME$$.$$VIEW_NAME$$ INSTEAD OF INSERT AS
      BEGIN
         RAISERROR(''Test system is in an invalid state. SetFakeViewOff must be called if SetFakeViewOn was called. Call SetFakeViewOff after creating all test case procedures.'', 16, 10) WITH NOWAIT;
         RETURN;
      END;
     ';
      
  SET @Cmd = REPLACE(@Cmd, '$$SCHEMA_NAME$$', QUOTENAME(@SchemaName));
  SET @Cmd = REPLACE(@Cmd, '$$VIEW_NAME$$', QUOTENAME(@ViewName));
  SET @Cmd = REPLACE(@Cmd, '$$TRIGGER_NAME$$', QUOTENAME(@TriggerName));
  EXEC(@Cmd);

  EXEC sp_addextendedproperty @name = N'SetFakeViewOnTrigger', 
                               @value = 1,
                               @level0type = 'SCHEMA',
                               @level0name = @SchemaName, 
                               @level1type = 'VIEW',
                               @level1name = @ViewName,
                               @level2type = 'TRIGGER',
                               @level2name = @TriggerName;

  RETURN 0;
END;
GO
PRINT N'Creating [tSQLt].[SetFakeViewOn]'
GO
CREATE PROCEDURE [tSQLt].[SetFakeViewOn]
  @SchemaName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @ViewName NVARCHAR(MAX);
    
  DECLARE viewNames CURSOR LOCAL FAST_FORWARD FOR
  SELECT QUOTENAME(OBJECT_SCHEMA_NAME(object_id)) + '.' + QUOTENAME([name]) AS viewName
    FROM sys.views
   WHERE schema_id = SCHEMA_ID(@SchemaName);
  
  OPEN viewNames;
  
  FETCH NEXT FROM viewNames INTO @ViewName;
  WHILE @@FETCH_STATUS = 0
  BEGIN
    EXEC tSQLt.Private_SetFakeViewOn_SingleView @ViewName;
    
    FETCH NEXT FROM viewNames INTO @ViewName;
  END;
  
  CLOSE viewNames;
  DEALLOCATE viewNames;
END;
GO
PRINT N'Creating [SQLCop].[test Procedures that call undocumented procedures]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures that call undocumented procedures]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/identify-procedures-that-call-sql-server
	
    SET NOCOUNT ON

	Declare @Output VarChar(max)
	Set @Output = ''

    DECLARE @Temp TABLE(ProcedureName VARCHAR(50))

    INSERT INTO @Temp VALUES('sp_MStablespace')
    INSERT INTO @Temp VALUES('sp_who2')
    INSERT INTO @Temp VALUES('sp_tempdbspace')
    INSERT INTO @Temp VALUES('sp_MSkilldb')
    INSERT INTO @Temp VALUES('sp_MSindexspace')
    INSERT INTO @Temp VALUES('sp_MShelptype')
    INSERT INTO @Temp VALUES('sp_MShelpindex')
    INSERT INTO @Temp VALUES('sp_MShelpcolumns')
    INSERT INTO @Temp VALUES('sp_MSforeachtable')
    INSERT INTO @Temp VALUES('sp_MSforeachdb')
    INSERT INTO @Temp VALUES('sp_fixindex')
    INSERT INTO @Temp VALUES('sp_columns_rowset')
    INSERT INTO @Temp VALUES('sp_MScheck_uid_owns_anything')
    INSERT INTO @Temp VALUES('sp_MSgettools_path')
    INSERT INTO @Temp VALUES('sp_gettypestring')
    INSERT INTO @Temp VALUES('sp_MSdrop_object')
    INSERT INTO @Temp VALUES('sp_MSget_qualified_name')
    INSERT INTO @Temp VALUES('sp_MSgetversion')
    INSERT INTO @Temp VALUES('xp_dirtree')
    INSERT INTO @Temp VALUES('xp_subdirs')
    INSERT INTO @Temp VALUES('xp_enum_oledb_providers')
    INSERT INTO @Temp VALUES('xp_enumcodepages')
    INSERT INTO @Temp VALUES('xp_enumdsn')
    INSERT INTO @Temp VALUES('xp_enumerrorlogs')
    INSERT INTO @Temp VALUES('xp_enumgroups')
    INSERT INTO @Temp VALUES('xp_fileexist')
    INSERT INTO @Temp VALUES('xp_fixeddrives')
    INSERT INTO @Temp VALUES('xp_getnetname')
    INSERT INTO @Temp VALUES('xp_readerrorlog')
    INSERT INTO @Temp VALUES('sp_msdependencies')
    INSERT INTO @Temp VALUES('xp_qv')
    INSERT INTO @Temp VALUES('xp_delete_file')
    INSERT INTO @Temp VALUES('sp_checknames')
    INSERT INTO @Temp VALUES('sp_enumoledbdatasources')
    INSERT INTO @Temp VALUES('sp_MS_marksystemobject')
    INSERT INTO @Temp VALUES('sp_MSaddguidcolumn')
    INSERT INTO @Temp VALUES('sp_MSaddguidindex')
    INSERT INTO @Temp VALUES('sp_MSaddlogin_implicit_ntlogin')
    INSERT INTO @Temp VALUES('sp_MSadduser_implicit_ntlogin')
    INSERT INTO @Temp VALUES('sp_MSdbuseraccess')
    INSERT INTO @Temp VALUES('sp_MSdbuserpriv')
    INSERT INTO @Temp VALUES('sp_MSloginmappings')
    INSERT INTO @Temp VALUES('sp_MStablekeys')
    INSERT INTO @Temp VALUES('sp_MStablerefs')
    INSERT INTO @Temp VALUES('sp_MSuniquetempname')
    INSERT INTO @Temp VALUES('sp_MSuniqueobjectname')
    INSERT INTO @Temp VALUES('sp_MSuniquecolname')
    INSERT INTO @Temp VALUES('sp_MSuniquename')
    INSERT INTO @Temp VALUES('sp_MSunc_to_drive')
    INSERT INTO @Temp VALUES('sp_MSis_pk_col')
    INSERT INTO @Temp VALUES('xp_get_MAPI_default_profile')
    INSERT INTO @Temp VALUES('xp_get_MAPI_profiles')
    INSERT INTO @Temp VALUES('xp_regdeletekey')
    INSERT INTO @Temp VALUES('xp_regdeletevalue')
    INSERT INTO @Temp VALUES('xp_regread')
    INSERT INTO @Temp VALUES('xp_regenumvalues')
    INSERT INTO @Temp VALUES('xp_regaddmultistring')
    INSERT INTO @Temp VALUES('xp_regremovemultistring')
    INSERT INTO @Temp VALUES('xp_regwrite')
    INSERT INTO @Temp VALUES('xp_varbintohexstr')
    INSERT INTO @Temp VALUES('sp_MSguidtostr')

    Select @Output = @Output + u.name + '.' + o.name + Char(13) + Char(10)
    FROM   sysobjects o
           INNER JOIN syscomments c
             ON o.id = c.id
             AND o.xtype = 'P'
           INNER JOIN sysusers u
             ON o.uid = u.uid
           INNER JOIN @Temp t
             ON c.text COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE '%' + t.ProcedureName + '%'
    WHERE  xtype = 'P'
           AND OBJECTPROPERTY(o.id, N'IsMSShipped') = 0
           AND u.name <> 'tSQLt'
    ORDER BY u.name + '.' + o.Name 

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/identify-procedures-that-call-sql-server'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dsperr].[BatchIsNotAllowedId]'
GO

CREATE FUNCTION [dsperr].[BatchIsNotAllowedId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55017;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowBatchIsNotAllowed]'
GO

CREATE PROCEDURE [dsperr].[ThrowBatchIsNotAllowed] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.BatchIsNotAllowedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[SetVerbose]'
GO
CREATE PROCEDURE [tSQLt].[SetVerbose]
  @Verbose BIT = 1
AS
BEGIN
  EXEC tSQLt.Private_SetConfiguration @Name = 'Verbose', @Value = @Verbose;
END;
GO
PRINT N'Creating [SQLCop].[test Procedures using dynamic SQL without sp_executesql]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures using dynamic SQL without sp_executesql]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/avoid-conversions-in-execution-plans-by-
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

	SELECT	@Output = @Output + SCHEMA_NAME(so.uid) + '.' + so.name + Char(13) + Char(10)
	From	sys.sql_modules sm
			Inner Join sys.sysobjects so
				On  sm.object_id = so.id
				And so.type = 'P'
	Where	so.uid <> Schema_Id('tSQLt')
			And so.uid <> Schema_Id('SQLCop')
			And Replace(sm.definition, ' ', '') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%Exec(%'
			And Replace(sm.definition, ' ', '') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Not Like '%sp_Executesql%'
			And OBJECTPROPERTY(so.id, N'IsMSShipped') = 0
	Order By SCHEMA_NAME(so.uid),so.name

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/avoid-conversions-in-execution-plans-by-'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
 
END;
GO
PRINT N'Creating [dsperr].[TooManyRequestId]'
GO

CREATE FUNCTION [dsperr].[TooManyRequestId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55018;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowTooManyRequest]'
GO

CREATE PROCEDURE [dsperr].[ThrowTooManyRequest] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.TooManyRequestId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [SQLCop].[test Procedures with @@Identity]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures with @@Identity]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/6_Different_Ways_To_Get_The_Current_Identity_Value
	
	SET NOCOUNT ON

	Declare @Output VarChar(max)
	Set @Output = ''

	Select	@Output = @Output + Schema_Name(schema_id) + '.' + name + Char(13) + Char(10)
	From	sys.all_objects
	Where	type = 'P'
			AND name Not In('sp_helpdiagrams','sp_upgraddiagrams','sp_creatediagram','testProcedures with @@Identity')
			And Object_Definition(object_id) COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%@@identity%'
			And is_ms_shipped = 0
			and schema_id <> Schema_id('tSQLt')
			and schema_id <> Schema_id('SQLCop')
	ORDER BY Schema_Name(schema_id), name 

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/6_Different_Ways_To_Get_The_Current_Identity_Value'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
	
END;
GO
PRINT N'Creating [dsperr].[AuthUserNotFoundId]'
GO

CREATE FUNCTION [dsperr].[AuthUserNotFoundId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55019;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowAuthUserNotFound]'
GO

CREATE PROCEDURE [dsperr].[ThrowAuthUserNotFound] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.AuthUserNotFoundId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_GetUniqueConstraintDefinition]'
GO
CREATE FUNCTION [tSQLt].[Private_GetUniqueConstraintDefinition]
(
    @ConstraintObjectId INT,
    @QuotedTableName NVARCHAR(MAX)
)
RETURNS TABLE
AS
RETURN
  SELECT 'ALTER TABLE '+
         @QuotedTableName +
         ' ADD CONSTRAINT ' +
         QUOTENAME(OBJECT_NAME(@ConstraintObjectId)) +
         ' ' +
         CASE WHEN KC.type_desc = 'UNIQUE_CONSTRAINT' 
              THEN 'UNIQUE'
              ELSE 'PRIMARY KEY'
           END +
         '(' +
         STUFF((
                 SELECT ','+QUOTENAME(C.name)
                   FROM sys.index_columns AS IC
                   JOIN sys.columns AS C
                     ON IC.object_id = C.object_id
                    AND IC.column_id = C.column_id
                  WHERE KC.unique_index_id = IC.index_id
                    AND KC.parent_object_id = IC.object_id
                    FOR XML PATH(''),TYPE
               ).value('.','NVARCHAR(MAX)'),
               1,
               1,
               ''
              ) +
         ');' AS CreateConstraintCmd,
         CASE WHEN KC.type_desc = 'UNIQUE_CONSTRAINT' 
              THEN ''
              ELSE (
                     SELECT 'ALTER TABLE ' +
                            @QuotedTableName +
                            ' ALTER COLUMN ' +
                            QUOTENAME(C.name)+
                            cc.ColumnDefinition +
                            ' NOT NULL;'
                       FROM sys.index_columns AS IC
                       JOIN sys.columns AS C
                         ON IC.object_id = C.object_id
                        AND IC.column_id = C.column_id
                      CROSS APPLY tSQLt.Private_GetDataTypeOrComputedColumnDefinition(C.user_type_id, C.max_length, C.precision, C.scale, C.collation_name, C.object_id, C.column_id, 0) cc
                      WHERE KC.unique_index_id = IC.index_id
                        AND KC.parent_object_id = IC.object_id
                        FOR XML PATH(''),TYPE
                   ).value('.','NVARCHAR(MAX)')
           END AS NotNullColumnCmd
    FROM sys.key_constraints AS KC
   WHERE KC.object_id = @ConstraintObjectId;
GO
PRINT N'Creating [tSQLt].[Private_ValidateProcedureCanBeUsedWithSpyProcedure]'
GO
CREATE PROCEDURE [tSQLt].[Private_ValidateProcedureCanBeUsedWithSpyProcedure]
    @ProcedureName NVARCHAR(MAX)
AS
BEGIN
    IF NOT EXISTS(SELECT 1 FROM sys.procedures WHERE object_id = OBJECT_ID(@ProcedureName))
    BEGIN
      RAISERROR('Cannot use SpyProcedure on %s because the procedure does not exist', 16, 10, @ProcedureName) WITH NOWAIT;
    END;
    
    IF (1020 < (SELECT COUNT(*) FROM sys.parameters WHERE object_id = OBJECT_ID(@ProcedureName)))
    BEGIN
      RAISERROR('Cannot use SpyProcedure on procedure %s because it contains more than 1020 parameters', 16, 10, @ProcedureName) WITH NOWAIT;
    END;
END;
GO
PRINT N'Creating [tSQLt].[SpyProcedure]'
GO
CREATE PROCEDURE [tSQLt].[SpyProcedure]
    @ProcedureName NVARCHAR(MAX),
    @CommandToExecute NVARCHAR(MAX) = NULL
AS
BEGIN
    DECLARE @ProcedureObjectId INT;
    SELECT @ProcedureObjectId = OBJECT_ID(@ProcedureName);

    EXEC tSQLt.Private_ValidateProcedureCanBeUsedWithSpyProcedure @ProcedureName;

    DECLARE @LogTableName NVARCHAR(MAX);
    SELECT @LogTableName = QUOTENAME(OBJECT_SCHEMA_NAME(@ProcedureObjectId)) + '.' + QUOTENAME(OBJECT_NAME(@ProcedureObjectId)+'_SpyProcedureLog');

    EXEC tSQLt.Private_RenameObjectToUniqueNameUsingObjectId @ProcedureObjectId;

    EXEC tSQLt.Private_CreateProcedureSpy @ProcedureObjectId, @ProcedureName, @LogTableName, @CommandToExecute;

    RETURN 0;
END;
GO
PRINT N'Creating [SQLCop].[test Procedures With SET ROWCOUNT]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures With SET ROWCOUNT]
AS
BEGIN
    -- Written by George Mastros
    -- February 25, 2012
    -- http://sqlcop.lessthandot.com
    -- http://sqltips.wordpress.com/2007/08/19/set-rowcount-will-not-be-supported-in-future-version-of-sql-server/
    
    SET NOCOUNT ON

    Declare @Output VarChar(max)
    Set @Output = ''
  
    SELECT	@Output = @Output + Schema_Name(schema_id) + '.' + name + Char(13) + Char(10)
    From	sys.all_objects
    Where	type = 'P'
            AND name Not In('sp_helpdiagrams','sp_upgraddiagrams','sp_creatediagram','testProcedures With SET ROWCOUNT')
            And Replace(Object_Definition(Object_id), ' ', '') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%SETROWCOUNT%'
            And is_ms_shipped = 0
            and schema_id <> Schema_id('tSQLt')
            and schema_id <> Schema_id('SQLCop')			
    ORDER BY Schema_Name(schema_id) + '.' + name

    If @Output > '' 
        Begin
            Set @Output = Char(13) + Char(10) 
                          + 'For more information:  '
                          + 'http://sqltips.wordpress.com/2007/08/19/set-rowcount-will-not-be-supported-in-future-version-of-sql-server/'
                          + Char(13) + Char(10) 
                          + Char(13) + Char(10) 
                          + @Output
            EXEC tSQLt.Fail @Output
        End
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_NotProcessed]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_NotProcessed] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dsperr].[DuplicateRequestExceptionId]'
GO

CREATE FUNCTION [dsperr].[DuplicateRequestExceptionId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55024;  
END
			
GO
PRINT N'Creating [dspInboxMessage].[InboxMessage_CreateBulk]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessage_CreateBulk]
    @ResultItems TJSON = NULL OUTPUT
AS
BEGIN
    -- It is for prompt
    IF (1 = 0)
    BEGIN
        CREATE TABLE #InboxMessage ([InboxMessageId] BIGINT NOT NULL,
            [MessageRefrenceNumber] NVARCHAR(MAX /*NCQ*/),
            [Address] NVARCHAR(MAX /*NCQ*/),
            [MessageBody] NVARCHAR(MAX /*NCQ*/),
            [MessageTime] DATETIME NOT NULL,
            [ProviderInfoId] [INT] NOT NULL,
            [InboxMessageDataSource1Id] BIGINT NULL,
            [CreatedTime] DATETIME NOT NULL,
            [ContactInfo] NVARCHAR(MAX /*NCQ*/),
            Error NVARCHAR(MAX /*NCQ*/));
    END;

    -- Consts
    DECLARE @InboxMessageProcessStateId TINYINT = dspconst.InboxMessageProcessState_NotProcessed();

    -- Declare variable to get inserted id 
    DECLARE @InsertedId TABLE (InboxMessageId BIGINT,
        MessageServerInboxNumber BIGINT);

    -- Check data duplicatation
    -- Use index 'IX_MessageServerInboxNumber'
    UPDATE  StageInbox
       SET  StageInbox.Error = dsp.Exception_BuildMessageParam4(
                                   @@PROCID, dsperr.DuplicateRequestExceptionId(), 'InboxMessage already exist', DEFAULT, DEFAULT, DEFAULT, DEFAULT)
      FROM  #InboxMessage StageInbox
            INNER JOIN dspInboxMessage.InboxMessage MainInbox ON MainInbox.MessageServerInboxNumber = StageInbox.InboxMessageId
     WHERE  StageInbox.Error IS NULL;

    -- Insert into my InboxMessage table
    BEGIN TRY
        INSERT INTO dspInboxMessage.InboxMessage (MessageRefrenceNumber, Address, MessageBody, MessageTime, ProviderInfoId, MessageServerCreatedTime,
            MessageServerInboxNumber, InboxMessageProcessStateId)
        OUTPUT Inserted.InboxMessageId, Inserted.MessageServerInboxNumber
        INTO @InsertedId (InboxMessageId, MessageServerInboxNumber)
        SELECT  MessageRefrenceNumber, Address, MessageBody, MessageTime, ProviderInfoId, CreatedTime, InboxMessageId, @InboxMessageProcessStateId
          FROM  #InboxMessage
         WHERE  Error IS NULL;
    END TRY
    BEGIN CATCH
        -- Update result json
        UPDATE  TIM
           SET  TIM.Error = dsp.Exception_BuildMessageParam4(@@PROCID, dsperr.InvalidOperationId(), ERROR_MESSAGE(), DEFAULT, DEFAULT, DEFAULT, DEFAULT)
          FROM  #InboxMessage TIM
         WHERE  TIM.Error IS NULL;
    END CATCH;

    -- Set all inpute data with status
    SET @ResultItems =
    (   SELECT      *
          FROM      (   SELECT  MessageServerInboxNumber = StageInbox.InboxMessageId, InboxMessageId = InsertedIds.InboxMessageId, StageInbox.Error
                          FROM  #InboxMessage StageInbox
                                LEFT OUTER JOIN @InsertedId InsertedIds ON InsertedIds.MessageServerInboxNumber = StageInbox.InboxMessageId) T
        FOR JSON AUTO);
END;
GO
PRINT N'Creating [dsperr].[InvokerAppVersionId]'
GO

CREATE FUNCTION [dsperr].[InvokerAppVersionId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55020;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowInvokerAppVersion]'
GO

CREATE PROCEDURE [dsperr].[ThrowInvokerAppVersion] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvokerAppVersionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Uninstall]'
GO
CREATE PROCEDURE [tSQLt].[Uninstall]
AS
BEGIN
  DROP TYPE tSQLt.Private;

  EXEC tSQLt.DropClass 'tSQLt';  
  
  DROP ASSEMBLY tSQLtCLR;
END;
GO
PRINT N'Creating [SQLCop].[test Procedures without SET NOCOUNT ON]'
GO
CREATE PROCEDURE [SQLCop].[test Procedures without SET NOCOUNT ON]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/Optimization:_Set_Nocount_On
	
	SET NOCOUNT ON

	Declare @Output VarChar(max)
	Set @Output = ''
  
	SELECT	@Output = @Output + Schema_Name(schema_id) + '.' + name + Char(13) + Char(10)
	From	sys.all_objects
	Where	Type = 'P'
			AND name Not In('sp_helpdiagrams','sp_upgraddiagrams','sp_creatediagram','testProcedures without SET NOCOUNT ON')
			And Object_Definition(Object_id) COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI not Like '%SET NOCOUNT ON%'
			And is_ms_shipped = 0
			and schema_id <> Schema_id('tSQLt')
			and schema_id <> Schema_id('SQLCop')			
	ORDER BY Schema_Name(schema_id) + '.' + name

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/Optimization:_Set_Nocount_On'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
						
END;
GO
PRINT N'Creating [dsperr].[MaintenanceId]'
GO

CREATE FUNCTION [dsperr].[MaintenanceId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55021;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowMaintenance]'
GO

CREATE PROCEDURE [dsperr].[ThrowMaintenance] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.MaintenanceId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [SQLCop].[test Service Account]'
GO
CREATE PROCEDURE [SQLCop].[test Service Account]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://msdn.microsoft.com/en-us/library/ms143504.aspx#Use_startup_accounts
	
    SET NOCOUNT ON

	Declare @Output VarChar(max)
	Set @Output = ''

    --Declare a variable to hold the value
    DECLARE @ServiceAccount varchar(100)

    --Retrieve the Service account from registry
    EXECUTE master.dbo.xp_instance_regread
            N'HKEY_LOCAL_MACHINE',
            N'SYSTEM\CurrentControlSet\Services\MSSQLSERVER',
            N'ObjectName',
            @ServiceAccount OUTPUT,
            N'no_output'

    --Display the Service Account
    SELECT @Output = 'Service account set to LocalSystem'
    Where  @ServiceAccount = 'LocalSystem'	
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://msdn.microsoft.com/en-us/library/ms143504.aspx#Use_startup_accounts'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
		
END;
GO
PRINT N'Creating [dsperr].[MaintenanceReadOnlyId]'
GO

CREATE FUNCTION [dsperr].[MaintenanceReadOnlyId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55022;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowMaintenanceReadOnly]'
GO

CREATE PROCEDURE [dsperr].[ThrowMaintenanceReadOnly] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.MaintenanceReadOnlyId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_PrintXML]'
GO
CREATE PROCEDURE [tSQLt].[Private_PrintXML]
    @Message XML
AS 
BEGIN
    SELECT @Message FOR XML PATH('');--Required together with ":XML ON" sqlcmd statement to allow more than 1mb to be returned
    RETURN 0;
END;
GO
PRINT N'Creating [tSQLt].[XmlResultFormatter]'
GO
CREATE PROCEDURE [tSQLt].[XmlResultFormatter]
AS
BEGIN
    DECLARE @XmlOutput XML;

    SELECT @XmlOutput = (
      SELECT *--Tag, Parent, [testsuites!1!hide!hide], [testsuite!2!name], [testsuite!2!tests], [testsuite!2!errors], [testsuite!2!failures], [testsuite!2!timestamp], [testsuite!2!time], [testcase!3!classname], [testcase!3!name], [testcase!3!time], [failure!4!message]  
        FROM (
          SELECT 1 AS Tag,
                 NULL AS Parent,
                 'root' AS [testsuites!1!hide!hide],
                 NULL AS [testsuite!2!id],
                 NULL AS [testsuite!2!name],
                 NULL AS [testsuite!2!tests],
                 NULL AS [testsuite!2!errors],
                 NULL AS [testsuite!2!failures],
                 NULL AS [testsuite!2!timestamp],
                 NULL AS [testsuite!2!time],
                 NULL AS [testsuite!2!hostname],
                 NULL AS [testsuite!2!package],
                 NULL AS [properties!3!hide!hide],
                 NULL AS [testcase!4!classname],
                 NULL AS [testcase!4!name],
                 NULL AS [testcase!4!time],
                 NULL AS [failure!5!message],
                 NULL AS [failure!5!type],
                 NULL AS [error!6!message],
                 NULL AS [error!6!type],
                 NULL AS [system-out!7!hide],
                 NULL AS [system-err!8!hide]
          UNION ALL
          SELECT 2 AS Tag, 
                 1 AS Parent,
                 'root',
                 ROW_NUMBER()OVER(ORDER BY Class),
                 Class,
                 COUNT(1),
                 SUM(CASE Result WHEN 'Error' THEN 1 ELSE 0 END),
                 SUM(CASE Result WHEN 'Failure' THEN 1 ELSE 0 END),
                 CONVERT(VARCHAR(19),MIN(TestResult.TestStartTime),126),
                 CAST(CAST(DATEDIFF(MILLISECOND,MIN(TestResult.TestStartTime),MAX(TestResult.TestEndTime))/1000.0 AS NUMERIC(20,3))AS VARCHAR(MAX)),
                 CAST(SERVERPROPERTY('ServerName') AS NVARCHAR(MAX)),
                 'tSQLt',
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
          GROUP BY Class
          UNION ALL
          SELECT 3 AS Tag,
                 2 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
           GROUP BY Class
          UNION ALL
          SELECT 4 AS Tag,
                 2 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 TestCase,
                 CAST(CAST(DATEDIFF(MILLISECOND,TestResult.TestStartTime,TestResult.TestEndTime)/1000.0 AS NUMERIC(20,3))AS VARCHAR(MAX)),
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
          UNION ALL
          SELECT 5 AS Tag,
                 4 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 TestCase,
                 CAST(CAST(DATEDIFF(MILLISECOND,TestResult.TestStartTime,TestResult.TestEndTime)/1000.0 AS NUMERIC(20,3))AS VARCHAR(MAX)),
                 Msg,
                 'tSQLt.Fail',
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
           WHERE Result IN ('Failure')
          UNION ALL
          SELECT 6 AS Tag,
                 4 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 TestCase,
                 CAST(CAST(DATEDIFF(MILLISECOND,TestResult.TestStartTime,TestResult.TestEndTime)/1000.0 AS NUMERIC(20,3))AS VARCHAR(MAX)),
                 NULL,
                 NULL,
                 Msg,
                 'SQL Error',
                 NULL,
                 NULL
            FROM tSQLt.TestResult
           WHERE Result IN ( 'Error')
          UNION ALL
          SELECT 7 AS Tag,
                 2 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
           GROUP BY Class
          UNION ALL
          SELECT 8 AS Tag,
                 2 AS Parent,
                 'root',
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 Class,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL,
                 NULL
            FROM tSQLt.TestResult
           GROUP BY Class
        ) AS X
       ORDER BY [testsuite!2!name],CASE WHEN Tag IN (7,8) THEN 1 ELSE 0 END, [testcase!4!name], Tag
       FOR XML EXPLICIT
       );

    EXEC tSQLt.Private_PrintXML @XmlOutput;
END;
GO
PRINT N'Creating [SQLCop].[test SMO and DMO]'
GO
CREATE PROCEDURE [SQLCop].[test SMO and DMO]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#SMO_and_DMO_XPs
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    select @Output = @Output + 'Status: SMO and DMO procedures are enabled' + Char(13) + Char(10)
    from   sys.configurations
    where  name = 'SMO and DMO XPs'
           and value_in_use = 1
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#SMO_and_DMO_XPs'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
		
END;
GO
PRINT N'Creating [dspInboxMessage].[Setting]'
GO
CREATE TABLE [dspInboxMessage].[Setting]
(
[SettingId] [int] NOT NULL,
[WaitExpirationTreshold] [int] NULL,
[ProcessRecordCount] [int] NULL,
[RefreshRecordCount] [int] NULL,
[FailedConfirmStepMessage] [nvarchar] (200) NULL,
[AddressRegistrationIsActive] [bit] NULL CONSTRAINT [DF__Setting__Address__21F7932D] DEFAULT ((0)),
[FaildConfirmActivationMessage] [nvarchar] (400) NULL
)
GO
PRINT N'Creating [dspInboxMessage].[Setting_GetProps]'
GO
--ALTER TABLE dspInboxMessage.Setting ADD FaildConfirmActivationMessage NVARCHAR(400)

CREATE PROCEDURE [dspInboxMessage].[Setting_GetProps]
    @WaitExpirationTreshold INT = NULL OUT, @RefreshRecordCount INT = NULL OUT, @ProcessRecordCount INT = NULL OUT,
    @FailedConfirmStepMessage TSTRING = NULL OUTPUT, @AddressRegistrationIsActive BIT = NULL OUTPUT, @FaildConfirmActivationMessage TSTRING = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    SELECT --
        @WaitExpirationTreshold = ISNULL(WaitExpirationTreshold, 300), --
        @RefreshRecordCount = ISNULL(RefreshRecordCount, 1000), --
        @ProcessRecordCount = ISNULL(ProcessRecordCount, 1000), --
        @FailedConfirmStepMessage = FailedConfirmStepMessage, --
        @AddressRegistrationIsActive = ISNULL(AddressRegistrationIsActive, 0), --
        @FaildConfirmActivationMessage = FaildConfirmActivationMessage --
      FROM  dspInboxMessage.Setting;

END;
GO
PRINT N'Creating [dsperr].[InvalidParamSignatureId]'
GO

CREATE FUNCTION [dsperr].[InvalidParamSignatureId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55023;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowInvalidParamSignature]'
GO

CREATE PROCEDURE [dsperr].[ThrowInvalidParamSignature] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.InvalidParamSignatureId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_ResolveApplyConstraintParameters]'
GO
CREATE FUNCTION [tSQLt].[Private_ResolveApplyConstraintParameters]
(
  @A NVARCHAR(MAX),
  @B NVARCHAR(MAX),
  @C NVARCHAR(MAX)
)
RETURNS TABLE
AS 
RETURN
  SELECT ConstraintObjectId, ConstraintType
    FROM tSQLt.Private_FindConstraint(OBJECT_ID(@A), @B)
   WHERE @C IS NULL
   UNION ALL
  SELECT *
    FROM tSQLt.Private_FindConstraint(OBJECT_ID(@A + '.' + @B), @C)
   UNION ALL
  SELECT *
    FROM tSQLt.Private_FindConstraint(OBJECT_ID(@C + '.' + @A), @B);
GO
PRINT N'Creating [dspAuth].[vw_RolePermission]'
GO
CREATE VIEW [dspAuth].[vw_RolePermission]
AS
SELECT  P.PermissionId, P.PermissionName, R.RoleId, R.RoleName, PG.PermissionGroupId, PG.PermissionGroupName, SD.SecurityDescriptorId, SD.ObjectTypeId,
    SD.ObjectId, ROSD.SecurityDescriptorId AS RoleOwnerSecurityDescriptorId, ROSD.ObjectTypeId AS RoleOwnerObjectTypeId, ROSD.ObjectId AS RoleOwnerObjectId
  FROM  dspAuth.Role AS R
        LEFT JOIN dspAuth.SecurityDescriptor AS ROSD ON ROSD.SecurityDescriptorId = R.OwnerSecurityDescriptorId
        LEFT JOIN dspAuth.SecurityDescriptorRolePermission AS SDRP ON SDRP.RoleId = R.RoleId
        LEFT JOIN dspAuth.SecurityDescriptor AS SD ON SD.SecurityDescriptorId = SDRP.SecurityDescriptorId
        LEFT JOIN dspAuth.PermissionGroup AS PG ON PG.PermissionGroupId = SDRP.PermissionGroupId
        LEFT JOIN dspAuth.PermissionGroupPermission AS PGP ON PGP.PermissionGroupId = PG.PermissionGroupId
        LEFT JOIN dspAuth.Permission AS P ON P.PermissionId = PGP.PermissionId;





GO
PRINT N'Creating [SQLCop].[test Table name problems]'
GO
CREATE PROCEDURE [SQLCop].[test Table name problems]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-spaces-or-other-invalid-chara
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
    DECLARE @AcceptableSymbols VARCHAR(100)

    SET @AcceptableSymbols = '_$'
	SET @Output = ''

	SELECT  @Output = @Output + TABLE_SCHEMA + '.' + TABLE_NAME + Char(13) + Char(10)
    FROM    INFORMATION_SCHEMA.TABLES
    WHERE   TABLE_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%[^a-z' + @AcceptableSymbols + ']%'
			AND TABLE_SCHEMA <> 'tSQLt'
	ORDER BY TABLE_SCHEMA,TABLE_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/do-not-use-spaces-or-other-invalid-chara' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [syn].[MessageServer_InboxMessageList]'
GO
CREATE SYNONYM [syn].[MessageServer_InboxMessageList] FOR [IcMessage].[api].[InboxMessage_List]
GO
PRINT N'Creating [dspInboxMessage].[InboxMessage_LastRefershInboxMessageNumber]'
GO
CREATE TABLE [dspInboxMessage].[InboxMessage_LastRefershInboxMessageNumber]
(
[LastRefershInboxMessageNumber] [bigint] NULL
)
GO
PRINT N'Creating [dspInboxMessage].[InboxMessage_Refresh]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessage_Refresh]
    @ApplicationId INT, @ResultItems TJSON = NULL OUTPUT
AS
BEGIN
    DECLARE @Context TCONTEXT = '$$';
    DECLARE @FilterInboxMessageIdFrom BIGINT;
    DECLARE @ErrorMessage TSTRING;

    -- Get @RefreshRecordCount from setting
    DECLARE @RefreshRecordCount INT;
    EXEC dspInboxMessage.Setting_GetProps @RefreshRecordCount = @RefreshRecordCount OUTPUT;

    CREATE TABLE #InboxMessage ([InboxMessageId] BIGINT NOT NULL,
        [MessageRefrenceNumber] NVARCHAR(MAX /*NCQ*/),
        [Address] NVARCHAR(MAX /*NCQ*/),
        [MessageBody] NVARCHAR(MAX /*NCQ*/),
        [MessageTime] DATETIME NOT NULL,
        [ProviderInfoId] [INT] NOT NULL,
        [InboxMessageDataSource1Id] BIGINT NULL,
        [CreatedTime] DATETIME NOT NULL,
        [ContactInfo] NVARCHAR(MAX /*NCQ*/),
        Error NVARCHAR(MAX /*NCQ*/));

    WHILE (1 = 1)
    BEGIN
        -- Get data from InboxMessage_LastRefershTime
        SET @FilterInboxMessageIdFrom = (   SELECT LastRefershInboxMessageNumber
                                           FROM dspInboxMessage.InboxMessage_LastRefershInboxMessageNumber);

        SET @FilterInboxMessageIdFrom = ISNULL(@FilterInboxMessageIdFrom, 0);

        -- Call syn to get data
        BEGIN TRY
            TRUNCATE TABLE #InboxMessage;

            INSERT INTO #InboxMessage (InboxMessageId, MessageRefrenceNumber, Address, MessageBody, MessageTime, ProviderInfoId, InboxMessageDataSource1Id,
                CreatedTime, ContactInfo)
            EXEC syn.MessageServer_InboxMessageList @Context = @Context OUTPUT, @ApplicationId = @ApplicationId,
                @FilterInboxMessageIdFrom = @FilterInboxMessageIdFrom, @RequestRecordCount = @RefreshRecordCount;

            -- If no new data available then exit
            IF NOT EXISTS (SELECT   * FROM  #InboxMessage)
                BREAK;
        END TRY
        BEGIN CATCH
            -- Update InboxMessage_LastRefershInboxMessageNumber table with max MessageServerInboxMessageId
            UPDATE  dspInboxMessage.InboxMessage_LastRefershInboxMessageNumber
               SET  LastRefershInboxMessageNumber = (SELECT MAX(InboxMessageId) FROM    #InboxMessage);

            SET @ErrorMessage = ERROR_MESSAGE();
            EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = @ErrorMessage;
        END CATCH;

        -- Call create bulk
        DECLARE @TranCount INT = @@TRANCOUNT;
        IF (@TranCount = 0)
            BEGIN TRANSACTION;
        BEGIN TRY
            EXEC dspInboxMessage.InboxMessage_CreateBulk @ResultItems = @ResultItems OUTPUT;

            -- Update InboxMessage_LastRefershInboxMessageNumber
            UPDATE  dspInboxMessage.InboxMessage_LastRefershInboxMessageNumber
               SET  LastRefershInboxMessageNumber = (SELECT MAX(InboxMessageId) FROM    #InboxMessage);

            IF (@TranCount = 0) COMMIT;
        END TRY
        BEGIN CATCH
            IF (@TranCount = 0)
                ROLLBACK TRANSACTION;

            SET @ErrorMessage = ERROR_MESSAGE();
            EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
        END CATCH;
    END;
END;
GO
PRINT N'Creating [dsperr].[ThrowDuplicateRequestException]'
GO

CREATE PROCEDURE [dsperr].[ThrowDuplicateRequestException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.DuplicateRequestExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspInboxMessage].[vw_ProviderInfo]'
GO
CREATE  VIEW [dspInboxMessage].[vw_ProviderInfo]
WITH SCHEMABINDING
AS
SELECT  PI.ProviderInfoId, PI.ProviderId, PI.ContactInfo, PI.IsEnable, PI.Description, P.ProviderName, P.ProviderTypeId, P.IsEnable AS ProviderIsEnable
  FROM  dspInboxMessage.ProviderInfo PI
        INNER JOIN dspInboxMessage.Provider P ON P.ProviderId = PI.ProviderId;
GO
PRINT N'Creating [const].[UserName_App]'
GO
CREATE FUNCTION [const].[UserName_App]()
RETURNS TSTRING
AS
BEGIN
    RETURN 'Log_App';
END
GO
PRINT N'Creating [SQLCop].[test Tables that start with tbl]'
GO
CREATE PROCEDURE [SQLCop].[test Tables that start with tbl]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/don-t-prefix-your-table-names-with-tbl
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

    SELECT	@Output = @Output + TABLE_SCHEMA + '.' + TABLE_NAME + Char(13) + Char(10)
    From	INFORMATION_SCHEMA.TABLES
    WHERE	TABLE_TYPE = 'BASE TABLE'
			And TABLE_NAME COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI LIKE 'tbl%'
			And TABLE_SCHEMA <> 'tSQLt'
    Order By TABLE_SCHEMA,TABLE_NAME		

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/don-t-prefix-your-table-names-with-tbl' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End  
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$CheckCustomConfirmValueActivation]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$CheckCustomConfirmValueActivation]
    @ProviderInfoId INT, @Address TSTRING, @IsActive BIT OUTPUT
AS
BEGIN
    -- It must be overwrite by client
    BEGIN TRY
        EXEC InboxMessage.InboxMessageProcess_CheckCustomConfirmValueActivation @ProviderInfoId = @ProviderInfoId, @Address = @Address,
            @IsActive = @IsActive OUTPUT;
    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;
END;
GO
PRINT N'Creating [dsperr].[HasNotSameStrcutreId]'
GO

CREATE FUNCTION [dsperr].[HasNotSameStrcutreId]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 55025;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowHasNotSameStrcutre]'
GO

CREATE PROCEDURE [dsperr].[ThrowHasNotSameStrcutre] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.HasNotSameStrcutreId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Tests]'
GO
CREATE VIEW [tSQLt].[Tests]
AS
  SELECT classes.SchemaId, classes.Name AS TestClassName, 
         procs.object_id AS ObjectId, procs.name AS Name
    FROM tSQLt.TestClasses classes
    JOIN sys.procedures procs ON classes.SchemaId = procs.schema_id
   WHERE LOWER(procs.name) LIKE 'test%';
GO
PRINT N'Creating [const].[UserName_System]'
GO
CREATE FUNCTION [const].[UserName_System]()
RETURNS TSTRING
AS
BEGIN
    RETURN 'Log_System';
END
GO
PRINT N'Creating [SQLCop].[test Tables without a primary key]'
GO
CREATE PROCEDURE [SQLCop].[test Tables without a primary key]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/best-practice-every-table-should-have-a
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT	@Output = @Output + su.name + '.' + AllTables.Name + Char(13) + Char(10)
	FROM	(
			SELECT	Name, id, uid
			From	sysobjects
			WHERE	xtype = 'U'
			) AS AllTables
			INNER JOIN sysusers su
				On AllTables.uid = su.uid
			LEFT JOIN (
				SELECT parent_obj
				From sysobjects
				WHERE  xtype = 'PK'
				) AS PrimaryKeys
				ON AllTables.id = PrimaryKeys.parent_obj
	WHERE	PrimaryKeys.parent_obj Is Null
			AND su.name <> 'tSQLt'
	ORDER BY su.name,AllTables.Name

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/best-practice-every-table-should-have-a' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	
END;
GO
PRINT N'Creating [dspconst].[WaitForReplyMessageState_NotProcess]'
GO
CREATE FUNCTION [dspconst].[WaitForReplyMessageState_NotProcess] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$CreateWaitForReplyMessage]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$CreateWaitForReplyMessage]
    @Address TSTRING, @MessagePatternStepId INT, @MessageLastData TJSON, @ProviderInfoId INT, @WaitForReplyMessageId BIGINT = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    INSERT INTO dspInboxMessage.WaitForReplyMessage (Address, MessagePatternStepId, MessageLastData, WaitForReplyMessageStateId, ProviderInfoId)
    VALUES (@Address, @MessagePatternStepId, @MessageLastData, dspconst.WaitForReplyMessageState_NotProcess(), @ProviderInfoId);

    SET @WaitForReplyMessageId = SCOPE_IDENTITY();
END;
GO
PRINT N'Creating [dsperr].[ThrowGeneralException]'
GO

CREATE PROCEDURE [dsperr].[ThrowGeneralException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.GeneralExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [const].[UserName_SystemAdmin]'
GO
CREATE FUNCTION [const].[UserName_SystemAdmin]()
RETURNS TSTRING
AS
BEGIN
    RETURN 'Log_Admin';
END
 
GO
PRINT N'Creating [SQLCop].[test Tables without any data]'
GO
CREATE PROCEDURE [SQLCop].[test Tables without any data]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/List_all_empty_tables_in_your_SQL_Server_database
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	CREATE TABLE #EmptyTables(Table_Name VarChar(100))  
	EXEC 	sp_MSforeachtable 'IF NOT EXISTS(SELECT 1 FROM ?) INSERT INTO #EmptyTables VALUES(''?'')' 
	SELECT	@Output = @Output + Table_Name + Char(13) + Char(10)
	FROM	#EmptyTables 
	Where	Left(Table_Name, 7) <> '[tSQLt]'
	ORDER BY Table_Name 
	DROP TABLE #EmptyTables

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/List_all_empty_tables_in_your_SQL_Server_database' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$SendReplyMessage]'
GO

CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$SendReplyMessage]
    @ProviderInfoId BIGINT, @Address TSTRING, @SendMessageValue TSTRING, @MessagePatternStepId INT
AS
BEGIN
    -- It must be overwrite by client
    BEGIN TRY
        EXEC InboxMessage.InboxMessageProcess_SendReplyMessage @ProviderInfoId = @ProviderInfoId, @Address = @Address, @SendMessageValue = @SendMessageValue,
            @MessagePatternStepId = @MessagePatternStepId;
    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;
END;
GO
PRINT N'Creating [DatabaseVersioning].[Table_HasColumnName]'
GO
CREATE   FUNCTION [DatabaseVersioning].[Table_HasColumnName] (@ObjectId INT,
    @ColumName TSTRING)
RETURNS TABLE
AS
RETURN SELECT TOP 1 1 AS HasColumn
         FROM   sys.columns AS C
        WHERE   C.object_id = @ObjectId --
           AND  C.name = @ColumName;
GO
PRINT N'Creating [SQLCop].[test UniqueIdentifier with NewId]'
GO
CREATE PROCEDURE [SQLCop].[test UniqueIdentifier with NewId]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/best-practice-don-t-not-cluster-on-uniqu
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT  @Output = @Output + so.name + '.' + col.name + Char(13) + Char(10)
	FROM    sysobjects so
			INNER JOIN sysindexes sind
				ON so.id=sind.id
			INNER JOIN sysindexkeys sik
				ON sind.id=sik.id
				AND sind.indid=sik.indid
			INNER JOIN syscolumns col
				ON col.id=sik.id
				AND col.colid=sik.colid
			INNER JOIN systypes
				ON col.xtype = systypes.xtype
			INNER JOIN syscomments
				ON col.cdefault = syscomments.id
	WHERE	sind.Status & 16 = 16
			AND systypes.name = 'uniqueidentifier'
			AND keyno = 1
			AND sind.OrigFillFactor = 0
			AND syscomments.TEXT COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%newid%'
			and so.name <> 'tSQLt'
	ORDER BY so.name, sik.keyno

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/best-practice-don-t-not-cluster-on-uniqu' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
END;
GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_$MessagePatternStepItems]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_$MessagePatternStepItems]
    @MessagePatternId INT, @StepItems TJSON = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    SET @StepItems =
    (   SELECT  MessagePatternStepId, MessagePatternId, MessagePatternStepTypeId, ParameterName, SendMessageValue, [Order], DefaultValue, Description,
            ConfirmHasCustomValidation, HasCustomValue
          FROM  dspInboxMessage.MessagePatternStep
         WHERE MessagePatternId = @MessagePatternId AND [Order] > 0
         ORDER BY [Order]
        FOR JSON AUTO, INCLUDE_NULL_VALUES);
END;
GO
PRINT N'Creating [dsperr].[ThrowUnHandledException]'
GO

CREATE PROCEDURE [dsperr].[ThrowUnHandledException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.UnHandledExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[Private_SysIndexes]'
GO
CREATE VIEW [tSQLt].[Private_SysIndexes] AS SELECT * FROM sys.indexes;
GO
PRINT N'Creating [tSQLt].[Private_ScriptIndex]'
GO
CREATE FUNCTION [tSQLt].[Private_ScriptIndex]
(
  @object_id INT,
  @index_id INT
)
RETURNS TABLE
AS
RETURN
  SELECT I.index_id,
         I.name AS index_name,
         I.is_primary_key,
         I.is_unique,
         I.is_disabled,
         'CREATE ' +
         CASE WHEN I.is_unique = 1 THEN 'UNIQUE ' ELSE '' END +
         CASE I.type
           WHEN 1 THEN 'CLUSTERED'
           WHEN 2 THEN 'NONCLUSTERED'
           WHEN 5 THEN 'CLUSTERED COLUMNSTORE'
           WHEN 6 THEN 'NONCLUSTERED COLUMNSTORE'
           ELSE '{Index Type Not Supported!}' 
         END +
         ' INDEX ' +
         QUOTENAME(I.name)+
         ' ON ' + QUOTENAME(OBJECT_SCHEMA_NAME(@object_id)) + '.' + QUOTENAME(OBJECT_NAME(@object_id)) +
         CASE WHEN I.type NOT IN (5)
           THEN
             '('+ 
             CL.column_list +
             ')'
           ELSE ''
         END +
         CASE WHEN I.has_filter = 1
           THEN 'WHERE' + I.filter_definition
           ELSE ''
         END +
         CASE WHEN I.is_hypothetical = 1
           THEN 'WITH(STATISTICS_ONLY = -1)'
           ELSE ''
         END +
         ';' AS create_cmd
    FROM tSQLt.Private_SysIndexes AS I
   CROSS APPLY
   (
     SELECT
      (
        SELECT 
          CASE WHEN OIC.rn > 1 THEN ',' ELSE '' END +
          CASE WHEN OIC.rn = 1 AND OIC.is_included_column = 1 AND I.type NOT IN (6) THEN ')INCLUDE(' ELSE '' END +
          QUOTENAME(OIC.name) +
          CASE WHEN OIC.is_included_column = 0
            THEN CASE WHEN OIC.is_descending_key = 1 THEN 'DESC' ELSE 'ASC' END
            ELSE ''
          END
          FROM
          (
            SELECT C.name,
                   IC.is_descending_key, 
                   IC.key_ordinal,
                   IC.is_included_column,
                   ROW_NUMBER()OVER(PARTITION BY IC.is_included_column ORDER BY IC.key_ordinal, IC.index_column_id) AS rn
              FROM sys.index_columns AS IC
              JOIN sys.columns AS C
                ON IC.column_id = C.column_id
               AND IC.object_id = C.object_id
             WHERE IC.object_id = I.object_id
               AND IC.index_id = I.index_id
          )OIC
         ORDER BY OIC.is_included_column, OIC.rn
           FOR XML PATH(''),TYPE
      ).value('.','NVARCHAR(MAX)') AS column_list
   )CL
   WHERE I.object_id = @object_id
     AND I.index_id = ISNULL(@index_id,I.index_id);
GO
PRINT N'Creating [DatabaseVersioning].[Table_HasExtendedProperty]'
GO
CREATE FUNCTION [DatabaseVersioning].[Table_HasExtendedProperty] (@ObjectId INT,
    @ExtendedPropertyName TSTRING,
    @ExtendedPropertyValue NVARCHAR(MAX)/*NQC*/)
RETURNS TABLE
AS
RETURN SELECT TOP 1 1 AS HasExtendedProperty
         FROM   sys.extended_properties AS EP
        WHERE   EP.major_id = @ObjectId --
           AND  EP.name = @ExtendedPropertyName AND CAST(EP.value AS NVARCHAR(MAX)/*NQC*/) = @ExtendedPropertyValue;
GO
PRINT N'Creating [SQLCop].[test Unnamed Constraints]'
GO
CREATE PROCEDURE [SQLCop].[test Unnamed Constraints]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/how-to-name-default-constraints-and-how-
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT	@Output = @Output + CONSTRAINT_SCHEMA + '.' + CONSTRAINT_NAME + Char(13) + Char(10)
	From	INFORMATION_SCHEMA.CONSTRAINT_TABLE_USAGE
	Where	CONSTRAINT_NAME collate sql_latin1_general_CP1_CI_AI Like '%[_][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f][0-9a-f]'
			And TABLE_NAME <> 'sysdiagrams'
			And CONSTRAINT_SCHEMA <> 'tSQLt'
	Order By CONSTRAINT_SCHEMA,CONSTRAINT_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/how-to-name-default-constraints-and-how-' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
		
END;
GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_GetProps]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_GetProps]
    @MessagePatternId INT = NULL, @PatternName TSTRING = NULL OUTPUT, @StartTime DATETIME = NULL OUTPUT, @ExpirationTime DATETIME = NULL OUTPUT,
    @MessagePatternSepratorId INT = NULL OUTPUT, @ResponseProcedureSchemaName TSTRING = NULL OUTPUT, @ResponseProcedureName TSTRING = NULL OUTPUT,
    @PatternKey TSTRING = NULL OUTPUT, @MessagePatternStateId INT = NULL OUTPUT, @Description TSTRING = NULL OUTPUT, @StepItems TJSON = NULL OUTPUT,
    @MessagePatternSeprator TSTRING = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @ActualPatternId INT;

    -- Get Data
    SELECT  @ActualPatternId = MP.MessagePatternId, @PatternName = MP.PatternName, @StartTime = MP.StartTime, @ExpirationTime = MP.ExpirationTime,
        @MessagePatternSepratorId = MP.MessagePatternSepratorId, @ResponseProcedureSchemaName = MP.ResponseProcedureSchemaName,
        @ResponseProcedureName = MP.ResponseProcedureName, @PatternKey = MP.PatternKey, @MessagePatternStateId = MP.MessagePatternStateId,
        @Description = [MP].[Description], @MessagePatternSeprator = MPS.MessagePatternSeprator
      FROM  dspInboxMessage.vw_MessagePattern MP
            INNER JOIN dspInboxMessage.MessagePatternSeprator MPS ON MPS.MessagePatternSepratorId = MP.MessagePatternSepratorId
     WHERE  MP.MessagePatternId = @MessagePatternId;

    IF (@ActualPatternId IS NULL) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = 'ActualPatternId IS NULL';

    -- Get steps data
    EXEC dspInboxMessage.[MessagePattern_$MessagePatternStepItems] @MessagePatternId = @MessagePatternId, @StepItems = @StepItems OUTPUT;
END;

GO
PRINT N'Creating [tSQLt].[TestCaseSummary]'
GO
CREATE FUNCTION [tSQLt].[TestCaseSummary]()
RETURNS TABLE
AS
RETURN WITH A(Cnt, SuccessCnt, FailCnt, ErrorCnt) AS (
                SELECT COUNT(1),
                       ISNULL(SUM(CASE WHEN Result = 'Success' THEN 1 ELSE 0 END), 0),
                       ISNULL(SUM(CASE WHEN Result = 'Failure' THEN 1 ELSE 0 END), 0),
                       ISNULL(SUM(CASE WHEN Result = 'Error' THEN 1 ELSE 0 END), 0)
                  FROM tSQLt.TestResult
                  
                )
       SELECT 'Test Case Summary: ' + CAST(Cnt AS NVARCHAR) + ' test case(s) executed, '+
                  CAST(SuccessCnt AS NVARCHAR) + ' succeeded, '+
                  CAST(FailCnt AS NVARCHAR) + ' failed, '+
                  CAST(ErrorCnt AS NVARCHAR) + ' errored.' Msg,*
         FROM A;
GO
PRINT N'Creating [SQLCop].[test User Aliases]'
GO
CREATE PROCEDURE [SQLCop].[test User Aliases]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://www.mssqltips.com/tip.asp?tip=1675
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
    Set @Output = ''

    Select @Output = @Output + Name + Char(13) + Char(10)
    From   sysusers 
    Where  IsAliased = 1 
    Order By Name
        
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://www.mssqltips.com/tip.asp?tip=1675'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_GetProps]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePatternStep_GetProps]
    @MessagePatternStepId INT, @MessagePatternId INT = NULL OUTPUT, @MessagePatternStepTypeId INT = NULL OUTPUT, @ParameterName TSTRING = NULL OUTPUT,
    @SendMessageValue TSTRING = NULL OUTPUT, @Order INT = NULL OUTPUT, @DefaultValue TSTRING = NULL OUTPUT, @Description TSTRING = NULL OUTPUT,
    @ConfirmHasCustomValidation BIT = NULL OUTPUT, @HasCustomValue BIT = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @ActualStepId INT;

    --Get ApiId from local data
    SELECT  @ActualStepId = MessagePatternStepId, @MessagePatternId = MessagePatternId, @MessagePatternStepTypeId = MessagePatternStepTypeId,
        @ParameterName = ParameterName, @SendMessageValue = SendMessageValue, @Order = [Order], @DefaultValue = DefaultValue, @Description = [Description],
        @ConfirmHasCustomValidation = ConfirmHasCustomValidation, @HasCustomValue = HasCustomValue
      FROM  dspInboxMessage.MessagePatternStep
     WHERE  MessagePatternStepId = @MessagePatternStepId;

    IF (@ActualStepId IS NULL) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID;
END;

GO
PRINT N'Creating [dsperr].[Error1Id]'
GO

CREATE FUNCTION [dsperr].[Error1Id]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 56001;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowError1]'
GO

CREATE PROCEDURE [dsperr].[ThrowError1] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.Error1Id();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [api].[$$ResponseProcedureName1$$]'
GO

		CREATE   PROCEDURE [api].[$$ResponseProcedureName1$$] 
			@Contect TCONTEXT = NULL, @Input TSTRING, @InputOutput TSTRING OUTPUT, @Output TSTRING OUTPUT, @DefaultValue TSTRING OUTPUT 
		AS 
		BEGIN 
			PRINT 'Succefully test procedure excute ;)' 
			PRINT '	@Input: ' + ISNULL(@Input,'NULL')
			PRINT '	@InputOutput: ' + ISNULL(@InputOutput,'NULL')
			PRINT '	@Output: ' + ISNULL(@Output,'NULL')
			PRINT '	@DefaultValue: ' + ISNULL(@DefaultValue,'NULL')
		END
GO
PRINT N'Creating [SQLCop].[test Varchar Size Problem]'
GO
CREATE PROCEDURE [SQLCop].[test Varchar Size Problem]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/always-include-size-when-using-varchar-n
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

	Select	@Output = @Output + ProblemItem + Char(13) + Char(10)
	From	(
			SELECT	DISTINCT su.name + '.' + so.Name As ProblemItem
			From	syscomments sc
					Inner Join sysobjects so
						On  sc.id = so.id
						And so.xtype = 'P'
					INNER JOIN sys.schemas su
						ON so.uid = su.schema_id
			Where	REPLACE(Replace(sc.text, ' ', ''), 'varchar]','varchar') COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI Like '%varchar[^(]%'
					And ObjectProperty(sc.Id, N'IsMSSHIPPED') = 0
					And su.schema_id <> schema_id('tSQLt')
					and su.schema_id <> Schema_id('SQLCop')
			) As Problems
	Order By ProblemItem

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DBProgramming/MSSQLServer/always-include-size-when-using-varchar-n' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End
		  
END;
GO
PRINT N'Creating [dsperr].[Error2Id]'
GO

CREATE FUNCTION [dsperr].[Error2Id]()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN 56002;  
END
			
GO
PRINT N'Creating [dsperr].[ThrowError2]'
GO

CREATE PROCEDURE [dsperr].[ThrowError2] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.Error2Id();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [SQLCop].[test Views with order by]'
GO
CREATE PROCEDURE [SQLCop].[test Views with order by]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/create-a-sorted-view-in-sql-server-2005--2008
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	SELECT	@Output = @Output + sysusers.name + '.' + sysobjects.name + Char(13) + Char(10)
	FROM	sysobjects
			INNER JOIN syscomments
			  ON sysobjects.id = syscomments.id
			INNER JOIN sysusers
			  ON sysobjects.uid = sysusers.uid
	WHERE	xtype = 'V'
			and syscomments.text COLLATE SQL_LATIN1_GENERAL_CP1_CI_AI like '%order by%'
			and sysusers.name <> 'tSQLt'
	ORDER BY sysusers.name,sysobjects.name

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://blogs.lessthandot.com/index.php/DataMgmt/DataDesign/create-a-sorted-view-in-sql-server-2005--2008' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	  
END;
GO
PRINT N'Creating [SQLCop].[test Wide Table]'
GO
CREATE PROCEDURE [SQLCop].[test Wide Table]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_wide_table_check
	
	SET NOCOUNT ON
	
	DECLARE @Output VarChar(max)
	SET @Output = ''

	Select  @Output = @Output + C.TABLE_SCHEMA + '.' + C.TABLE_NAME + Char(13) + Char(10)
	From    INFORMATION_SCHEMA.TABLES T
			INNER JOIN INFORMATION_SCHEMA.COLUMNS C
			  On  T.TABLE_NAME = C.TABLE_NAME
			  AND T.TABLE_SCHEMA = C.TABLE_SCHEMA
			  And T.TABLE_TYPE = 'BASE TABLE'
			INNER JOIN systypes S
				On C.DATA_TYPE = S.name
	WHERE   C.TABLE_SCHEMA <> 'tSQLt'
	GROUP BY C.TABLE_SCHEMA,C.TABLE_NAME
	HAVING SUM(ISNULL(NULLIF(CONVERT(BIGINT,S.Length), 8000), 0) + ISNULL(NULLIF(C.CHARACTER_MAXIMUM_LENGTH, 2147483647), 0)) > 8060
	ORDER BY C.TABLE_SCHEMA,C.TABLE_NAME

	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_wide_table_check' 
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End	
END;
GO
PRINT N'Creating [dsp].[Message_CommonExceptionFormat]'
GO
CREATE FUNCTION [dsp].[Message_CommonExceptionFormat] (@ProcId INT,
    @Message TSTRING)
RETURNS TJSON
AS
BEGIN
    DECLARE @Exception TJSON;
    DECLARE @ExceptionId INT = IIF(ISJSON(@Message) = 1, JSON_VALUE(@Message, '$.errorId'), NULL);

    IF (@ExceptionId IS NOT NULL)
        SET @Exception = @Message;
    ELSE
        SET @Exception = dsp.Exception_BuildMessageParam4(@ProcId, dsperr.UnHandledExceptionId(), @Message, DEFAULT, DEFAULT, DEFAULT, DEFAULT);

    RETURN @Exception;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_ExecResponseProcedureFaild]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_ExecResponseProcedureFaild]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 7;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessKeyTag_ParameterSpecification]'
GO
CREATE FUNCTION [dspInboxMessage].[InboxMessageProcessKeyTag_ParameterSpecification] ()
RETURNS NVARCHAR(50)
WITH SCHEMABINDING
AS
BEGIN
    RETURN 'ParameterSpecification';
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessKeyTag_NullExpression]'
GO
CREATE FUNCTION [dspInboxMessage].[InboxMessageProcessKeyTag_NullExpression] ()
RETURNS NVARCHAR(10)
WITH SCHEMABINDING
AS
BEGIN
    RETURN '<NULL>';
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$DoRunResponseProcedure]'
GO
/*
	Sample Data
	ParameterSpecification	[{"ParamName":"Input","ParamType":"Input","ParameterValue":"Sended_InputParameterValue_from_consumer"}]
	ParameterSpecification	[{"ParamName":"InputOutput","ParamType":"Output","ParameterValue":"Sended_InputOutputParameterValue_from_consumer"}]
	ParameterSpecification	[{"ParamName":"Output","ParamType":"Output"}]
	ParameterSpecification	[{"ParamName":"DefaultValue","ParamType":"Input","ParameterValue":"DefaultValue"}]
	*/
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$DoRunResponseProcedure]
    @MessageLastData TJSON, @ProviderInfoId INT, @Address TSTRING, @SendMessageValue TSTRING, @MessagePatternStepId INT,
    @InboxMessageProcessStateId INT = NULL OUTPUT, @ErrorMessage TSTRING = NULL OUTPUT
AS
BEGIN
    -- Consts
    DECLARE @Tag_ParameterSpecification TSTRING = dspInboxMessage.InboxMessageProcessKeyTag_ParameterSpecification();
    DECLARE @NullExpression TSTRING = dspInboxMessage.InboxMessageProcessKeyTag_NullExpression();

    DECLARE @SQL TSTRING;
    DECLARE @ResponseProcedureSchemaName TSTRING;
    DECLARE @ResponseProcedureName TSTRING;
    DECLARE @DeclarePart TSTRING = '';
    DECLARE @CallParameterPart TSTRING = '';
    DECLARE @SelectParamAfterExec TSTRING = '';

    -- Generate DeclarePart, CallParameterPart, SelectParamAfterExec
    SELECT  @DeclarePart =
        @DeclarePart + ' DECLARE @' + JSON_VALUE(MsgValue, '$.ParamName') + ' TSTRING '
        + CASE
              WHEN JSON_VALUE(MsgValue, '$.ParamValue') IS NOT NULL
                  THEN ' = ' + CASE JSON_VALUE(MsgValue, '$.ParamValue')
                                   WHEN @NullExpression
                                       THEN 'NULL' ELSE QUOTENAME(JSON_VALUE(MsgValue, '$.ParamValue'), '''')
                               END ELSE ''
          END + CHAR(13),
        @CallParameterPart =
            @CallParameterPart + ', @' + JSON_VALUE(MsgValue, '$.ParamName') + ' = @' + JSON_VALUE(MsgValue, '$.ParamName')
            + CASE
                  WHEN JSON_VALUE(MsgValue, '$.ParamType') = 'Output'
                      THEN ' OUTPUT' ELSE ''
              END,
        @SelectParamAfterExec =
            @SelectParamAfterExec + CASE
                                        WHEN JSON_VALUE(MsgValue, '$.ParamType') = 'Output'
                                            THEN ', @' + JSON_VALUE(MsgValue, '$.ParamName') + ' AS ' + JSON_VALUE(MsgValue, '$.ParamName') ELSE ''
                                    END
      FROM  dspInboxMessage.MessageLastData_ReadJson(@MessageLastData)
     WHERE  MsgKey = @Tag_ParameterSpecification;

    -- Prepare @CallParameterPart
    SET @CallParameterPart = LTRIM(RTRIM(@CallParameterPart));
    SET @CallParameterPart = RIGHT(@CallParameterPart, LEN(@CallParameterPart) - 1);

    -- Prepare @CallParameterPart
    SET @SelectParamAfterExec = LTRIM(RTRIM(@SelectParamAfterExec));
    IF @SelectParamAfterExec <> ''
        SET @SelectParamAfterExec = RIGHT(@SelectParamAfterExec, LEN(@SelectParamAfterExec) - 1);
    IF @SelectParamAfterExec <> ''
        SET @SelectParamAfterExec = CHAR(13) + ' SELECT ' + @SelectParamAfterExec;

    -- Get ResponseProcedureSchemaName and ResponseProcedureName
    DECLARE @MessagePatternId INT;
    EXEC dspInboxMessage.MessagePatternStep_GetProps @MessagePatternStepId = @MessagePatternStepId, @MessagePatternId = @MessagePatternId OUTPUT;
    EXEC dspInboxMessage.MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @ResponseProcedureSchemaName = @ResponseProcedureSchemaName OUTPUT,
        @ResponseProcedureName = @ResponseProcedureName OUTPUT;

    -- Prepare query for call response procedure with last data and call it
    SET @SQL = @DeclarePart + 'EXECUTE ' + @ResponseProcedureSchemaName + '.' + @ResponseProcedureName + @CallParameterPart; --+ @SelectParamAfterExec;

    IF LTRIM(RTRIM(ISNULL(@SQL, ''))) = ''
    BEGIN
        SET @ErrorMessage = 'Do not valid SQL command generated';
        SET @InboxMessageProcessStateId = dspconst.InboxMessageProcessState_ExecResponseProcedureFaild();
        RETURN;
    END;

    BEGIN TRY
        EXEC (@SQL);
    END TRY
    BEGIN CATCH
        SET @ErrorMessage = dsp.Message_CommonExceptionFormat(@@PROCID, ERROR_MESSAGE());
        SET @InboxMessageProcessStateId = dspconst.InboxMessageProcessState_ExecResponseProcedureFaild();
        RETURN;
    END CATCH;

    -- Send message if exec successfuly and step has send message expression
    IF (@SendMessageValue IS NOT NULL)
        EXEC dspInboxMessage.[InboxMessageProcess_$SendReplyMessage] @ProviderInfoId = @ProviderInfoId, @Address = @Address,
            @SendMessageValue = @SendMessageValue, @MessagePatternStepId = @MessagePatternStepId;

END;

GO
PRINT N'Creating [SQLCop].[test xp_cmdshell is enabled]'
GO
CREATE PROCEDURE [SQLCop].[test xp_cmdshell is enabled]
AS
BEGIN
	-- Written by George Mastros
	-- February 25, 2012
	-- http://sqlcop.lessthandot.com
	-- http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#xp_cmdshell
	
	SET NOCOUNT ON
	
	Declare @Output VarChar(max)
	Set @Output = ''

    select @Output = @Output + 'Warning: xp_cmdshell is enabled' + Char(13) + Char(10)
    from   sys.configurations
    where  name = 'xp_cmdshell'
           and value_in_use = 1
    
	If @Output > '' 
		Begin
			Set @Output = Char(13) + Char(10) 
						  + 'For more information:  '
						  + 'http://wiki.lessthandot.com/index.php/SQLCop_informational_checks#xp_cmdshell'
						  + Char(13) + Char(10) 
						  + Char(13) + Char(10) 
						  + @Output
			EXEC tSQLt.Fail @Output
		End 
END;
GO
PRINT N'Creating [dspconst].[WaitForReplyMessageState_Expired]'
GO
CREATE FUNCTION [dspconst].[WaitForReplyMessageState_Expired] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$GetMessagePatternIdByWaitForReply]'
GO

CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$GetMessagePatternIdByWaitForReply]
    @MessageTime DATETIME, @Address TSTRING, @ProviderInfoId INT, --
    @MessagePatternId INT OUTPUT, @MessageLastData TJSON OUTPUT, @WaitStepId INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    -- Declare variables
    DECLARE @WaitForReplyMessageId BIGINT;
    DECLARE @WaitCreateTime DATETIME;
    DECLARE @ExpirationTreshold INT;
    DECLARE @WaitForReplyMessageStateId TINYINT;

    -- Get ExpirationTreshold from setting
    EXEC dspInboxMessage.Setting_GetProps @WaitExpirationTreshold = @ExpirationTreshold OUTPUT;

    -- Initialize output parameter
    SET @WaitForReplyMessageId = NULL;
    SET @MessagePatternId = NULL;
    SET @MessageLastData = NULL;
    SET @WaitStepId = NULL;

    -- Find first not processed item in wait for reply messages
    -- Index IX_AddressProviderInfoId
    SELECT TOP (1)  @WaitForReplyMessageId = W.WaitForReplyMessageId, @MessagePatternId = Step.MessagePatternId, @MessageLastData = W.MessageLastData,
        @WaitStepId = W.MessagePatternStepId, @WaitCreateTime = W.CreatedTime,
        @WaitForReplyMessageStateId = /*dspconst.WaitForReplyMessageState_Processed()*/ 1
      FROM  dspInboxMessage.WaitForReplyMessage W
            INNER JOIN dspInboxMessage.MessagePatternStep Step ON W.MessagePatternStepId = Step.MessagePatternStepId
     WHERE  W.WaitForReplyMessageStateId = /*dspconst.WaitForReplyMessageState_NotProcess()*/ 3 --
        AND W.[Address] = @Address --
        AND W.ProviderInfoId = @ProviderInfoId
     ORDER BY W.CreatedTime;

    -- Validate wait expiration time
    IF (DATEDIFF(SECOND, @WaitCreateTime, @MessageTime) > @ExpirationTreshold)
    BEGIN
        SET @MessagePatternId = NULL;
        SET @MessageLastData = NULL;
        SET @WaitStepId = NULL;
        SET @WaitForReplyMessageStateId = dspconst.WaitForReplyMessageState_Expired();
    END;

    -- Update wait process status
    IF (@WaitForReplyMessageId IS NOT NULL)
    BEGIN
        UPDATE  WFRM
           SET  WaitForReplyMessageStateId = @WaitForReplyMessageStateId
          FROM  dspInboxMessage.WaitForReplyMessage WFRM
         WHERE  WaitForReplyMessageId = @WaitForReplyMessageId;
    END;
END;
GO
PRINT N'Creating [dspconst].[WaitForReplyMessageState_Processed]'
GO
CREATE FUNCTION [dspconst].[WaitForReplyMessageState_Processed] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dspconst].[ProviderType_SMS]'
GO
CREATE  FUNCTION [dspconst].[ProviderType_SMS] ()
RETURNS TINYINT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dspconst].[ProviderType_Email]'
GO
CREATE  FUNCTION [dspconst].[ProviderType_Email] ()
RETURNS TINYINT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_SendMessage]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_SendMessage] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_OutputParam]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_OutputParam] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_InputParam]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_InputParam] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_InputOutputParam]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_InputOutputParam] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_DoRun]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_DoRun]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 6;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStepType_DoCheckConfirmActivation]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStepType_DoCheckConfirmActivation]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 7;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStateId_Started]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternStateId_Started] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStateId_Paused]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternStateId_Paused] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStateId_Drafted]'
GO
CREATE FUNCTION [dspconst].[MessagePatternStateId_Drafted] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternStateId_Canceled]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternStateId_Canceled] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternSeprator_Star]'
GO
create   FUNCTION [dspconst].[MessagePatternSeprator_Star] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternSeprator_Sharp]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternSeprator_Sharp] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternSeprator_DollorSign]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternSeprator_DollorSign] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 5;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternSeprator_Blank]'
GO
CREATE FUNCTION [dspconst].[MessagePatternSeprator_Blank] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [dspconst].[MessagePatternSeprator_AT]'
GO
CREATE   FUNCTION [dspconst].[MessagePatternSeprator_AT] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_ProcessedNotPair]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_ProcessedNotPair] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_ProcessedFailed]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_ProcessedFailed] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_Processed]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_Processed] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_InProcess]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_InProcess]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 5;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_CustomConfirmNotActive]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_CustomConfirmNotActive]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 8;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_CustomConfirmFailed]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_CustomConfirmFailed]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 9;
END;
GO
PRINT N'Creating [dspconst].[InboxMessageProcessState_AddressNotRegistered]'
GO
CREATE FUNCTION [dspconst].[InboxMessageProcessState_AddressNotRegistered]()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 6;
END;
GO
PRINT N'Creating [dspInboxMessage].[Init_FillLookups]'
GO
CREATE PROCEDURE [dspInboxMessage].[Init_FillLookups]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @TableName TSTRING;

	-- SQL Prompt formatting off

	-- MessagePatternSeprator
    SET @TableName = N'MessagePatternSeprator';
    SELECT  * 
    INTO    #MessagePatternSeprator
      FROM  dspInboxMessage.MessagePatternSeprator AS A
     WHERE  1 = 0;

    INSERT INTO #MessagePatternSeprator
    VALUES 
		(dspconst.MessagePatternSeprator_Blank(), N' '),
		(dspconst.MessagePatternSeprator_Sharp(), N'#'),
		(dspconst.MessagePatternSeprator_Star(), N'*'),
		(dspconst.MessagePatternSeprator_AT(), N'@'),
		(dspconst.MessagePatternSeprator_DollorSign(), N'$');
		
    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';

	-- MessagePatternSeprator
    SET @TableName = N'MessagePatternState';
    SELECT  * 
    INTO    #MessagePatternState
      FROM  dspInboxMessage.MessagePatternState AS A
     WHERE  1 = 0;
    INSERT INTO #MessagePatternState
    VALUES 
		(dspconst.MessagePatternStateId_Drafted(), N'Drafted'),
		(dspconst.MessagePatternStateId_Started(), N'Started'),
		(dspconst.MessagePatternStateId_Paused(), N'Paused'),
		(dspconst.MessagePatternStateId_Canceled(), N'Canceled');
		
    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';
	
	-- ProcessState
    SET @TableName = N'InboxMessageProcessState';
    SELECT  * 
    INTO    #InboxMessageProcessState
      FROM  dspInboxMessage.InboxMessageProcessState AS A
     WHERE  1 = 0;
    INSERT INTO #InboxMessageProcessState
    VALUES 
		(dspconst.InboxMessageProcessState_NotProcessed(), N'NotProcessed'),
		(dspconst.InboxMessageProcessState_Processed(), N'Processed'),
		(dspconst.InboxMessageProcessState_ProcessedNotPair(), N'ProceedNotPair'),
		(dspconst.InboxMessageProcessState_ProcessedFailed (), N'ProcessedFailed'),
		(dspconst.InboxMessageProcessState_InProcess(), N'InProcess'),
		(dspconst.InboxMessageProcessState_AddressNotRegistered(), N'AddressNotRegistered'),
		(dspconst.InboxMessageProcessState_ExecResponseProcedureFaild(), N'ExecResponseProcedureFaild'),
		(dspconst.InboxMessageProcessState_CustomConfirmNotActive(), N'CustomConfirmNotActive'),
		(dspconst.InboxMessageProcessState_CustomConfirmFailed(), N'CustomConfirmFailed');
		
    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';

	-- MessagePatternStepType
    SET @TableName = N'MessagePatternStepType';
    SELECT  * 
    INTO    #MessagePatternStepType
      FROM  dspInboxMessage.MessagePatternStepType AS A
     WHERE  1 = 0;
    INSERT INTO #MessagePatternStepType
    VALUES 
		(dspconst.MessagePatternStepType_InputParam(), N'InputParam'),
		(dspconst.MessagePatternStepType_OutputParam(), N'OutputParam'),
		(dspconst.MessagePatternStepType_InputOutputParam(), N'InputOutputParam'),
		(dspconst.MessagePatternStepType_SendMessage(), N'SendMessage'),
		(dspconst.MessagePatternStepType_Confirm(), N'Confirm'),
		(dspconst.MessagePatternStepType_DoRun(), N'DoRun'),
		(dspconst.MessagePatternStepType_DoCheckConfirmActivation(), N'DoCheckConfirmActivation');

    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';

	-- MessagePatternStepType
    SET @TableName = N'WaitForReplyMessageState';
    SELECT  * 
    INTO    #WaitForReplyMessageState
      FROM  dspInboxMessage.WaitForReplyMessageState AS A
     WHERE  1 = 0;
    INSERT INTO #WaitForReplyMessageState
    VALUES 
		(dspconst.WaitForReplyMessageState_Processed(), N'Processed'),
		(dspconst.WaitForReplyMessageState_Expired(), N'Expired'),
		(dspconst.WaitForReplyMessageState_NotProcess (), N'NotProcess');

    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';

	-- ProviderType
    SET @TableName = N'ProviderType';
    SELECT  * 
    INTO    #ProviderType
      FROM  dspInboxMessage.ProviderType AS A
     WHERE  1 = 0;
    INSERT INTO #ProviderType
    VALUES 
		(dspconst.ProviderType_SMS(), N'SMS'),
		(dspconst.ProviderType_Email(), N'Email');

    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'dspInboxMessage';
	-- SQL Prompt formatting on
END;
GO
PRINT N'Creating [err].[InvalidArgumentId]'
GO

CREATE FUNCTION [err].[InvalidArgumentId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55011;  
END
GO
PRINT N'Creating [err].[ThrowInvalidArgument]'
GO

CREATE PROCEDURE [err].[ThrowInvalidArgument] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.InvalidArgumentId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [tSQLt].[AssertEquals]'
GO
CREATE PROCEDURE [tSQLt].[AssertEquals]
    @Expected SQL_VARIANT,
    @Actual SQL_VARIANT,
    @Message NVARCHAR(MAX) = ''
AS
BEGIN
    IF ((@Expected = @Actual) OR (@Actual IS NULL AND @Expected IS NULL))
      RETURN 0;

    DECLARE @Msg NVARCHAR(MAX);
    SELECT @Msg = 'Expected: <' + ISNULL(CAST(@Expected AS NVARCHAR(MAX)), 'NULL') + 
                  '> but was: <' + ISNULL(CAST(@Actual AS NVARCHAR(MAX)), 'NULL') + '>';
    IF((COALESCE(@Message,'') <> '') AND (@Message NOT LIKE '% ')) SET @Message = @Message + ' ';
    EXEC tSQLt.Fail @Message, @Msg;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$GetAppropriatePatternId]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$GetAppropriatePatternId]
    @MessageBody TSTRING, @MessageTime DATETIME, @Address TSTRING, @ProviderInfoId INT, --
    @MessagePatternId INT OUTPUT, @MessageLastData TJSON OUTPUT, @WaitStepId INT OUTPUT
AS
BEGIN
    SET NOCOUNT ON;

    -- Find in wait for reply
    EXEC dspInboxMessage.[InboxMessageProcess_$GetMessagePatternIdByWaitForReply] @MessageTime = @MessageTime, @Address = @Address,
        @ProviderInfoId = @ProviderInfoId, @MessagePatternId = @MessagePatternId OUTPUT, @MessageLastData = @MessageLastData OUTPUT,
        @WaitStepId = @WaitStepId OUTPUT;
    -- Process PatternId if not found in wait table
    IF @MessagePatternId IS NULL
        SET @MessagePatternId = dspInboxMessage.InboxMessageProcess_$GetMessagePatternIdByCoding(@MessageBody, @MessageTime);
END;
GO
PRINT N'Creating [DatabaseVersioning].[Init_FillLookups]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Init_FillLookups]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @TableName TSTRING;

	-- SQL Prompt formatting off

	-- TemporalType
    SET @TableName = N'TemporalType';
    SELECT  * 
    INTO    #TemporalType
      FROM  DatabaseVersioning.TemporalType AS A
     WHERE  1 = 0;

    INSERT INTO #TemporalType
    VALUES 
		(dspconst.TemporalType_Ordinary(), N'Historical'),
		(dspconst.TemporalType_Temporal(), N'Temporal'),
		(dspconst.TemporalType_Transactional(), N'Transactional'),
		(dspconst.TemporalType_Lookup(), N'Lookup')
		
    EXEC dsp.Table_CompareData @DestinationTableName = @TableName, @DestinationSchemaName = 'DatabaseVersioning';

	-- SQL Prompt formatting on
END;


GO
PRINT N'Creating [dsp].[Init_FillLookups]'
GO

CREATE PROCEDURE [dsp].[Init_FillLookups]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @TableName TSTRING;

    -- Init lookup tables in this format

    -- This is sample
    -- please don't remove this code

    -- InboxMessage
    EXEC dspInboxMessage.Init_FillLookups;

    -- DatabaseVersioning
    EXEC DatabaseVersioning.Init_FillLookups;

	-- SQL Prompt formatting on
END;
GO
PRINT N'Creating [dbo].[Log_Create]'
GO
CREATE PROCEDURE [dbo].[Log_Create]
    @AuditUserId INT, @ApplicationId INT, @CategoryId INT = NULL, @SubCategoryId BIGINT = NULL, @CustomData TJSON = NULL, @LogId BIGINT = NULL OUTPUT
AS
BEGIN
    IF (@ApplicationId IS NULL) --
        EXEC err.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ApplicationId is null';

    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dbo.Application AS A
                       WHERE A.ApplicationId = @ApplicationId) --
        EXEC err.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ApplicationId is an invalid value';

    INSERT INTO dbo.Logs (ApplicationId, CategoryId, SubCategoryId, CustomData, CreatedByUserId, CreatedTime)
    VALUES (@ApplicationId, @CategoryId, @SubCategoryId, @CustomData, @AuditUserId, GETDATE());

    SET @LogId = SCOPE_IDENTITY();

END;
GO
PRINT N'Creating [dbo].[Log_Filter]'
GO
CREATE FUNCTION [dbo].[Log_Filter] (@ApplicationId INT,
    @CategoryId INT = NULL,
    @SubCategoryId BIGINT = NULL,
    @CustomData TJSON = NULL,
    @RecordCount INT,
    @RecordIndex INT)
RETURNS TABLE
AS
RETURN (   SELECT   L.LogId, L.CategoryId, L.SubCategoryId, L.CustomData, L.CreatedTime
             FROM   dbo.Logs AS L
            WHERE   L.ApplicationId = @ApplicationId --
               AND  (@CategoryId IS NULL OR L.CategoryId = @CategoryId) --
               AND  (@SubCategoryId IS NULL OR  L.SubCategoryId = @SubCategoryId)
            ORDER BY L.LogId DESC OFFSET @RecordIndex ROWS FETCH NEXT @RecordCount ROWS ONLY);
GO
PRINT N'Creating [err].[AuthUserNotFoundId]'
GO

CREATE FUNCTION [err].[AuthUserNotFoundId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55025;  
END
GO
PRINT N'Creating [err].[ThrowAuthUserNotFound]'
GO

CREATE PROCEDURE [err].[ThrowAuthUserNotFound] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.AuthUserNotFoundId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dbo].[User_UserIdByAuthUserId]'
GO

CREATE PROCEDURE [dbo].[User_UserIdByAuthUserId]
    @AuthUserId INT, @UserId TSTRING OUT
AS
BEGIN
    SET @UserId = NULL;

    -- find the UserId from your own user table
    -- SELECT  @UserId = U.UserId FROM  dbo.Users AS U WHERE  U.AuthUserId = @AuthUserId;

    IF (@UserId IS NULL) --
        EXEC err.ThrowAuthUserNotFound @ProcId = @@PROCID, @Message = 'AuthUserId: {0}', @Param0 = @AuthUserId;
END;
GO
PRINT N'Creating [dsp].[Database_IsReadOnly]'
GO
CREATE	FUNCTION [dsp].[Database_IsReadOnly] (@DatabaseName TSTRING)
RETURNS BIT
AS
BEGIN
	RETURN IIF(DATABASEPROPERTYEX(ISNULL(@DatabaseName, DB_NAME()), 'Updateability') = 'READ_ONLY', 1, 0);
END;


GO
PRINT N'Creating [dsp].[Context_SetProps]'
GO
CREATE	PROCEDURE [dsp].[Context_SetProps]
	@Context TCONTEXT OUT, @AppName TSTRING = N'<notset>', @AppVersion TSTRING = N'<notset>', @AuthUserId TSTRING = N'<notset>', @UserId TSTRING = N'<notset>',
	@Audience TSTRING = N'<notset>', @IsCaptcha BIT = NULL, @RecordCount INT = -1, @RecordIndex INT = -1, @ClientVersion TSTRING = N'<notset>'
AS
BEGIN
	IF (@Context IS NULL OR @Context = '')
		SET @Context = '{}';

	-- Fix built-in users
	IF (@UserId = N'$' OR @UserId = N'$$')
	BEGIN
		DECLARE @SystemUserId TSTRING;
		DECLARE @AppUserId TSTRING;
		EXEC dsp.Setting_GetProps @SystemUserId = @SystemUserId OUT, @AppUserId = @AppUserId OUT;

		IF (@UserId = N'$')
			SET @UserId = @SystemUserId;

		IF (@UserId = N'$$')
			SET @UserId = ISNULL(@AppUserId, @SystemUserId);
	END;

	IF (@AppName IS NULL OR @AppName <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, '$.AppName', @AppName);

	IF (@AppVersion IS NULL OR @AppVersion <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, '$.AppVersion', @AppVersion);

	IF (@AuthUserId IS NULL OR @AuthUserId <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, N'$.AuthUserId', @AuthUserId);

	IF (@UserId IS NULL OR @UserId <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, N'$.UserId', @UserId);

	IF (@Audience IS NULL OR @Audience <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, N'$.Audience', @Audience);

	-- update InvokeOptions
	IF (JSON_QUERY(@Context, N'$.InvokeOptions') IS NULL)
		SET @Context = JSON_MODIFY(@Context, N'$.InvokeOptions', JSON_QUERY('{}', '$'));

	IF (@IsCaptcha IS NOT NULL)
		SET @Context = JSON_MODIFY(@Context, N'$.InvokeOptions.IsCaptcha', @IsCaptcha);

	IF (@RecordCount IS NULL OR @RecordCount <> -1)
		SET @Context = JSON_MODIFY(@Context, N'$.InvokeOptions.RecordCount', @RecordCount);

	IF (@RecordIndex IS NULL OR @RecordIndex <> -1)
		SET @Context = JSON_MODIFY(@Context, N'$.InvokeOptions.RecordIndex', @RecordIndex);

	IF (@ClientVersion IS NULL OR @ClientVersion <> N'<notset>')
		SET @Context = JSON_MODIFY(@Context, N'$.InvokeOptions.ClientVersion', @ClientVersion);
END;








GO
PRINT N'Creating [err].[PageSizeTooLargeId]'
GO

CREATE FUNCTION [err].[PageSizeTooLargeId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55009;  
END
GO
PRINT N'Creating [err].[ThrowPageSizeTooLarge]'
GO

CREATE PROCEDURE [err].[ThrowPageSizeTooLarge] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.PageSizeTooLargeId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Param_IsSetOrNotNull]'
GO
CREATE FUNCTION [dsp].[Param_IsSetOrNotNull] (
	@value SQL_VARIANT
)
RETURNS BIT
AS
BEGIN
	RETURN IIF(@value IS NULL OR dsp.Param_IsSet(@value) = 0, 0, 1);
END;












GO
PRINT N'Creating [dsp].[Context_$ValidatePagination]'
GO
CREATE	PROCEDURE [dsp].[Context_$ValidatePagination]
	@RecordCount INT OUT, @RecordIndex INT OUT
AS
BEGIN
	-- Get RecordCount and RecordIndex from Context
	SET @RecordIndex = ISNULL(@RecordIndex, 0);

	DECLARE @PaginationMaxRecordCount INT;
	DECLARE @PaginationDefaultRecordCount INT;
	EXEC dsp.Setting_GetProps @PaginationDefaultRecordCount = @PaginationDefaultRecordCount OUTPUT,
		@PaginationMaxRecordCount = @PaginationMaxRecordCount OUTPUT;

	-- Set Default
	IF (dsp.Param_IsSetOrNotNull(@RecordCount) = 0)
		SET @RecordCount = @PaginationDefaultRecordCount;

	-- Set Max
	IF (@RecordCount = -2)
		SET @RecordCount = @PaginationMaxRecordCount;

	IF (@RecordCount > @PaginationMaxRecordCount) --
		EXEC err.ThrowPageSizeTooLarge @ProcId = @@PROCID;
END;












GO
PRINT N'Creating [dsp].[Context_GetProps]'
GO
CREATE	PROCEDURE [dsp].[Context_GetProps]
	@Context TCONTEXT OUT, @AppName TSTRING = N'<notset>' OUT, @AuthUserId TSTRING = N'<notset>' OUT, @UserId TSTRING = N'<notset>' OUT,
	@Audience TSTRING = N'<notset>' OUT, @IsCaptcha INT = -1 OUT, @RecordCount INT = -1 OUT, @RecordIndex INT = -1 OUT,
	@ClientVersion TSTRING = N'<notset>' OUT, @MoneyConversionRate FLOAT = -1 OUT, @InvokerAppVersion TSTRING = NULL OUT, @IsReadonlyIntent BIT = NULL OUT,
	@IsInvokedByMidware BIT = NULL OUT
AS
BEGIN
	-- General
	IF (@AppName IS NULL OR @AppName <> N'<notset>')
		SET @AppName = JSON_VALUE(@Context, N'$.AppName');

	IF (@AuthUserId IS NULL OR @AuthUserId <> N'<notset>')
		SET @AuthUserId = JSON_VALUE(@Context, N'$.AuthUserId');

	IF (@UserId IS NULL OR @UserId <> N'<notset>')
		SET @UserId = JSON_VALUE(@Context, N'$.UserId');

	IF (@Audience IS NULL OR @Audience <> N'<notset>')
		SET @Audience = JSON_VALUE(@Context, N'$.Audience');

	-- InvokeOptions
	DECLARE @InvokeOptions TJSON = JSON_QUERY(@Context, N'$.InvokeOptions');

	IF (@ClientVersion IS NULL OR @ClientVersion <> N'<notset>')
		SET @ClientVersion = JSON_VALUE(@InvokeOptions, N'$.ClientVersion');

	IF (@MoneyConversionRate IS NULL OR @MoneyConversionRate <> -1)
		SET @MoneyConversionRate = ISNULL(JSON_VALUE(@InvokeOptions, N'$.MoneyConversionRate'), 1);

	IF (@IsCaptcha IS NULL OR @IsCaptcha <> -1)
		SET @IsCaptcha = ISNULL(CAST(JSON_VALUE(@InvokeOptions, '$.IsCaptcha') AS BIT), 0);

	IF (@IsReadonlyIntent IS NULL OR @IsReadonlyIntent <> -1)
		SET @IsReadonlyIntent = ISNULL(CAST(JSON_VALUE(@InvokeOptions, '$.IsReadonlyIntent') AS BIT), 0);

	IF ((@RecordCount IS NULL OR @RecordCount <> -1) OR (@RecordIndex IS NULL OR @RecordIndex <> -1))
	BEGIN
		SET @RecordCount = JSON_VALUE(@InvokeOptions, N'$.RecordCount');
		SET @RecordIndex = JSON_VALUE(@InvokeOptions, N'$.RecordIndex');
		EXEC dsp.[Context_$ValidatePagination] @RecordCount = @RecordCount OUTPUT, @RecordIndex = @RecordIndex OUTPUT;
	END;

	IF (@InvokerAppVersion IS NULL OR @InvokerAppVersion <> -1)
		SET @InvokerAppVersion = JSON_VALUE(@InvokeOptions, N'$.InvokerAppVersion');

	SET @IsInvokedByMidware = IIF(@InvokerAppVersion IS NOT NULL, 1, 0);

END;

















GO
PRINT N'Creating [dsp].[Context_Create]'
GO
CREATE	PROCEDURE [dsp].[Context_Create]
	@UserId TSTRING, @IsCaptcha INT = 0, @Context TCONTEXT = NULL OUT
AS
BEGIN
	DECLARE @AppName TSTRING;
	DECLARE @AppVersion TSTRING;
	EXEC dsp.Setting_GetProps @AppName = @AppName OUTPUT, @AppVersion = @AppVersion OUTPUT;

	SET @Context = NULL;
	EXEC dsp.Context_SetProps @Context = @Context OUTPUT, @UserId = @UserId, @AppName = @AppName, @AppVersion = @AppVersion, @IsCaptcha = @IsCaptcha;
END;




GO
PRINT N'Creating [dsp].[Context_CreateSystem]'
GO
CREATE PROCEDURE [dsp].[Context_CreateSystem]
    @SystemContext TCONTEXT OUT
AS
BEGIN
    EXEC dsp.Context_Create @UserId = '$', @Context = @SystemContext OUT, @IsCaptcha = 1;
END;
GO
PRINT N'Creating [dsp].[Context_Verify]'
GO
CREATE	PROCEDURE [dsp].[Context_Verify]
	@Context TCONTEXT OUT, @ProcId INT
AS
BEGIN
	-- Settings
	DECLARE @AppName TSTRING;
	DECLARE @AppVersion TSTRING;
	DECLARE @AppUserId TSTRING;
	DECLARE @SystemUserId TSTRING;
	DECLARE @MaintenanceMode INT;
	EXEC dsp.Setting_GetProps @AppVersion = @AppVersion OUT, @AppName = @AppName OUT, @AppUserId = @AppUserId OUT, @SystemUserId = @SystemUserId OUT,
		@MaintenanceMode = @MaintenanceMode OUT;

	-- Set SystemContext
	IF (@Context = N'$') EXEC dsp.Context_CreateSystem @SystemContext = @Context OUTPUT;
	IF (@Context = N'$$') EXEC dsp.Context_Create @UserId = '$$', @Context = @Context OUT, @IsCaptcha = 1;

	-- Context 
	DECLARE @ContextAuthUserId TSTRING;
	DECLARE @ContextAppName TSTRING;
	DECLARE @ContextUserId TSTRING;
	DECLARE @ContextInvokerAppVersion TSTRING;
	DECLARE @IsReadonlyIntent BIT;
	DECLARE @IsInvokedByMidware BIT;
	EXEC dsp.Context_GetProps @Context = @Context OUTPUT, @AuthUserId = @ContextAuthUserId OUTPUT, @UserId = @ContextUserId OUTPUT,
		@AppName = @ContextAppName OUTPUT, @InvokerAppVersion = @ContextInvokerAppVersion OUT, @IsReadonlyIntent = @IsReadonlyIntent OUT,
		@IsInvokedByMidware = @IsInvokedByMidware OUT;
	DECLARE @ContextUserIdOrg TSTRING = @ContextUserId;

	-- Check MaintenanceMode
	IF (@IsInvokedByMidware = 1)
	BEGIN
		IF (@MaintenanceMode = 2) --
			EXEC dsperr.ThrowMaintenance @ProcId = @@PROCID, @Message = 'Maintenance';

		IF (@IsReadonlyIntent = 0 AND	(@MaintenanceMode = 1 OR dsp.Database_IsReadOnly(DB_NAME()) = 1))
			EXEC dsperr.ThrowMaintenanceReadOnly @ProcId = @@PROCID, @Message = 'MaintenanceReadOnly';
	END;

	-- Validate AppName
	IF (@ContextAppName IS NULL OR @ContextAppName <> @AppName) --
		EXEC dsp.ThrowGeneralException @ProcId = @ProcId, @Message = N'the app property of context is not valid! AppName: {0}; ContextAppName: {1}',
			@Param0 = @AppName, @Param1 = @ContextAppName;

	-- Check InvokerAppVersion if set
	IF (@ContextInvokerAppVersion IS NOT NULL AND	@ContextInvokerAppVersion <> @AppVersion)
		EXEC dsperr.ThrowInvokerAppVersion @ProcId = @ProcId;

	-------------
	-- Fin UserId for System Accounts
	-------------
	IF (@ContextUserId = N'$$')
		SET @ContextUserId = ISNULL(@AppUserId, N'$');

	IF (@ContextUserId = N'$')
	BEGIN
		SET @ContextUserId = @SystemUserId;
		IF (@ContextUserId IS NULL) --
			EXEC dsp.ThrowGeneralException @ProcId = @ProcId, @Message = 'SystemUserId has not been initailized';
	END;

	-- Find UserId by AuthUserId
	IF (@ContextUserId IS NULL) --
	BEGIN
		IF (@ContextAuthUserId = '$$')
			SET @ContextUserId = ISNULL(@AppUserId, @SystemUserId);
		ELSE
			EXEC dbo.User_UserIdByAuthUserId @AuthUserId = @ContextAuthUserId, @UserId = @ContextUserId OUT;
	END;

	-------------
	-- Update Context if user context
	-------------
	IF (@ContextUserIdOrg IS NULL OR @ContextUserIdOrg <> @ContextUserId) --
		EXEC dsp.Context_SetProps @Context = @Context OUTPUT, @UserId = @ContextUserId, @AppVersion = @AppVersion;

END;

GO
PRINT N'Creating [dsp].[Context_UserId]'
GO

CREATE	FUNCTION [dsp].[Context_UserId] (@Context TCONTEXT)
RETURNS TSTRING
AS
BEGIN
	RETURN	JSON_VALUE(@Context, '$.UserId');
END;



GO
PRINT N'Creating [api].[Log_Filter]'
GO
CREATE PROCEDURE [api].[Log_Filter]
    @Context TCONTEXT OUTPUT, @ApplicationId INT, @CategoryId INT = NULL, @SubCategoryId BIGINT = NULL, @CustomData TJSON = NULL
WITH EXECUTE AS OWNER
AS
BEGIN
    SET NOCOUNT ON;
    EXEC dsp.Context_Verify @Context = @Context OUT, @ProcId = @@PROCID;
    DECLARE @ContextUserId INT = dsp.Context_UserId(@Context);

    DECLARE @RecordCount INT;
    DECLARE @RecordIndex INT;
    EXEC dsp.Context_GetProps @Context = @Context OUTPUT, @RecordCount = @RecordCount OUTPUT, @RecordIndex = @RecordIndex OUTPUT;

    -- call dbo
    SELECT  LF.LogId, LF.CategoryId, LF.SubCategoryId, LF.CustomData, LF.CreatedTime
      FROM  dbo.Log_Filter(@ApplicationId, @CategoryId, @SubCategoryId, @CustomData, @RecordCount, @RecordIndex) AS LF;
END;
GO
PRINT N'Creating [api].[Log_Create]'
GO
CREATE PROCEDURE [api].[Log_Create]
    @Context TCONTEXT OUTPUT, @ApplicationId INT, @CategoryId INT = NULL, @SubCategoryId BIGINT = NULL, @CustomData TJSON = NULL, @LogId BIGINT = NULL OUTPUT
WITH EXECUTE AS OWNER
AS
BEGIN
    SET NOCOUNT ON;
    EXEC dsp.Context_Verify @Context = @Context OUT, @ProcId = @@PROCID;
    DECLARE @ContextUserId INT = dsp.Context_UserId(@Context);

    -- call dbo
    EXEC dbo.Log_Create @AuditUserId = @ContextUserId, @ApplicationId = @ApplicationId, @CategoryId = @CategoryId, @SubCategoryId = @SubCategoryId,
        @CustomData = @CustomData, @LogId = @LogId OUTPUT;
END;
GO
PRINT N'Creating [tClass].[test Log_Create]'
GO
CREATE PROCEDURE [tClass].[test Log_Create]
AS
BEGIN
    SET NOCOUNT ON;
    -- Getting SystemContext
    DECLARE @SystemContext TCONTEXT;
    EXEC dsp.Context_CreateSystem @SystemContext = @SystemContext OUTPUT;
    DECLARE @AuditUserId INT = dsp.Context_UserId(@SystemContext);

    -- Declare variable
    DECLARE @CheckingNumber INT = 0;
    DECLARE @LogId BIGINT;
    DECLARE @Application_IcLoyalty INT = const.Application_IcLoyalty();
    DECLARE @Log_FilterRsultList ud_LogFilter;

    --------------------------------
    -- Checking: InvalidArgument exception is expected when ApplicationId is null
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: InvalidArgument exception is expected when ApplicationId is null',
        @Param0 = @CheckingNumber;

    BEGIN TRY
        EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = NULL, @CategoryId = 1, @CustomData = '';
        EXEC tSQLt.Fail @Message0 = N'InvalidArgument exception is expected when ApplicationId is null';
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() <> err.InvalidArgumentId() OR CHARINDEX('ApplicationId is null', ERROR_MESSAGE()) = 0)
            THROW;
    END CATCH;

    --------------------------------
    -- Checking: InvalidArgument exception is expected when ApplicationId is an invalid value
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: InvalidArgument exception is expected when ApplicationId is an invalid value',
        @Param0 = @CheckingNumber;

    BEGIN TRY
        EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = -1, @CategoryId = 1, @CustomData = '';
        EXEC tSQLt.Fail @Message0 = N'InvalidArgument exception is expected when ApplicationId is an invalid value';
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() <> err.InvalidArgumentId() OR CHARINDEX('ApplicationId is an invalid value', ERROR_MESSAGE()) = 0)
            THROW;
    END CATCH;

    --------------------------------
    -- Checking: Successfully create log
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: Successfully create log', @Param0 = @CheckingNumber;

    SAVE TRANSACTION Test;
    SET @LogId = NULL;
    DECLARE @CustomData TJSON = '{"OperationKey": 101010, "OperationValue": "Operation was successfully"}';
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1, @SubCategoryId = 1, @CustomData = @CustomData,
        @LogId = @LogId OUTPUT;

    IF (@LogId IS NULL) --
        EXEC tSQLt.Fail @Message0 = N'The log is not saved correctly';

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty;

    IF NOT EXISTS (SELECT   TOP 1 1 FROM    @Log_FilterRsultList AS LFRL)
        EXEC tSQLt.Fail @Message0 = N'Log_Filter function is not worked correctly';

    DECLARE @ActualCategoryId INT;
    DECLARE @ActualSubCategoryId INT;
    DECLARE @ActualCustomData TJSON;

    SELECT  TOP 1 @ActualCategoryId = LFRL.CategoryId, @ActualSubCategoryId = LFRL.SubCategoryId, @ActualCustomData = LFRL.CustomData
      FROM  @Log_FilterRsultList AS LFRL;

    EXEC tSQLt.AssertEquals @Expected = 1, @Actual = @ActualCategoryId, @Message = N'CategoryId is not correctly';
    EXEC tSQLt.AssertEquals @Expected = 1, @Actual = @ActualSubCategoryId, @Message = N'SubCategoryId is not correctly';

    DECLARE @AreSame BIT;
    EXEC dsp.Json_Compare @Json1 = @CustomData, @Json2 = @ActualCustomData, @TwoSided = 0, @IncludeValue = 1,
        @ExceptionMessage = N'Log_Filter function is returned not correctly custom data json';

    ROLLBACK TRANSACTION Test;

END;


GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$GetCustomValue]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$GetCustomValue]
    @ProviderInfoId INT, @Address TSTRING, @MessageLastData TJSON, @MessagePatternStepId INT, @ParameterName TSTRING, @ParameterValue TSTRING OUTPUT
AS
BEGIN
    -- It must be overwrite by client
    BEGIN TRY
        EXEC InboxMessage.InboxMessageProcess_GetCustomValue @ProviderInfoId = @ProviderInfoId, @Address = @Address,
            @MessageLastData = @MessageLastData, @MessagePatternStepId = @MessagePatternStepId, @ParameterName = @ParameterName,
            @ParameterValue = @ParameterValue OUTPUT;
    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;

END;

GO
PRINT N'Creating [dsp].[Schema_DropObjects]'
GO
-- @ObjectType Can be 'FN' or 'P'
CREATE PROCEDURE [dsp].[Schema_DropObjects]
	@SchemaName TSTRING, @DropFunctions BIT = 0, @DropProcedures BIT = 0
AS
BEGIN
	SET NOCOUNT ON;
	SET @DropFunctions = ISNULL(@DropFunctions, 0);
	SET @DropProcedures = ISNULL(@DropProcedures, 0);

	DECLARE @ObjectName TSTRING;
	DECLARE @ObjectType TSTRING;
	DECLARE @DdlText TSTRING;

	--Drop String Functions
	DECLARE DropCursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
	SELECT	O.name, O.type
	FROM	sys.objects AS O
			INNER JOIN sys.schemas AS S ON S.schema_id = O.schema_id
	WHERE	S.name = @SchemaName
			AND O.type IN ( 'FN', 'P', 'IF', 'TF' );

	OPEN DropCursor;
	FETCH NEXT FROM DropCursor
	INTO @ObjectName, @ObjectType;
	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		IF (@DropFunctions = 1 AND @ObjectType IN ('FN', 'IF', 'TF'))
		BEGIN
			SET @DdlText = 'DROP FUNCTION ' + @SchemaName + '.' + @ObjectName;
			EXEC sys.sp_executesql @DdlText;
		END;

		IF (@DropProcedures = 1 AND @ObjectType = 'P')
		BEGIN
			SET @DdlText = 'DROP PROCEDURE ' + @SchemaName + '.' + @ObjectName;
			EXEC sys.sp_executesql @DdlText;
		END;

		FETCH NEXT FROM DropCursor
		INTO @ObjectName, @ObjectType;
	END;
	CLOSE DropCursor;
	DEALLOCATE DropCursor;

END;






GO
PRINT N'Creating [dsp].[App_LatestVersionNumber]'
GO
CREATE FUNCTION [dsp].[App_LatestVersionNumber] ()
RETURNS TSTRING
--WITH ENCRYPTION|SCHEMABINDING, ...
AS
BEGIN
    DECLARE @LatestAppVersionNumber TSTRING;

    -- Get the latest application version number
    SELECT  TOP 1 @LatestAppVersionNumber = AV.VersionNumber
      FROM  dsp.AppVersion AS AV
     ORDER BY AV.AppVersionId DESC;

    RETURN @LatestAppVersionNumber;
END;
GO
PRINT N'Creating [tClass].[test Log_Filter]'
GO
CREATE PROCEDURE [tClass].[test Log_Filter]
AS
BEGIN
    SET NOCOUNT ON;
    -- Getting SystemContext
    DECLARE @SystemContext TCONTEXT;
    EXEC dsp.Context_CreateSystem @SystemContext = @SystemContext OUTPUT;
    DECLARE @AuditUserId INT = dsp.Context_UserId(@SystemContext);

    -- Declare variable
    DECLARE @CheckingNumber INT = 0;
    DECLARE @Application_IcLoyalty INT = const.Application_IcLoyalty();
    DECLARE @Log_FilterRsultList ud_LogFilter;

    --------------------------------
    -- Checking: Create logs and get all of them by ApplicationId
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: Create logs and get all of them by just ApplicationId', @Param0 = @CheckingNumber;

    SAVE TRANSACTION Test;

    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1,
        @CustomData = '{"OperationKey": 101010, "OperationValue": "Operation was successfully"}';
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 2,
        @CustomData = '{"OperationKey": 101011, "OperationValue": "Operation was not successfully"}';

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext OUTPUT, @ApplicationId = @Application_IcLoyalty;

    IF ((SELECT COUNT(1) FROM   @Log_FilterRsultList AS LFRL) <> 2) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect count of result';

    ROLLBACK TRANSACTION Test;

    --------------------------------
    -- Checking: Create logs and get all of them by ApplicationId and CategoryId
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: Create logs and get all of them by ApplicationId and CategoryId',
    @Param0 = @CheckingNumber;

    SAVE TRANSACTION Test;

    DECLARE @LogId1 BIGINT;
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1,
        @CustomData = '{"OperationKey": 101010, "OperationValue": "Operation was successfully"}', @LogId = @LogId1 OUTPUT;
    DECLARE @LogId2 BIGINT;
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 2,
        @CustomData = '{"OperationKey": 101011, "OperationValue": "Operation was not successfully"}', @LogId = @LogId2 OUTPUT;

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext OUTPUT, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1;

    IF ((SELECT COUNT(1) FROM   @Log_FilterRsultList AS LFRL) <> 1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect count of result on Log_1';

    IF ((SELECT LFRL.LogId FROM @Log_FilterRsultList AS LFRL) <> @LogId1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect result on Log_1';

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext OUTPUT, @ApplicationId = @Application_IcLoyalty, @CategoryId = 2;

    IF ((SELECT COUNT(1) FROM   @Log_FilterRsultList AS LFRL) <> 1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect count of result on Log_2';

    IF ((SELECT LFRL.LogId FROM @Log_FilterRsultList AS LFRL) <> @LogId2) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect result on Log_2';

    ROLLBACK TRANSACTION Test;

    --------------------------------
    -- Checking: Create logs and get all of them by ApplicationId and CategoryId and SubCategory
    --------------------------------
    SET @CheckingNumber = @CheckingNumber + 1;
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking {0}: Create logs and get all of them by ApplicationId and CategoryId and SubCategory',
        @Param0 = @CheckingNumber;

    SAVE TRANSACTION Test;

    SET @LogId1 = NULL;
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1, @SubCategoryId = 1,
        @CustomData = '{"OperationKey": 101010, "OperationValue": "Operation was successfully"}', @LogId = @LogId1 OUTPUT;

    SET @LogId2 = NULL;
    EXEC api.Log_Create @Context = @SystemContext, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1, @SubCategoryId = 2,
        @CustomData = '{"OperationKey": 101011, "OperationValue": "Operation was not successfully"}', @LogId = @LogId2 OUTPUT;

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext OUTPUT, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1, @SubCategoryId = 1;

    IF ((SELECT COUNT(1) FROM   @Log_FilterRsultList AS LFRL) <> 1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect count of result on Log_1';

    IF ((SELECT LFRL.LogId FROM @Log_FilterRsultList AS LFRL) <> @LogId1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect result on Log_1';

    DELETE @Log_FilterRsultList;
    INSERT INTO @Log_FilterRsultList
    EXEC api.Log_Filter @Context = @SystemContext OUTPUT, @ApplicationId = @Application_IcLoyalty, @CategoryId = 1, @SubCategoryId = 2;

    IF ((SELECT COUNT(1) FROM   @Log_FilterRsultList AS LFRL) <> 1) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect count of result on Log_2';

    IF ((SELECT LFRL.LogId FROM @Log_FilterRsultList AS LFRL) <> @LogId2) --
        EXEC tSQLt.Fail @Message0 = N'The function returned incorrect result on Log_2';

    ROLLBACK TRANSACTION Test;

END;


GO
PRINT N'Creating [dsp].[Lock_Create]'
GO
CREATE	PROCEDURE [dsp].[Lock_Create]
	@ObjectTypeName TSTRING, @ObjectName TSTRING = NULL, @IsTransactionMode BIT = 1, @LockId TSTRING = NULL OUT
AS
BEGIN
	SET @LockId = N'{}';
	SET @ObjectName = ISNULL(@ObjectName, '');
	SET @IsTransactionMode = ISNULL(@IsTransactionMode, 1);
	DECLARE @LockName TSTRING = @ObjectTypeName + @ObjectName;
	DECLARE @LockOwner TSTRING = IIF(@IsTransactionMode = 1, 'Transaction', 'Session');

	-- Getting Lock
	DECLARE @Result INT;
	EXEC @Result = sys.sp_getapplock @Resource = @LockName, @LockMode = 'Exclusive', @LockOwner = @LockOwner;

	-- throw error for error result
	IF (@Result < 0) --
		EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = N'Get AppLock Error! ErrorNumber: {0}', @Param0 = @Result;

	SET @LockId = JSON_MODIFY(@LockId, '$.LockOwner', @LockOwner);
	SET @LockId = JSON_MODIFY(@LockId, '$.LockName', @LockName);
END;































GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$GetNextBulk]'
GO

CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$GetNextBulk]
    @MaxInboxMessageId BIGINT, @InboxMessageItems TJSON = NULL OUTPUT
AS
BEGIN
    -- Consts
    DECLARE @ProcessRecordCount BIGINT;

    -- Get @ProcessRecordCount from setting
    EXEC dspInboxMessage.Setting_GetProps @ProcessRecordCount = @ProcessRecordCount OUTPUT;

    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;
    BEGIN TRY
        EXEC dsp.Lock_Create @ObjectTypeName = 'InboxMessageProcess_$GetNextBulk';

        -- TODO : need index
        SET @InboxMessageItems =
        (   SELECT TOP (@ProcessRecordCount)    IM.InboxMessageId, IM.Address, IM.MessageBody, IM.MessageTime, IM.ProviderInfoId
              FROM  dspInboxMessage.InboxMessage IM
			  LEFT JOIN  dspInboxMessage.InboxMessage IMInProcess ON IMInProcess.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_InProcess()*/ 5 --
				AND IMInProcess.Address = IM.Address
             WHERE IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_NotProcessed()*/ 1 --
                AND IMInProcess.InboxMessageId IS NULL
                AND IM.InboxMessageId <= @MaxInboxMessageId
             ORDER BY IM.MessageTime
            FOR JSON AUTO);
		
		-- TODO: Need perfomance tunning
        --SET @InboxMessageItems =
        --(   SELECT TOP (@ProcessRecordCount)    IM.InboxMessageId, IM.Address, IM.MessageBody, IM.MessageTime, IM.ProviderInfoId
        --      FROM  InboxMessage.InboxMessage IM
        --     WHERE IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_NotProcessed()*/ 1 --
        --        AND
        --           NOT EXISTS (   SELECT    1
        --                            FROM    InboxMessage.InboxMessage IMInProcess
        --                           WHERE  IMInProcess.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_InProcess()*/ 5 AND
        --                                  IMInProcess.Address = IM.Address) --
        --        AND InboxMessageId <= @MaxInboxMessageId
        --     ORDER BY IM.MessageTime
        --    FOR JSON AUTO);

        -- Update state
        UPDATE  IM
           SET  IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_InProcess()*/ 5, IM.ProcessStartTime = GETDATE()
          FROM  (   SELECT  *
                      FROM
                        OPENJSON(@InboxMessageItems)
                        WITH (InboxMessageId BIGINT)) Result
                INNER JOIN dspInboxMessage.InboxMessage IM ON IM.InboxMessageId = Result.InboxMessageId;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;

        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;
END;
GO
PRINT N'Creating [dsp].[Init_RecreateEnumFunctions]'
GO

-- Create Procedure RecreatePermissionFunctions
CREATE PROCEDURE [dsp].[Init_RecreateEnumFunctions]
    @SchemaName TSTRING, @TableSchemaName TSTRING = 'dbo', @TableName TSTRING, @KeyColumnName TSTRING, @TextColumnName TSTRING, @FunctionBody TSTRING = NULL,
    @FunctionNamePostfix TSTRING = NULL
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @KeyColumnValue TSTRING;
    DECLARE @TextColumnValue TSTRING;
    DECLARE @Sql TSTRING;
    SET @FunctionNamePostfix = ISNULL(@FunctionNamePostfix, '');

    -- Set default function body
    IF (@FunctionBody IS NULL)
    BEGIN
        SET @FunctionBody =
            '
CREATE FUNCTION @SchemaName.@TextColumnValue@FunctionNamePostfix()
RETURNS INT 
WITH SCHEMABINDING
AS
BEGIN
	RETURN @KeyColumnValue;  
END
			'       ;
    END;
    SET @FunctionBody = REPLACE(@FunctionBody, '@SchemaName', @SchemaName);
    SET @FunctionBody = REPLACE(@FunctionBody, '@FunctionNamePostfix', @FunctionNamePostfix);

    -- Drop const Functions
    EXEC dsp.Schema_DropObjects @SchemaName = @SchemaName, @DropFunctions = 1;

    CREATE TABLE #EnumIdName (ObjectId NVARCHAR(/*Ignore code quality*/ MAX),
        ObjectName NVARCHAR(/*Ignore code quality*/ MAX));
    SET @Sql = 'INSERT INTO #EnumIdName (ObjectId, ObjectName) SELECT @KeyColumnName, @TextColumnName FROM @TableSchemaName.@TableName';
    SET @Sql = REPLACE(@Sql, '@TableSchemaName', @TableSchemaName);
    SET @Sql = REPLACE(@Sql, '@TableName', @TableName);
    SET @Sql = REPLACE(@Sql, '@KeyColumnName', @KeyColumnName);
    SET @Sql = REPLACE(@Sql, '@TextColumnName', @TextColumnName);
    EXEC (@Sql);
    
    -- Recreate Permissions Functions
    DECLARE LocalCursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR SELECT  E.ObjectId, E.ObjectName FROM   #EnumIdName AS E;
    OPEN LocalCursor;
    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM LocalCursor
         INTO @KeyColumnValue, @TextColumnValue;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        SET @Sql = @FunctionBody;

        SET @Sql = REPLACE(@Sql, '@TextColumnValue', @TextColumnValue);
        SET @Sql = REPLACE(@Sql, '@KeyColumnValue', @KeyColumnValue);

        EXEC (@Sql);
    END;
    CLOSE LocalCursor;
    DEALLOCATE LocalCursor;

    DROP TABLE #EnumIdName;

END;




GO
PRINT N'Creating [dsp].[AppVersion_Details]'
GO
CREATE FUNCTION [dsp].[AppVersion_Details] (@AppVersionNumber TSTRING)
RETURNS TABLE
--WITH ENCRYPTION|SCHEMABINDING, ...
AS
RETURN (   SELECT   AVD.AppVersionDetailId, --
               AVD.AppVersionId, --
               AVD.StoredProcedureName, --
               AVD.StoredProcedurePhysicalName, --
               AVD.StoredProcedureVersionNumber, --
               AVD.SchemaName, --
               AVD.ExpirationTime, --
               AVD.CreatedTime --
             FROM   dsp.AppVersionDetail AS AVD
                    INNER JOIN --
               dsp.AppVersion AS AV ON AV.AppVersionId = AVD.AppVersionId
            WHERE   AV.VersionNumber = @AppVersionNumber);

GO
PRINT N'Creating [tCodeQuality].[Private_ColumnsWithBigintTypes]'
GO

CREATE PROCEDURE [tCodeQuality].[Private_ColumnsWithBigintTypes]
AS
BEGIN
    WITH BigIntColumns
        AS (SELECT  Tbl.name AS TableName, C.name AS ColumnName
              FROM  sys.columns AS C
                    INNER JOIN sys.types AS T ON T.user_type_id = C.user_type_id
                    INNER JOIN sys.tables AS Tbl ON Tbl.object_id = C.object_id
             WHERE  T.name = 'bigint')
    SELECT  DISTINCT S.name AS SchemaName, P.name AS ProcedureName, SM.definition, BC.ColumnName
      FROM  BigIntColumns AS BC, sys.procedures AS P
                                 INNER JOIN sys.schemas AS S ON S.schema_id = P.schema_id
                                 INNER JOIN sys.sql_modules AS SM ON SM.object_id = P.object_id
     WHERE  dsp.String_RemoveWhitespacesBig(REPLACE(SM.definition, 'INTO', '')) LIKE '%' + BC.ColumnName + 'INT%' --
        AND S.name <> 'tSQLt';
END;


GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessCheckConfirmActivationStep]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessCheckConfirmActivationStep]
    @MessagePatternStepId INT, @ProviderInfoId INT, @Address TSTRING, @DoBreak BIT = NULL OUTPUT, @InboxMessageProcessStateId INT = NULL OUTPUT
AS
BEGIN
    DECLARE @IsActive BIT;
	DECLARE @FaildConfirmActivationMessage TSTRING;
    DECLARE @MessagePatternId INT = (   SELECT  MessagePatternId
                                          FROM  dspInboxMessage.MessagePatternStep
                                         WHERE  MessagePatternStepId = @MessagePatternStepId);

    SET @DoBreak = 0;

    -- Check custom confirm validation existance
    IF dspInboxMessage.[MessagePatternStep_HasCustomConfirmValidation](@MessagePatternId) = 1
    BEGIN
        -- Call client api for check custom validation activation
        EXEC dspInboxMessage.InboxMessageProcess_$CheckCustomConfirmValueActivation @ProviderInfoId = @ProviderInfoId, @Address = @Address,
            @IsActive = @IsActive OUTPUT;

        -- if is not active then exit process and send error message to user address
        IF @IsActive = 0
        BEGIN
            SET @DoBreak = 1;
            SET @InboxMessageProcessStateId = dspconst.InboxMessageProcessState_CustomConfirmNotActive();
            EXEC dspInboxMessage.Setting_GetProps @FaildConfirmActivationMessage = @FaildConfirmActivationMessage OUTPUT;
            SET @MessagePatternStepId = (   SELECT TOP 1    MessagePatternStepId
                                              FROM  dspInboxMessage.MessagePatternStep
                                             WHERE  MessagePatternId = @MessagePatternId
                                             ORDER BY [Order]);
            IF @FaildConfirmActivationMessage IS NOT NULL
                EXEC dspInboxMessage.[InboxMessageProcess_$SendReplyMessage] @ProviderInfoId = @ProviderInfoId, @Address = @Address,
                    @SendMessageValue = @FaildConfirmActivationMessage, @MessagePatternStepId = @MessagePatternStepId;
        END;
    END;
END;
GO
PRINT N'Creating [dsp].[Init_$RecreateExceptionFunctions]'
GO
CREATE PROCEDURE [dsp].[Init_$RecreateExceptionFunctions]
AS
BEGIN
    SET NOCOUNT ON;
    -- Drop err Functions and procedures
    EXEC dsp.Schema_DropObjects @SchemaName = 'dsperr', @DropFunctions = 1, @DropProcedures = 1;

    -- Recreate err constant functions
    EXEC dsp.Init_RecreateEnumFunctions @SchemaName = 'dsperr', @TableSchemaName = 'dsp', @TableName = 'Exception', @KeyColumnName = 'ExceptionId',
        @TextColumnName = 'ExceptionName', @FunctionNamePostfix = 'Id';

    -- Recreate Throw procedures
    DECLARE @ExceptionId INT;
    DECLARE @ExceptionName TSTRING;

    DECLARE CreateFunctionCursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR SELECT E.ExceptionName, E.ExceptionId FROM dsp.Exception AS E;
    OPEN CreateFunctionCursor;
    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM CreateFunctionCursor
         INTO @ExceptionName, @ExceptionId;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        DECLARE @Sql TSTRING =
            '
CREATE PROCEDURE dsperr.Throw{@ExceptionName} @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = ''<notset>'', @Param1 TSTRING = ''<notset>'', @Param2 TSTRING = ''<notset>'', @Param3 TSTRING = ''<notset>''
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.{@ExceptionName}Id();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END'    ;
        SET @Sql = REPLACE(@Sql, '{@ExceptionName}', @ExceptionName);
        EXEC (@Sql);
    END;
    CLOSE CreateFunctionCursor;
    DEALLOCATE CreateFunctionCursor;

END;













GO
PRINT N'Creating [tCodeQuality].[Private_CompareConstFunctionReturnValueWithScriptValue]'
GO
CREATE PROCEDURE [tCodeQuality].[Private_CompareConstFunctionReturnValueWithScriptValue]
    @Script TBIGSTRING OUT, @ConstFunctionName TSTRING OUT, @ConstValueInFunction INT OUT, @ConstValueInScript INT OUT, @IsMatch BIT OUT
AS
BEGIN
    DECLARE @StartStrCharIndex INT;
    DECLARE @EndStrCharIndex INT;
    DECLARE @StartNumPadIndex INT;
    DECLARE @EndStrNumdIndex INT;
		
    SET @IsMatch = 0;
    SET @ConstValueInScript = NULL;
    SET @ConstValueInFunction = NULL;

    -- Getting Function Name
    SET @StartStrCharIndex = CHARINDEX('/*co' + 'nst.', @Script);
    IF (@StartStrCharIndex = 0)
        RETURN;

    SET @EndStrCharIndex = CHARINDEX('()*/', @Script, @StartStrCharIndex) + 2;
    SET @StartStrCharIndex = @StartStrCharIndex + 2;
    SET @ConstFunctionName = SUBSTRING(@Script, @StartStrCharIndex, @EndStrCharIndex - @StartStrCharIndex);

	-- Getting Function Value
    BEGIN TRY
        SET @Script = SUBSTRING(@Script, @EndStrCharIndex + 2, LEN(@Script));
        SET @StartNumPadIndex = PATINDEX('%[0-9]%', @Script);
        SET @EndStrNumdIndex = PATINDEX('%[^0-9]%', @Script);
        SET @ConstValueInScript = CAST(SUBSTRING(@Script, @StartNumPadIndex, @EndStrNumdIndex - @StartNumPadIndex) AS INT);
    END TRY
    BEGIN CATCH
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'ConstFunctionValue has written before ConstFunctionName!';
    END CATCH;

    --Getting Function Id
    BEGIN TRY
        DECLARE @SqlQuery TSTRING = 'SET @Id = ' + @ConstFunctionName;
        EXEC sys.sp_executesql @SqlQuery, N'@Id INT OUTPUT', @ConstValueInFunction OUTPUT;
        SET @IsMatch = IIF(@ConstValueInFunction = @ConstValueInScript, 1, 0);
    END TRY
    BEGIN CATCH
        SET @IsMatch = 0;
    END CATCH;

    DECLARE @StartIndex INT = (@EndStrCharIndex - @StartStrCharIndex);	
END;
GO
PRINT N'Creating [dsp].[Init_$CreateCommonExceptions]'
GO
-- Create common exception
CREATE PROCEDURE  [dsp].[Init_$CreateCommonExceptions]
AS
BEGIN
	-- SQL Prompt formatting off
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55002, N'AccessDeniedOrObjectNotExists');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55003, N'ObjectAlreadyExists');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55004, N'ObjectIsInUse');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55005, N'PageSizeTooLarge');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55006, N'InvalidArgument');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55007, N'FatalError');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55008, N'LockFailed');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55009, N'ValidationError');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55010, N'InvalidOperation');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55011, N'NotSupported');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55012, N'NotImplemeted');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55013, N'UserIsDisabled');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55014, N'AmbiguousException');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55015, N'NoOperation');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55016, N'InvalidCaptcha');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55017, N'BatchIsNotAllowed');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55018, N'TooManyRequest');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55019, N'AuthUserNotFound');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55020, N'InvokerAppVersion');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55021, N'Maintenance');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55022, N'MaintenanceReadOnly');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55023, N'InvalidParamSignature');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55024, N'DuplicateRequestException');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55025, N'HasNotSameStrcutre');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55026, N'GeneralException');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55027, N'ArgumentsAreNotSame');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55028, N'UnHandledException');
	INSERT dsp.Exception (ExceptionId, ExceptionName) VALUES (55029, N'ProductionEnvinronmentIsTurnedOn');
END
GO
PRINT N'Creating [dspconst].[Exception_DspFailErrorId]'
GO
CREATE FUNCTION [dspconst].[Exception_DspFailErrorId] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 60000;
END;
GO
PRINT N'Creating [dsptest].[ThrowFail]'
GO
CREATE PROCEDURE [dsptest].[ThrowFail]
    @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>',
    @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dspconst.Exception_DspFailErrorId();
	IF (dsp.Param_IsSetString(@Param0) = 1) --
		SET @Message = REPLACE(@Message, '{0}', @Param0);

    THROW @ExceptionId, @Message, 1;

END;
GO
PRINT N'Creating [dsp].[Database_$FunctionTypeName]'
GO
CREATE FUNCTION [dsp].[Database_$FunctionTypeName] (@Type TSTRING)
RETURNS TABLE
AS
RETURN SELECT   (CASE
                     WHEN @Type = 'IF'
                         THEN 'InlineFunction'
                     WHEN @Type = 'TF'
                         THEN 'TableValueFunction'
                     WHEN @Type = 'FN'
                         THEN 'Function'
                 END) TypeName;
GO
PRINT N'Creating [dsp].[Function_List]'
GO
CREATE FUNCTION [dsp].[Function_List] (@SchemaName TSTRING)
RETURNS TABLE
AS
RETURN SELECT   O.object_id FunctionId, --
           S.name AS FunctionSchemaName, --
           O.name AS FunctionName, --
           OBJECT_DEFINITION(O.object_id) AS FunctionDefinitionCode, --
           DFTN.TypeName FunctionTypeName --
         FROM   sys.objects AS O
                INNER JOIN sys.schemas AS S ON S.schema_id = O.schema_id
                CROSS APPLY dsp.[Database_$FunctionTypeName](O.type) AS DFTN
        WHERE   O.type IN ( 'FN', 'IF', 'TF' ) --
           AND  (S.name = @SchemaName OR @SchemaName IS NULL);




GO
PRINT N'Creating [tCodeQuality].[test All Parameters should be used in Procedure]'
GO
CREATE PROCEDURE [tCodeQuality].[test All Parameters should be used in Procedure]
AS
BEGIN
    DECLARE @ProcedureId INT;
    DECLARE @ProcedureSchemaName TSTRING;
    DECLARE @ProcedureName TSTRING;
    DECLARE @DefinitionCode TBIGSTRING;
    DECLARE @ProcedureTypeName TSTRING;

    DECLARE @ParameterObject TJSON;
    DECLARE @Procedures TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        ParameterObject TJSON);

    DECLARE Procedures_Cursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  SPL.StoredProcedureId, SPL.StoredProcedureSchemaName, SPL.StoredProcedureName, SPL.StoredProcedureDefinitionCode, 'P' AS ProcedureTypeName
      FROM  dsp.StoredProcedure_List(NULL) AS SPL
     WHERE  SPL.StoredProcedureSchemaName NOT IN ( 'tSQLt' )
    UNION ALL
    SELECT  FL.FunctionId, FL.FunctionSchemaName, FL.FunctionName, FL.FunctionDefinitionCode, FL.FunctionTypeName
      FROM  dsp.Function_List(NULL) AS FL;

    OPEN Procedures_Cursor;

    DECLARE @StartIndexDelimiter TSTRING;
    DECLARE @StartIndex BIGINT;
    DECLARE @Msg TSTRING;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM Procedures_Cursor
         INTO @ProcedureId, @ProcedureSchemaName, @ProcedureName, @DefinitionCode, @ProcedureTypeName;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        -- Remove whitespace from defination code
        SET @DefinitionCode = dsp.String_RemoveWhitespacesBig(@DefinitionCode);

        -- Validate Index after parameter declination
        SET @StartIndexDelimiter = IIF(@ProcedureTypeName = 'P', 'BEGIN', 'RET' + 'URNS');
        SET @StartIndex = CHARINDEX(@StartIndexDelimiter, @DefinitionCode);
        IF (@StartIndex = 0) --
        BEGIN
            SET @Msg = REPLACE(N'Procedure {0} has not BEGIN keyword', '{0}', @ProcedureName);
            EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Msg;
        END;

        -- Continue if procedure has not parameter
        IF NOT EXISTS (   SELECT    1
                            FROM    sys.parameters AS P
                           WHERE P.object_id = @ProcedureId --
        )
            CONTINUE;

        -- Get not used parameters
        SET @ParameterObject = (   SELECT   P.name
                                     FROM   sys.parameters AS P
                                    WHERE   P.name <> '' --
                                       AND  P.object_id = @ProcedureId --
                                       AND  CHARINDEX(P.name, @DefinitionCode, @StartIndex) = 0
                                   FOR JSON AUTO);

        IF (@ParameterObject IS NOT NULL)
            INSERT  @Procedures (SchemaName, ProcedureName, ParameterObject)
            VALUES (@ProcedureSchemaName, @ProcedureName, @ParameterObject);
    END;
    CLOSE Procedures_Cursor;
    DEALLOCATE Procedures_Cursor;

    IF EXISTS (SELECT   1 FROM  @Procedures AS P)
    BEGIN
        DECLARE @Message TBIGSTRING = '';
        SELECT  @Message = @Message + CONCAT('\n', P.SchemaName, '.', P.ProcedureName, ', Params: ', P.ParameterObject)
          FROM  @Procedures AS P
         ORDER BY P.SchemaName, P.ProcedureName;

        SET @Message = dsp.String_ReplaceEnter(@Message);

        DECLARE @ProceduresCount INT;
        SELECT  @ProceduresCount = COUNT(1)
          FROM  @Procedures AS P;

        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message;
    END;

END;
GO
PRINT N'Creating [dsp].[Init_$RecreateStringFunctions]'
GO
-- Create Procedure RecreateStringFunctions
CREATE PROCEDURE [dsp].[Init_$RecreateStringFunctions]
AS
BEGIN
    SET NOCOUNT ON;
    DECLARE @FunctionBody TSTRING =
						'
				CREATE FUNCTION @SchemaName.@KeyColumnValue() 
				RETURNS TSTRING
				AS 
				BEGIN
					RETURN dsp.StringTable_Value(''@KeyColumnValue'');
				END
						';

    EXEC dsp.Init_RecreateEnumFunctions @SchemaName = 'dspstr', @TableSchemaName = 'dsp', @TableName = 'StringTable', @KeyColumnName = 'StringId',
        @TextColumnName = 'StringValue', @FunctionBody = @FunctionBody;
END;
GO
PRINT N'Creating [dsp].[Util_IsEqual]'
GO
/*TO check if two input are equal*/
--null aware
CREATE FUNCTION [dsp].[Util_IsEqual] (
	@Value1 SQL_VARIANT,
	@Value2 SQL_VARIANT)
RETURNS BIT
AS
BEGIN
	RETURN IIF(@Value1 = @Value2 OR ISNULL(@Value1, @Value2) IS NULL, 1, 0);
END;


GO
PRINT N'Creating [dsp].[Param_IsChanged]'
GO

--Check if a parameter has been updated or not
CREATE FUNCTION [dsp].[Param_IsChanged] (
	@OldValue SQL_VARIANT,
	@NewValue SQL_VARIANT,
	@NullAsNotSet BIT
)
RETURNS BIT
AS
BEGIN
	RETURN IIF(dsp.Param_IsSetBase(@NewValue, @NullAsNotSet) = 1 AND dsp.Util_IsEqual(@OldValue, @NewValue) = 0, 1, 0);
END;




GO
PRINT N'Creating [dsptest].[Fail]'
GO
CREATE PROCEDURE [dsptest].[Fail]
    @ProcId INT, @Message0 TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>',
    @Param3 TSTRING = '<notset>'
AS
BEGIN
    EXEC dsptest.[ThrowFail] @ProcId = @ProcId, @Message = @Message0, @Param0 = @Param0, @Param1 = @Param1, @Param2 = @Param2, @Param3 = @Param3;
END;
GO
PRINT N'Creating [tCodeQuality].[test API must have Context TCONTEXT OUT]'
GO
CREATE PROCEDURE [tCodeQuality].[test API must have Context TCONTEXT OUT]
AS
BEGIN
    -- Declearing pattern
    DECLARE @Pattern_Context TCONTEXT = dsp.String_RemoveWhitespaces('@Context TCONTEXT OUT');

    DECLARE @SchemaName TSTRING = 'api';
    DECLARE @msg TSTRING;
    DECLARE @ProcedureName TSTRING;

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with api schema';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  @SchemaName, PD.StoredProcedureName, dsp.String_RemoveWhitespaces(PD.StoredProcedureDefinitionCode)
      FROM  dsp.StoredProcedure_List(@SchemaName) AS PD;

    -- Looking for "@Context TCONTEXT OUT" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "@Context TCONTEXT OUT" phrase';
    SELECT  @ProcedureName = SchemaName + '.' + ProcedureName
      FROM  @t
     WHERE  CHARINDEX(@Pattern_Context, Script) < 1;

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = '"@Context TCONTEXT OUT" phrase was not found in procedure: ' + @ProcedureName;
        EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = @msg;
    END;

END;

GO
PRINT N'Creating [dsp].[CheckIfChanged_Int]'
GO
CREATE FUNCTION [dsp].[CheckIfChanged_Int] (@NewValue BIGINT,
    @OldValue BIGINT,
    @NullAsNotSet BIT = 0)
RETURNS BIGINT
AS
BEGIN
    DECLARE @ResultValue BIGINT = @OldValue;
    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 1)
        SET @ResultValue = @NewValue;

    RETURN @ResultValue;
END;








GO
PRINT N'Creating [tCodeQuality].[test API must have Context_Verify]'
GO
CREATE PROCEDURE [tCodeQuality].[test API must have Context_Verify]
AS
BEGIN
    DECLARE @msg TSTRING;
    DECLARE @ProcedureName TSTRING;
    DECLARE @SchemaName TSTRING = 'api';

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with api schema';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  @SchemaName, VPD.StoredProcedureName, VPD.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(@SchemaName) AS VPD;

    -- Looking for "Context_Verify" in api procedure
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N' Looking for "Context_Verify" in api procedure';
    SELECT  @ProcedureName = SchemaName + '.' + ProcedureName
      FROM  @t
     WHERE  (SchemaName IN ( 'api' )) AND   Script NOT LIKE N'%dsp.Context_Verify%';

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = 'Code should contain dsp.Context_Verify in procedure: ' + @ProcedureName;
        EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = @msg;
    END;
END;

GO
PRINT N'Creating [dspInboxMessage].[Init_$InitSettings]'
GO
CREATE PROCEDURE [dspInboxMessage].[Init_$InitSettings]
AS
BEGIN
    SET NOCOUNT ON;

    ----------------
    -- Insert the only dsp.Settings record
    ----------------
    IF (NOT EXISTS (SELECT  1 FROM  dspInboxMessage.Setting))
    BEGIN
        -- Report it is done
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Creating default InboxMessage.Settings';
        INSERT  dspInboxMessage.Setting (SettingId)
        VALUES (1);
    END;    
END;
GO
PRINT N'Creating [dsp].[Convert_ToSqlvariant]'
GO


CREATE FUNCTION [dsp].[Convert_ToSqlvariant] (@Value TBIGSTRING)
RETURNS SQL_VARIANT
AS
BEGIN
	RETURN CAST(@Value AS NVARCHAR(4000));
END;

GO
PRINT N'Creating [tCodeQuality].[test API must have WITH EXECUTE AS OWNER]'
GO
CREATE PROCEDURE [tCodeQuality].[test API must have WITH EXECUTE AS OWNER]
AS
BEGIN
    -- Declaring pattern
    DECLARE @Pattern_WithExecuteASOwner TSTRING = dsp.String_RemoveWhitespaces('WITH EXECUTE AS OWNER');
    DECLARE @Pattern_WithExecASOwner TSTRING = dsp.String_RemoveWhitespaces('WITH EXEC AS OWNER');
    DECLARE @msg TSTRING;
    DECLARE @SchemaName TSTRING = 'api';

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with pagination';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);

    INSERT INTO @t
    SELECT  @SchemaName, PD.StoredProcedureName, dsp.String_RemoveWhitespacesBig(PD.StoredProcedureDefinitionCode)
      FROM  dsp.StoredProcedure_List(@SchemaName) AS PD;

    -- Looking for "With Execute AS Owner" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "With Execute AS Owner" phrase';
    SET @msg = (   SELECT   SchemaName + '.' + ProcedureName AS ProcedureName
                     FROM   @t
                    WHERE   CHARINDEX(@Pattern_WithExecuteASOwner, Script) = 0 AND  CHARINDEX(@Pattern_WithExecASOwner, Script) = 0
                   FOR JSON AUTO);

    IF (@msg IS NOT NULL) --
        EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = @msg;
END;

GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessSendMessageTag_RandomString]'
GO
CREATE   FUNCTION [dspInboxMessage].[InboxMessageProcessSendMessageTag_RandomString] ()
RETURNS NVARCHAR(50)
WITH SCHEMABINDING
AS
BEGIN
    RETURN '@@RandomString';
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessSendMessageTag_RandomNumber]'
GO
CREATE   FUNCTION [dspInboxMessage].[InboxMessageProcessSendMessageTag_RandomNumber] ()
RETURNS NVARCHAR(50)
WITH SCHEMABINDING
AS
BEGIN
    RETURN '@@RandomNumber';
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessSendMessageTag_DefaultValue]'
GO
CREATE   FUNCTION [dspInboxMessage].[InboxMessageProcessSendMessageTag_DefaultValue] ()
RETURNS NVARCHAR(50)
WITH SCHEMABINDING
AS
BEGIN
    RETURN '@@DefaultValue';
END;
GO
PRINT N'Creating [dspInboxMessage].[Message_$BuildByDynamicExpression]'
GO
CREATE PROCEDURE [dspInboxMessage].[Message_$BuildByDynamicExpression]
    @Message TSTRING, @DefaultValue TSTRING, @ConfirmHasCustomValidation BIT, @ResultMessage TSTRING = NULL OUTPUT, @ConfirmValue TSTRING OUTPUT
AS
BEGIN
    -- Parameters
    DECLARE @InboxMessageProcessSendMessageTag_RandomString TSTRING = dspInboxMessage.InboxMessageProcessSendMessageTag_RandomString();
    DECLARE @InboxMessageProcessSendMessageTag_RandomNumber TSTRING = dspInboxMessage.InboxMessageProcessSendMessageTag_RandomNumber();
    DECLARE @InboxMessageProcessSendMessageTag_DefaultValue TSTRING = dspInboxMessage.InboxMessageProcessSendMessageTag_DefaultValue();

    -- Buiild corresponding message
    IF CHARINDEX(@InboxMessageProcessSendMessageTag_RandomString, @Message) > 0
    BEGIN
        EXEC dsp.String_CreateRandom @Length = 4, @RandomString = @ConfirmValue OUTPUT, @IncludeLetter = 1, @IncludeDigit = 1;
        SET @ResultMessage = REPLACE(@Message, @InboxMessageProcessSendMessageTag_RandomString, @ConfirmValue);
    END;
    -- Prpare @@RandomNumber
    ELSE IF CHARINDEX(@InboxMessageProcessSendMessageTag_RandomNumber, @Message) > 0
    BEGIN
        EXEC dsp.String_CreateRandom @Length = 4, @RandomString = @ConfirmValue OUTPUT, @IncludeLetter = 0, @IncludeDigit = 1;
        SET @ResultMessage = REPLACE(@Message, @InboxMessageProcessSendMessageTag_RandomNumber, @ConfirmValue);
    END;
    -- Prepare @@DefaultValue
    ELSE IF CHARINDEX(@InboxMessageProcessSendMessageTag_DefaultValue, @Message) > 0
    BEGIN
        SET @ConfirmValue = ISNULL(@DefaultValue, '');
        SET @ResultMessage = REPLACE(@Message, @InboxMessageProcessSendMessageTag_DefaultValue, @ConfirmValue);
    END;
END;
GO
PRINT N'Creating [dsp].[Init_$InitSettings]'
GO
CREATE PROCEDURE [dsp].[Init_$InitSettings]
AS
BEGIN
    SET NOCOUNT ON;

    ----------------
    -- Insert the only dsp.Settings record
    ----------------
    IF (NOT EXISTS (SELECT  1 FROM  dsp.Setting))
    BEGIN
        -- Report it is done
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Creating default dsp.Settings';
        INSERT  dsp.Setting (SettingId)
        VALUES (1);
    END;    
END;

GO
PRINT N'Creating [dsp].[CheckIfChanged_String]'
GO
CREATE	FUNCTION [dsp].[CheckIfChanged_String] (@NewValue TSTRING,
	@OldValue TSTRING,
	@NullAsNotSet BIT = 0)
RETURNS TSTRING
AS
BEGIN
	DECLARE @ResultValue TSTRING = @OldValue;

	IF (dsp.Param_IsChanged(dsp.Convert_ToSqlvariant(@OldValue), dsp.Convert_ToSqlvariant(@NewValue), @NullAsNotSet) = 1)
		SET @ResultValue = @NewValue;

	RETURN @ResultValue;
END;








GO
PRINT N'Creating [tCodeQuality].[test const Functions must have WITH SCHEMABINDING]'
GO
CREATE PROCEDURE [tCodeQuality].[test const Functions must have WITH SCHEMABINDING]
AS
BEGIN

    -- Declaring pattern
    DECLARE @Pattern_Context TCONTEXT = dsp.String_RemoveWhitespaces('WITH SCHEMABINDING');

    DECLARE @msg TSTRING;
    DECLARE @FunctionName TSTRING;
    DECLARE @SchemaName TSTRING = 'const';

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all functions with const schema';
    DECLARE @t TABLE (SchemaName TSTRING,
        FunctionName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  @SchemaName, PD.StoredProcedureName, dsp.String_RemoveWhitespaces(PD.StoredProcedureDefinitionCode)
      FROM  dsp.StoredProcedure_List(@SchemaName) AS PD;

    -- Looking for "@Context TCONTEXT OUT" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "WITH SCHEMABINDING" phrase';
    SELECT  @FunctionName = SchemaName + '.' + FunctionName
      FROM  @t
     WHERE  CHARINDEX(@Pattern_Context, Script) < 1 AND CHARINDEX('TSTRING', Script) = 0;

    IF (@FunctionName IS NOT NULL)
    BEGIN
        SET @msg = '"WITH SCHEMABINDING" phrase was not found in Function: ' + @FunctionName;
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
    END;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ValidateCustomConfirmValue]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ValidateCustomConfirmValue]
    @ProviderInfoId INT, @Address TSTRING, @MessageBody TSTRING, @IsValid BIT OUTPUT
AS
BEGIN
    -- It must be overwrite by client
    BEGIN TRY
        EXEC InboxMessage.[InboxMessageProcess_ValidateCustomConfirmValue] @ProviderInfoId = @ProviderInfoId, @Address = @Address, @MessageBody = @MessageBody,
            @IsValid = @IsValid OUTPUT;
    END TRY
    BEGIN CATCH
        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;
END;

GO
PRINT N'Creating [dsp].[Table_DeleteRecords]'
GO
CREATE PROCEDURE [dsp].[Table_DeleteRecords]
AS
BEGIN

    DECLARE @DeleteSqlCmd NVARCHAR(MAX);
    DECLARE @DeletetableName TSTRING;
    DECLARE @objectId INT;
    DECLARE @ConstraintName TSTRING;
    DECLARE @NOCHECKCONSTRAINT TSTRING;
    DECLARE @CHECKCONSTRAINT TSTRING;
    DECLARE @SchemaName TSTRING;
    DECLARE @IsTemporal BIT;

    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;

    BEGIN TRY
        -- Disable all constraints
        EXEC sys.sp_MSforeachtable 'ALTER TABLE ? NOCHECK CONSTRAINT all';

        -- Get list all tables for delete
        DECLARE Constraint_Cursor CURSOR FOR
        SELECT  s.name AS SchemaName, t.name, t.object_id, SFKT.name AS constraintname
          FROM  sys.tables t
                INNER JOIN sys.schemas s ON s.schema_id = t.schema_id
                OUTER APPLY dsp.Table_GetForeignKeys(DEFAULT, t.name) SFKT
         WHERE  s.name <> N'tSQLt' AND  t.temporal_type <> 1;


        OPEN Constraint_Cursor;
        FETCH NEXT FROM Constraint_Cursor
         INTO @SchemaName, @DeletetableName, @objectId, @ConstraintName;

        WHILE @@FETCH_STATUS = 0
        BEGIN
            SET @IsTemporal =
                IIF(
                EXISTS (SELECT  history_table_id FROM   sys.tables WHERE object_id = OBJECT_ID(@SchemaName + '.' + @DeletetableName) AND
                                                                       history_table_id IS NOT NULL),
                1,
                0);

            IF @IsTemporal = 1
                EXEC dsp.Table_DisableTemporalAttribute @SchemaName = @SchemaName, @TableName = @DeletetableName;

            IF @IsTemporal = 1
            BEGIN
                SET @DeleteSqlCmd = N'DELETE FROM ' + @SchemaName + N'.' + @DeletetableName + N'History';
                EXEC (@DeleteSqlCmd);
            END;
            SET @DeleteSqlCmd = N'DELETE FROM ' + @SchemaName + N'.' + @DeletetableName;
            EXEC (@DeleteSqlCmd);

            -- Disable all Temporal
            IF @IsTemporal = 1
                EXEC dsp.Table_EnableTemporalAttribute @SchemaName = @SchemaName, @TableName = @DeletetableName;


            FETCH NEXT FROM Constraint_Cursor
             INTO @SchemaName, @DeletetableName, @objectId, @ConstraintName;
        END;

        CLOSE Constraint_Cursor;
        DEALLOCATE Constraint_Cursor;

        -- Enable all constraints
        EXEC sys.sp_MSforeachtable 'ALTER TABLE ? WITH CHECK CHECK CONSTRAINT all';

        -- Enable temporaltype extended property


        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH;
END;
GO
PRINT N'Creating [tCodeQuality].[test DataAccessMode annotation existance in proc]'
GO
CREATE PROCEDURE [tCodeQuality].[test DataAccessMode annotation existance in proc]
AS
BEGIN
    DECLARE @SchemaName TSTRING = 'api';
    DECLARE @msg TBIGSTRING = --
            (   SELECT  CHAR(10) + @SchemaName + '.' + SPM.StoredProcedureName
                  FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
                 WHERE  JSON_VALUE(SPM.StoredProcedureMetadata, '$.DataAccessMode') IS NULL
                FOR XML PATH(''));

    DECLARE @msg2 TBIGSTRING = --
            (   SELECT  CHAR(10) + @SchemaName + '.' + SPM.StoredProcedureName
                  FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
                 WHERE  JSON_VALUE(SPM.StoredProcedureMetadata, '$.DataAccessMode') IS NOT NULL --
                    AND JSON_VALUE(SPM.StoredProcedureMetadata, '$.DataAccessMode') NOT IN ( 'Read', 'Write', 'ReadSnapshot' )
                FOR XML PATH(''));

    IF (@msg IS NOT NULL) --		
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;

    IF (@msg2 IS NOT NULL) --
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = N'Procedures with wrong value of DataAccessMode {0}', @Param0 = @msg2;
END;
GO
PRINT N'Creating [dsp].[Init_$ImpCleanup]'
GO
CREATE PROCEDURE [dsp].[Init_$ImpCleanup]
AS
BEGIN
    SET NOCOUNT ON;
    -- Protect production environment
    EXEC dsp.Util_ProtectProductionEnvironment;

    -- delete all table's records in test environment
    EXEC dsp.Table_DeleteRecords;
END;



GO
PRINT N'Creating [tCodeQuality].[test dbo should not have WITH EXECUTE AS OWNER]'
GO
CREATE PROCEDURE [tCodeQuality].[test dbo should not have WITH EXECUTE AS OWNER]
AS
BEGIN
    -- Declaring pattern
    DECLARE @Pattern_WithExecuteASOwner TSTRING = dsp.String_RemoveWhitespaces('WITH EXECUTE AS OWNER');
    DECLARE @Pattern_WithExecASOwner TSTRING = dsp.String_RemoveWhitespaces('WITH EXEC AS OWNER');
    DECLARE @msg TSTRING;
    DECLARE @ProcedureName TSTRING;

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with pagination';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  PD.StoredProcedureSchemaName, PD.StoredProcedureName, PD.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(NULL) AS PD
     WHERE  PD.StoredProcedureSchemaName IN ( 'dsp', 'dbo', 'perm' );

    -- Looking for "With Execute AS Owner" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "With Execute AS Owner" phrase';
    SELECT  @ProcedureName = SchemaName + '.' + ProcedureName
      FROM  @t
     WHERE  CHARINDEX(@Pattern_WithExecuteASOwner, Script) > 0 OR   CHARINDEX(@Pattern_WithExecASOwner, Script) > 0;

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = '"With Execute AS Owner" phrase was found in procedure: ' + @ProcedureName;
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
    END;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcessKeyTag_ConfirmValue]'
GO
CREATE FUNCTION [dspInboxMessage].[InboxMessageProcessKeyTag_ConfirmValue] ()
RETURNS NVARCHAR(50)
WITH SCHEMABINDING
AS
BEGIN
    RETURN 'ConfirmValue';
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$AppendToMessageLastData]'
GO
CREATE FUNCTION [dspInboxMessage].[InboxMessageProcess_$AppendToMessageLastData] (@MessageLastData NVARCHAR(MAX /*NCQ*/),
    @MsgKey NVARCHAR(MAX /*NCQ*/),
    @MsgValue NVARCHAR(MAX /*NCQ*/))
RETURNS NVARCHAR(MAX /*NCQ*/)
WITH SCHEMABINDING
AS
BEGIN
    RETURN (JSON_MODIFY(ISNULL(@MessageLastData, '[]'), 'append $', JSON_QUERY((   SELECT   @MsgKey AS MsgKey, @MsgValue AS MsgValue
                                                                                   FOR JSON PATH, WITHOUT_ARRAY_WRAPPER))));
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessConfirmStep]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessConfirmStep]
    @MessagePatternStepTypeId INT, @ProviderInfoId INT, @Address TSTRING, @MessageBody TSTRING, @DefaultValue TSTRING, @ConfirmHasCustomValidation BIT,
    @WaitStepId INT, @MessagePatternStepId INT, @SendMessageValue TSTRING, @MessageLastData TJSON = NULL OUTPUT, @DoBreak BIT = NULL OUTPUT,
    @InboxMessageProcessStateId INT = NULL OUTPUT
AS
BEGIN
    DECLARE @ConfirmValue TSTRING;

    -- Declare const variable
    DECLARE @StepType_Confirm INT = dspconst.MessagePatternStepType_Confirm();
    DECLARE @InboxMessageProcessKeyTag_ConfirmValue TSTRING = dspInboxMessage.InboxMessageProcessKeyTag_ConfirmValue();
    SET @DoBreak = 1;

    -- If StepType is not confirm message, so return
    IF (@MessagePatternStepTypeId <> @StepType_Confirm) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Invalid StepType in confirm';

    -- If current message is reply message, validate message value
    IF (@WaitStepId IS NOT NULL AND @WaitStepId = @MessagePatternStepId)
    BEGIN
        DECLARE @CustomConfirmationIsValid BIT = 0;
        IF @ConfirmHasCustomValidation = 1
            EXEC dspInboxMessage.[InboxMessageProcess_$ValidateCustomConfirmValue] @ProviderInfoId = @ProviderInfoId, @Address = @Address,
                @MessageBody = @MessageBody, @IsValid = @CustomConfirmationIsValid;
        ELSE
            -- Get ConfirmValue
            SELECT  @ConfirmValue = MsgValue
              FROM  dspInboxMessage.MessageLastData_ReadJson(@MessageLastData)
             WHERE  MsgKey = @InboxMessageProcessKeyTag_ConfirmValue;

        -- Validate ConfirmValue
        IF (@CustomConfirmationIsValid = 1 OR   @ConfirmValue IS NULL OR (@ConfirmValue IS NOT NULL AND @MessageBody = @ConfirmValue))
            SET @DoBreak = 0;
        ELSE
        BEGIN
            SET @InboxMessageProcessStateId = dspconst.InboxMessageProcessState_CustomConfirmFailed();

            -- Get from setting
            EXEC dspInboxMessage.Setting_GetProps @FailedConfirmStepMessage = @SendMessageValue OUTPUT;

            -- Call send message
            IF @SendMessageValue IS NOT NULL
                EXEC dspInboxMessage.[InboxMessageProcess_$SendReplyMessage] @ProviderInfoId = @ProviderInfoId, @Address = @Address,
                    @SendMessageValue = @SendMessageValue, @MessagePatternStepId = @MessagePatternStepId;
        END;

        RETURN;
    END;

    -- Prepare message to send
    -- Prpare @@RandomString
    EXEC dspInboxMessage.[Message_$BuildByDynamicExpression] @Message = @SendMessageValue, @DefaultValue = @DefaultValue,
        @ConfirmHasCustomValidation = @ConfirmHasCustomValidation, @ResultMessage = @SendMessageValue OUTPUT, @ConfirmValue = @ConfirmValue OUTPUT;

    IF @ConfirmHasCustomValidation = 1
        SET @ConfirmValue = 'CustomConfirmValidation';

    -- Call send message
    EXEC dspInboxMessage.[InboxMessageProcess_$SendReplyMessage] @ProviderInfoId = @ProviderInfoId, @Address = @Address, @SendMessageValue = @SendMessageValue,
        @MessagePatternStepId = @MessagePatternStepId;

    -- Delete all key with confirm tag and insert new confirm tag into LastData
    SET @MessageLastData = (   SELECT   *
                                 FROM   dspInboxMessage.MessageLastData_ReadJson(@MessageLastData)
                                WHERE   MsgKey <> @InboxMessageProcessKeyTag_ConfirmValue
                               FOR JSON AUTO);

    -- insert new confirm tag into LastData
    SET @MessageLastData =
        dspInboxMessage.[InboxMessageProcess_$AppendToMessageLastData](@MessageLastData, @InboxMessageProcessKeyTag_ConfirmValue, @ConfirmValue);

    -- insert into waitReply table with new LastData
    EXEC dspInboxMessage.[InboxMessageProcess_$CreateWaitForReplyMessage] @Address = @Address, @MessagePatternStepId = @MessagePatternStepId,
        @MessageLastData = @MessageLastData, @ProviderInfoId = @ProviderInfoId;
END;
GO
PRINT N'Creating [dsp].[Convert_BinaryFromBase64]'
GO

-- #Inliner {"InlineMode":"none"} 
CREATE FUNCTION [dsp].[Convert_BinaryFromBase64](@Base64 TSTRING)
RETURNS VARBINARY(MAX)
AS
BEGIN
    DECLARE @Bin VARBINARY(MAX)
    /*
        SELECT CONVERT(TSTRING, dbo.f_Base64ToBinary('Q29udmVydGluZyB0aGlzIHRleHQgdG8gQmFzZTY0Li4u'))
    */
    SET @Bin = CAST(N'' AS XML).value('xs:base64Binary(sql:variable("@Base64"))', 'VARBINARY(MAX)')
    RETURN @Bin
END


GO
PRINT N'Creating [tCodeQuality].[test Declare BIGINT]'
GO
CREATE PROCEDURE [tCodeQuality].[test Declare BIGINT]
AS
BEGIN
    -- Getting procedures which have bigint columns with int declaration
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting procedures which have bigint columns with int declaration';
    DECLARE @ProcInfo TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        DEFINITION TBIGSTRING,
        ColumnName TSTRING);
    INSERT  @ProcInfo (SchemaName, ProcedureName, DEFINITION, ColumnName)
    EXEC tCodeQuality.Private_ColumnsWithBigintTypes;

    -- Checking if there is any wrong type for Bigint Columns
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Checking if there is any wrong type for Bigint Columns';
    DECLARE @ProcName TSTRING = '';
    DECLARE @ParamName TSTRING = '';
    IF EXISTS (SELECT   1 FROM  @ProcInfo AS PI)
    BEGIN
        DECLARE @Message TSTRING =
                (   SELECT      CHAR(10) + N'in the procedure "' + PI.SchemaName + '.' + PI.ProcedureName + '", parameter "',
                        PI.ColumnName + '" has wrong parameter data type!'
                      FROM      @ProcInfo AS PI
                    FOR XML PATH(''));

        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message;
    END;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessInputOutputStep]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessInputOutputStep]
    @MessagePatternStepId INT, @MessagePatternStepTypeId INT, @DefaultValue TSTRING, @MessageBodyCurrentValue TSTRING, @ParameterName TSTRING,
    @Address TSTRING, @ProviderInfoId INT, @MessageLastData TJSON OUTPUT, @DoBreak BIT OUTPUT, @HasCustomValue BIT, @UsedMessageBodyCurrentValue BIT OUTPUT
AS
BEGIN
    -- Declare const variable
    DECLARE @StepType_InputParam INT = dspconst.MessagePatternStepType_InputParam();
    DECLARE @StepType_OutputParam INT = dspconst.MessagePatternStepType_OutputParam();
    DECLARE @StepType_InputOutputParam INT = dspconst.MessagePatternStepType_InputOutputParam();
    DECLARE @InboxMessageProcessKeyTag_ParameterSpecification TSTRING = dspInboxMessage.InboxMessageProcessKeyTag_ParameterSpecification();
    DECLARE @ParameterValue TSTRING;
    DECLARE @ParamType TSTRING;
    DECLARE @ParameterSpec TJSON;

    -- Initialize output parameter
    SET @DoBreak = 0;
    SET @UsedMessageBodyCurrentValue = 0;

    -- If StepType is not input so return
    IF @MessagePatternStepTypeId NOT IN ( @StepType_InputParam, @StepType_InputOutputParam, @StepType_OutputParam )
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Invalid SteptypeId';

    -- These types need parameter value
    IF @MessagePatternStepTypeId IN ( @StepType_InputParam, @StepType_InputOutputParam )
    BEGIN
        SET @ParameterValue = NULL;

        IF @HasCustomValue = 1
        BEGIN
            EXEC dspInboxMessage.InboxMessageProcess_$GetCustomValue @ProviderInfoId = @ProviderInfoId, @Address = @Address,
                @MessageLastData = @MessageLastData, @MessagePatternStepId = @MessagePatternStepId, @ParameterName = @ParameterName,
                @ParameterValue = @ParameterValue OUTPUT;
            SET @ParameterValue = ISNULL(@ParameterValue, dspInboxMessage.InboxMessageProcessKeyTag_NullExpression());
        END;

        -- If Step has DefaultValue, fill itself by DefaultValue and do not wait for MessageBody
        IF (@DefaultValue IS NOT NULL)
            SET @ParameterValue = @DefaultValue;

        --If has value in MessageBody then add to LastData and go to next step
        IF (@ParameterValue IS NULL AND @MessageBodyCurrentValue IS NOT NULL)
        BEGIN
            SET @ParameterValue = @MessageBodyCurrentValue;
            SET @UsedMessageBodyCurrentValue = 1;
        END;

        --If dont have value in message body, insert request and wait for new message body
        IF (@ParameterValue IS NULL)
        BEGIN
            -- Insert into waitReply table with @MessageLastData
            EXEC dspInboxMessage.[InboxMessageProcess_$CreateWaitForReplyMessage] @Address = @Address, @MessagePatternStepId = @MessagePatternStepId,
                @MessageLastData = @MessageLastData, @ProviderInfoId = @ProviderInfoId;

            SET @DoBreak = 1;
            RETURN;
        END;
    END;

    -- Detect parameter type
    SET @ParamType = CASE @MessagePatternStepTypeId
                         WHEN @StepType_InputParam
                             THEN 'Input'
                         WHEN @StepType_InputOutputParam
                             THEN 'Output'
                         WHEN @StepType_OutputParam
                             THEN 'Output'
                     END;

    -- Put parameter specifications into MessageLastData and continue
    SET @ParameterSpec = (   SELECT @ParameterName AS ParamName, @ParamType AS ParamType, @ParameterValue AS ParamValue
                             FOR JSON PATH, WITHOUT_ARRAY_WRAPPER);

    SET @MessageLastData =
        dspInboxMessage.[InboxMessageProcess_$AppendToMessageLastData](@MessageLastData, @InboxMessageProcessKeyTag_ParameterSpecification, @ParameterSpec);
END;

GO
PRINT N'Creating [dsp].[Metadata_IsObjectExists]'
GO
CREATE	FUNCTION [dsp].[Metadata_IsObjectExists] (@SchemaName TSTRING,
	@ObjectName TSTRING,
	@TypeName TSTRING)
RETURNS BIT
BEGIN

	DECLARE @IsExist BIT = 0;
	SELECT	@IsExist = 1
	FROM	sys.objects AS O
			INNER JOIN sys.schemas
AS		S ON O.schema_id = S.schema_id
	WHERE	S.name = @SchemaName --
		AND O.name = @ObjectName --
		AND O.type = @TypeName;
	RETURN @IsExist;

END;
GO
PRINT N'Creating [dspconst].[Exception_ProductionEnvironmentId]'
GO
CREATE FUNCTION [dspconst].[Exception_ProductionEnvironmentId] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1000000000;
END;
GO
PRINT N'Creating [dsp].[Init_$Cleanup]'
GO
CREATE PROCEDURE [dsp].[Init_$Cleanup]
    @IsProductionEnvironment BIT OUT, @IsWithCleanup BIT OUT
AS
BEGIN
    -- Set IsProductionEnvironment after creating Setting and Initializing Exceptions and Strings 
    DECLARE @OldIsProductionEnvironment INT;
    EXEC dsp.Setting_GetProps @IsProductionEnvironment = @OldIsProductionEnvironment OUTPUT;

    -- Find IsProductionEnvironment and IsWithCleanup default depending of current state
    SET @IsProductionEnvironment = ISNULL(@IsProductionEnvironment, @OldIsProductionEnvironment); -- Don't change IsProductionEnvironment if it is not changed
    IF (@IsWithCleanup IS NULL)
        SET @IsWithCleanup = IIF(@IsProductionEnvironment = 1, 0, 1);

    -- validate arguments    
    IF (@IsProductionEnvironment = 0 AND @OldIsProductionEnvironment = 1) --
        EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'dsp.Init cannot unset IsProductionEnvironment setting!';

    IF (@IsProductionEnvironment = 1 AND @IsWithCleanup = 1) --
        EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'Could not execute Cleanup in production environment!';

    -- Update IsProductionEnvironment
    EXEC dsp.Setting_SetProps @IsProductionEnvironment = @IsProductionEnvironment;

    -- Raise error in production environment if IsWithCleanup is set
    IF (@IsWithCleanup = 0) --
        RETURN;

    -- Make sure dbo.Init_Cleanup has production protection
    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;

    SAVE TRANSACTION Test;
    BEGIN TRY
        EXEC dsp.Setting_SetProps @IsProductionEnvironment = 1;
        EXEC dsp.[Init_$ImpCleanup];
        EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = 'Could not detect dsp.Init_Cleanup protection control for production environment';
    END TRY
    BEGIN CATCH
        ROLLBACK TRANSACTION Test;
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;

        IF (ERROR_NUMBER() = dspconst.Exception_ProductionEnvironmentId() AND
            CHARINDEX('This operation can not be executed in ProductionEnvironment', ERROR_MESSAGE()) > 0)
            THROW;
    END CATCH;

    -- Read CleanUp
    DECLARE @DataBaseName TSTRING = DB_NAME();
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Cleaning "{1}" database of "{0}"', @Param0 = @@SERVERNAME, @Param1 = @DataBaseName;

    -- Cleanup dbo
    EXEC dsp.[Init_$ImpCleanup];

    -- CleanUp dspAuth if exists
    IF (dsp.Metadata_IsObjectExists('dspAuth', 'Init_Cleanup', 'P') = 1) EXEC ('EXEC dspAuth.Init_Cleanup');
END;














GO
PRINT N'Creating [tCodeQuality].[test Declare generic types INT, TSTRING]'
GO
CREATE PROCEDURE [tCodeQuality].[test Declare generic types INT, TSTRING]
AS
BEGIN
    DECLARE @msg TSTRING;
    DECLARE @ProcedureName TSTRING;

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with api schema';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  PD.StoredProcedureSchemaName, PD.StoredProcedureName, PD.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List('api') AS PD
     WHERE  PD.StoredProcedureName NOT IN ( 'Convert_ToString', 'Convert_ToSqlvariant', 'CRYPT_PBKDF2_VARBINARY_SHA512' );

    -- Looking for "tinyint and smallint" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "tinyint and smallint" phrase';
    SET @ProcedureName = STUFF((   SELECT   '\n' + SchemaName + '.' + ProcedureName
                                     FROM   @t
                                    WHERE   (SchemaName IN ( 'dbo', 'api', 'dsp' )) AND (CHARINDEX('tinyint', Script) > 0 OR CHARINDEX('smallint', Script) > 0)
                                   FOR XML PATH('')), 1, 2, '');

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = 'Code should not contains SMALLINT or TINYINT in procedure: \n' + @ProcedureName;
        SET @msg = dsp.String_ReplaceEnter(@msg);
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
    END;

    -- Looking for "NVARCHAR(MAX)" phrase
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Looking for "NVARCHAR(MAX)" phrase';
    SET @ProcedureName = STUFF((   SELECT   '\n' + SchemaName + '.' + ProcedureName
                                     FROM   @t
                                    WHERE   (SchemaName IN ( 'dbo', 'api', 'dsp' )) AND (Script LIKE '%VARCHAR([0-9]%' OR   Script LIKE '%VARCHAR(MAX)%')
                                   FOR XML PATH('')), 1, 2, '');

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = 'Code should not contains NVARCHAR(XX) in procedure: \n' + @ProcedureName;
        SET @msg = dsp.String_ReplaceEnter(@msg);
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
    END;

END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessSendMessageStep]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessSendMessageStep]
    @MessagePatternStepTypeId INT, @SendMessageValue TSTRING, @ProviderInfoId INT, @Address TSTRING, @MessagePatternStepId INT
AS
BEGIN
    -- Declare const variable
    DECLARE @StepType_SendMessage INT = dspconst.MessagePatternStepType_SendMessage();

    -- If StepType is not send message so return
    IF (@MessagePatternStepTypeId <> @StepType_SendMessage) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Invalid SteptypeId in send message';

    -- Call Api.SendMessage
    EXEC dspInboxMessage.InboxMessageProcess_$SendReplyMessage @ProviderInfoId = @ProviderInfoId, @Address = @Address, @SendMessageValue = @SendMessageValue,
        @MessagePatternStepId = @MessagePatternStepId;
END;

GO
PRINT N'Creating [dsp].[Init_$SetUp]'
GO
CREATE PROCEDURE [dsp].[Init_$SetUp]
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @Sql TSTRING;
    DECLARE @Schema TSTRING;
    DECLARE @ObjectName TSTRING;

    -------------------------
    -- Schemas
    -------------------------

    -- try to create err schema
    IF SCHEMA_ID('dsperr') IS NULL
    BEGIN
        PRINT 'Creating schema: dsperr ';
        EXEC sys.sp_executesql N'CREATE SCHEMA [dsperr]';
    END;

    -- try to create str schema
    IF SCHEMA_ID('dspstr') IS NULL
    BEGIN
        PRINT 'Creating schema: dspstr';
        EXEC sys.sp_executesql N'CREATE SCHEMA [dspstr]';
    END;

    -- try to create const schema
    IF SCHEMA_ID('dspconst') IS NULL
    BEGIN
        PRINT 'Creating schema: dspconst';
        EXEC sys.sp_executesql N'CREATE SCHEMA [dspconst]';

    END;
END;








GO
PRINT N'Creating [dsp].[Convert_RowVersionToString]'
GO
CREATE FUNCTION [dsp].[Convert_RowVersionToString] (@Value VARBINARY(/*Ignore CC*/8))
RETURNS TSTRING
BEGIN
    RETURN CONVERT(NVARCHAR(/*Ignore CC*/4000), CONVERT(BINARY(8), @Value), 1);
END;





GO
PRINT N'Creating [tCodeQuality].[test Description must be nvarchar(max)]'
GO
CREATE PROCEDURE [tCodeQuality].[test Description must be nvarchar(max)]
AS
BEGIN
    DECLARE @Msg TSTRING;
    SELECT  @Msg = QUOTENAME(SCHEMA_NAME(tb.schema_id)) + '.' + QUOTENAME(OBJECT_NAME(tb.object_id))
      FROM  sys.columns C
            INNER JOIN sys.tables tb ON tb.object_id = C.object_id
            INNER JOIN sys.types T ON C.system_type_id = T.user_type_id
     WHERE  tb.is_ms_shipped = 0 --
        AND C.name LIKE N'%Description%' --
        AND (T.name <> 'nvarchar' OR C.max_length != -1);

    IF (@Msg IS NOT NULL)
    BEGIN
        SET @Msg = '"Description and type TSTRING" was not found in table ' + @Msg;
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Msg;
    END;
END;
GO
PRINT N'Creating [dbo].[Init_$InitSettings]'
GO
CREATE PROCEDURE [dbo].[Init_$InitSettings]
AS
BEGIN
    -- Tof
    RETURN 1;
END;
GO
PRINT N'Creating [DatabaseVersioning].[Init_$InitSettings]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Init_$InitSettings]
AS
BEGIN
    SET NOCOUNT ON;

    ----------------
    -- Insert the only dsp.Settings record
    ----------------
    IF (NOT EXISTS (SELECT  1 FROM  DatabaseVersioning.Setting))
    BEGIN
        -- Report it is done
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Creating default DatabaseVersioning.Settings';
        INSERT  DatabaseVersioning.Setting (Id)
        VALUES (1);
    END;    
END;
GO
PRINT N'Creating [dsp].[Init_$Start]'
GO
CREATE PROCEDURE [dsp].[Init_$Start]
    @IsProductionEnvironment BIT = NULL, @IsWithCleanup BIT = NULL, @Reserved BIT = NULL, @DoNotDisableTemporalForActiveTemporal BIT = 1
AS
BEGIN
    SET NOCOUNT ON;
    SET @Reserved = ISNULL(@Reserved, 1);

    -- SetUp DirectSp procedures and tables
    EXEC dsp.[Init_$SetUp];

    ----------------
    -- Check Production Environment and Run Cleanup
    ----------------	
    -- Cleanup is using setting so do init setting before cleanup but because cleanup cleaned the setting table we should do init setting again
    EXEC dsp.[Init_$Cleanup] @IsProductionEnvironment = @IsProductionEnvironment OUT, @IsWithCleanup = @IsWithCleanup OUT;

    -- Be carefull: in production environment, setting tables must not be owerwrite
    IF (@IsWithCleanup = 1)
    BEGIN
        -- Filling Setting
        EXEC dsp.[Init_$InitSettings];

        EXEC dspInboxMessage.[Init_$InitSettings];

        EXEC DatabaseVersioning.[Init_$InitSettings];

        -- You should implement this function to your specifics Setting
        IF (dsp.Metadata_IsObjectExists('dbo', 'Init_$InitSettings', 'P') = 1) --
            EXEC dbo.[Init_$InitSettings];
    END;

    ----------------
    -- Recreate Strings
    ----------------
    IF (@Reserved = 1) --
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Recreating strings';
    DELETE  dsp.StringTable;

    -- You should implement this function to your specifics String
    IF (dsp.Metadata_IsObjectExists('dbo', 'Init_FillStrings', 'P') = 1) --
        EXEC dbo.Init_FillStrings;

    -- Recreate string functions
    EXEC dsp.[Init_$RecreateStringFunctions];

    -- Check is internal databse
    DECLARE @IsInternalDatabase BIT = 0;
    SELECT  @IsInternalDatabase = 1
      FROM  dsp.StringTable AS ST
     WHERE  ST.StringId = 'IsDirectSpInternal';

    ----------------
    -- Recreate Exceptions 
    ----------------
    IF (@Reserved = 1) --
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Recreating exception';
    DELETE  dsp.Exception;

    -- You should implement this function to your specifics Exception
    -- Your ExceptionId mst be grather than 56000
    IF (dsp.Metadata_IsObjectExists('dbo', 'Init_FillExceptions', 'p') = 1) --
        EXEC dbo.Init_FillExceptions;

    -- make sure there is no invalid Exception Id for general application
    IF (@IsInternalDatabase = 0 AND EXISTS (   SELECT   1
                                                 FROM   dsp.Exception AS E
                                                WHERE   E.ExceptionId < 56000))
        EXEC dsp.ThrowAppException @ProcId = @@PROCID, @ExceptionId = 55001, @Message = 'Application ExceptionId cannot be less than 56000!';

    -- make sure there is no invalid Exception Id for DirectSpInternal
    IF (@IsInternalDatabase = 1 AND EXISTS (   SELECT   1
                                                 FROM   dsp.Exception AS E
                                                WHERE   E.ExceptionId < 55700 OR E.ExceptionId >= 56000))
        EXEC dsp.ThrowAppException @ProcId = @@PROCID, @ExceptionId = 55001, @Message = 'DirectSpInternal ExceptionId must asigned between 55700 and 56000!';

    -- Recreate exception function
    EXEC dsp.[Init_$CreateCommonExceptions];
    EXEC dsp.[Init_$RecreateExceptionFunctions];

    ----------------
    -- Lookups and Data
    ----------------
    IF (@Reserved = 1) --
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Filling lookups';
    EXEC dsp.Init_FillLookups;

    -- You should implement this function to your specifics Lookup
    IF (dsp.Metadata_IsObjectExists('dbo', 'Init_FillLookups', 'P') = 1) --
        EXEC dbo.Init_FillLookups;

    IF (@Reserved = 1) --
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Filling data';
    EXEC dsp.Init_FillData;

    -- Initialized startup data if you have not initialized yet your data
    IF (dsp.Metadata_IsObjectExists('dbo', 'Init_FillData', 'P') = 1) --
        EXEC dbo.Init_FillData;

    -- Initialize SystemTable to Temporal and DatabseVaersioning feature
    IF (dsp.Metadata_IsObjectExists('dbo', 'Init_SystemTable', 'P') = 1) --
        EXEC dbo.Init_SystemTable;

    -- Turn on feature by SystemTabkle
    EXEC dsp.Init_SystemTable @DoNotDisableTemporalForActiveTemporal = @DoNotDisableTemporalForActiveTemporal;

    -- Call Init again to make sure it can be called without cleanup
    IF (@IsProductionEnvironment = 0 AND @IsWithCleanup = 1 AND @Reserved = 1)
    BEGIN
        EXEC dsp.[Init_$Start] @IsProductionEnvironment = 0, @IsWithCleanup = 0, @Reserved = 0;
        RETURN;
    END;

    ----------------
    -- Init new application version
    ----------------
    DECLARE @IsEnabledInitNewAppVersion BIT;
    EXEC dsp.Setting_GetProps @IsEnabledInitNewAppVersion = @IsEnabledInitNewAppVersion OUTPUT;
    IF (@IsEnabledInitNewAppVersion = 1) --
        EXEC dsp.Init_NewAppVersion;

    -- Configure large fields
    -- EXEC dsp.Table_UpdateToUseBlobForFields;

    -- Report it is done
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Init has been completed.';

END;
GO
PRINT N'Creating [tCodeQuality].[test Find functions with dsptest schema which not in test functioncs- for existing functions]'
GO
CREATE   PROCEDURE [tCodeQuality].[test Find functions with dsptest schema which not in test functioncs- for existing functions]
AS
BEGIN
    --------------------------------
    -- Checking: InvalidOperation exception is expected when dspTest objects not only use in tests
    --------------------------------
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking 1: InvalidOperation exception is expected when dspTest objects not only use in tests';

    DECLARE @FunctionNames TSTRING = dsptest.Database_FindFunctionsWithDspTestSchemaWhichNotInTestFunctioncs();

    IF (@FunctionNames IS NOT NULL)
    BEGIN
        SET @FunctionNames = CHAR(10) + CHAR(13) + @FunctionNames;
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = N'These procedures use dspTest objects: {0}', @Param0 = @FunctionNames;
    END;

END;
GO
PRINT N'Creating [dsp].[SplitStringByIndex]'
GO
CREATE FUNCTION [dsp].[SplitStringByIndex] (@Exprission NVARCHAR(MAX /*NCQ*/),
    @Seprator NVARCHAR(MAX /*NCQ*/),
    @Index INT)
RETURNS NVARCHAR(MAX /*NCQ*/)
WITH SCHEMABINDING
AS
BEGIN
    RETURN (   SELECT   value
                 FROM   (   SELECT  ROW_NUMBER() OVER (ORDER BY @Seprator) AS RowNumber, value
                              FROM  STRING_SPLIT(@Exprission, @Seprator)
                             WHERE  value <> '') SplitedQ
                WHERE   SplitedQ.RowNumber = @Index);

END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessSteps]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessSteps]
    @MessagePatternId INT, @WaitStepId BIGINT, @ProviderInfoId INT, @Address TSTRING, @MessageBody TSTRING, @MessageLastData TJSON OUTPUT,
    @InboxMessageProcessStateId INT = NULL OUTPUT, @ErrorMessage TJSON = NULL OUTPUT
AS
BEGIN
    -- Consts
    DECLARE @StepType_InputParam INT = dspconst.MessagePatternStepType_InputParam();
    DECLARE @StepType_OutputParam INT = dspconst.MessagePatternStepType_OutputParam();
    DECLARE @StepType_InputOutputParam INT = dspconst.MessagePatternStepType_InputOutputParam();
    DECLARE @StepType_SendMessage INT = dspconst.MessagePatternStepType_SendMessage();
    DECLARE @StepType_Confirm INT = dspconst.MessagePatternStepType_Confirm();
    DECLARE @StepType_DoRun INT = dspconst.MessagePatternStepType_DoRun();
    DECLARE @StepType_DoCheckConfirmActivation INT = dspconst.MessagePatternStepType_DoCheckConfirmActivation();

    -- Declare variables
    DECLARE @MessagePatternSeprator TSTRING;
    DECLARE @MessagePatternStepId INT;
    DECLARE @MessagePatternStepTypeId INT;
    DECLARE @ParameterName TSTRING;
    DECLARE @SendMessageValue TSTRING;
    DECLARE @DefaultValue TSTRING;
    DECLARE @ConfirmHasCustomValidation BIT;
    DECLARE @HasCustomValue BIT;

    DECLARE @UsedMessageBodyCurrentValue BIT;
    DECLARE @MessageBodyCurrentValue TSTRING;

    DECLARE @DoBreak BIT;

    -- Call GetProps of MessagePattern
    EXEC dspInboxMessage.MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @MessagePatternSeprator = @MessagePatternSeprator OUTPUT;

    -- Get latest done step order
    DECLARE @LastOrder INT = ISNULL((   SELECT  [Step].[Order]
                                          FROM  dspInboxMessage.MessagePatternStep Step
                                         WHERE  Step.MessagePatternStepId = ISNULL(@WaitStepId, 0)), 0);

    -- Cursor for pattern all steps
    DECLARE StepsCursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  MessagePatternStepId, MPS.MessagePatternStepTypeId, MPS.ParameterName, MPS.SendMessageValue, MPS.DefaultValue, MPS.ConfirmHasCustomValidation,
        MPS.HasCustomValue
      FROM  dspInboxMessage.MessagePatternStep MPS
     WHERE  MessagePatternId = @MessagePatternId --
        AND [Order] >= @LastOrder
     ORDER BY [Order];

    OPEN StepsCursor;

    -- Calculate current index of parameters in process scenario
    DECLARE @UseableIndexOfMessageBody INT = IIF(@WaitStepId IS NULL, 2, 1);

    -- Variable for detect all steps proceed and related procedure must run
    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM StepsCursor
         INTO @MessagePatternStepId, @MessagePatternStepTypeId, @ParameterName, @SendMessageValue, @DefaultValue, @ConfirmHasCustomValidation, @HasCustomValue;

        IF (@@FETCH_STATUS <> 0)
        BEGIN
            BREAK;
        END;

        -- Get current value by MessageBody pointer
        SET @MessageBodyCurrentValue = dsp.SplitStringByIndex(@MessageBody, @MessagePatternSeprator, @UseableIndexOfMessageBody);

        IF (@MessagePatternStepTypeId = @StepType_DoCheckConfirmActivation)
        BEGIN
            EXEC dspInboxMessage.InboxMessageProcess_$ProcessCheckConfirmActivationStep @MessagePatternStepId = @MessagePatternStepId,
                @ProviderInfoId = @ProviderInfoId, @Address = @Address, @DoBreak = @DoBreak OUTPUT,
                @InboxMessageProcessStateId = @InboxMessageProcessStateId OUTPUT;

            IF (@DoBreak = 1)
                BREAK;
        END;
        -- When step is one of api parameter
        ELSE IF (@MessagePatternStepTypeId IN ( @StepType_InputParam, @StepType_InputOutputParam, @StepType_OutputParam ))
        BEGIN
            EXEC dspInboxMessage.InboxMessageProcess_$ProcessInputOutputStep @MessagePatternStepId = @MessagePatternStepId,
                @MessagePatternStepTypeId = @MessagePatternStepTypeId, @DefaultValue = @DefaultValue, @MessageBodyCurrentValue = @MessageBodyCurrentValue,
                @ParameterName = @ParameterName, @Address = @Address, @ProviderInfoId = @ProviderInfoId, @HasCustomValue = @HasCustomValue,
                @MessageLastData = @MessageLastData OUTPUT, @DoBreak = @DoBreak OUTPUT, @UsedMessageBodyCurrentValue = @UsedMessageBodyCurrentValue OUTPUT;

            IF (@UsedMessageBodyCurrentValue = 1)
            BEGIN
                SET @UseableIndexOfMessageBody = @UseableIndexOfMessageBody + 1;
                SET @MessageBodyCurrentValue = dsp.SplitStringByIndex(@MessageBody, @MessagePatternSeprator, @UseableIndexOfMessageBody);
            END;

            IF (@DoBreak = 1)
                BREAK;
        END;
        -- send message
        ELSE IF (@MessagePatternStepTypeId = @StepType_SendMessage)
            EXEC dspInboxMessage.InboxMessageProcess_$ProcessSendMessageStep @MessagePatternStepTypeId = @MessagePatternStepTypeId,
                @ProviderInfoId = @ProviderInfoId, @Address = @Address, @SendMessageValue = @SendMessageValue, @MessagePatternStepId = @MessagePatternStepId;
        -- confirm message
        ELSE IF (@MessagePatternStepTypeId = @StepType_Confirm)
        BEGIN
            EXEC dspInboxMessage.InboxMessageProcess_$ProcessConfirmStep @MessagePatternStepTypeId = @MessagePatternStepTypeId,
                @ProviderInfoId = @ProviderInfoId, @Address = @Address, @MessageBody = @MessageBody, @DefaultValue = @DefaultValue,
                @ConfirmHasCustomValidation = @ConfirmHasCustomValidation, @WaitStepId = @WaitStepId, @MessagePatternStepId = @MessagePatternStepId,
                @SendMessageValue = @SendMessageValue, @MessageLastData = @MessageLastData OUTPUT, @DoBreak = @DoBreak OUTPUT,
                @InboxMessageProcessStateId = @InboxMessageProcessStateId OUTPUT;

            IF (@DoBreak = 1)
                BREAK;
        END;
        ELSE IF (@MessagePatternStepTypeId = @StepType_DoRun)
        BEGIN
            EXEC dspInboxMessage.InboxMessageProcess_$DoRunResponseProcedure @MessageLastData = @MessageLastData, @ProviderInfoId = @ProviderInfoId,
                @Address = @Address, @SendMessageValue = @SendMessageValue, @MessagePatternStepId = @MessagePatternStepId,
                @InboxMessageProcessStateId = @InboxMessageProcessStateId OUTPUT, @ErrorMessage = @ErrorMessage OUTPUT;
        END;
    END;
    CLOSE StepsCursor;
    DEALLOCATE StepsCursor;
END;

GO
PRINT N'Creating [dsp].[Init]'
GO
CREATE PROCEDURE [dsp].[Init]
    @IsProductionEnvironment BIT = NULL, @DoNotDisableTemporalForActiveTemporal BIT = 1
AS
BEGIN
    SET NOCOUNT ON;

    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;
    BEGIN TRY
        SET @DoNotDisableTemporalForActiveTemporal = ISNULL(@DoNotDisableTemporalForActiveTemporal, 1);
        EXEC dsp.[Init_$Start] @IsProductionEnvironment = @IsProductionEnvironment, @IsWithCleanup = NULL, @Reserved = NULL,
            @DoNotDisableTemporalForActiveTemporal = @DoNotDisableTemporalForActiveTemporal;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH;
END;

GO
PRINT N'Creating [tCodeQuality].[test Find functions with dsptest schema which not in test Functioncs]'
GO
CREATE   PROCEDURE [tCodeQuality].[test Find functions with dsptest schema which not in test Functioncs]
AS
BEGIN
    --------------------------------
    -- Checking: InvalidOperation exception is expected when we have a function with one of "dspTest" schema object and code quality method does not return function name
    --------------------------------
    EXEC dsp.Log_Trace @ProcId = @@PROCID,
        @Message = 'Checking 1: InvalidOperation exception is expected when we have a function with one of "dspTest" schema object and code quality method does not return function name';

    SAVE TRANSACTION Test;

    EXEC ('CREATE OR ALTER PROCEDURE dbo.TestProcedure
	AS
	BEGIN
	EXEC dsptest.AssertEquals @Expected = 1, @Actual = NULL	
	END');

    DECLARE @FunctionNames TSTRING = dsptest.Database_FindFunctionsWithDspTestSchemaWhichNotInTestFunctioncs();

    IF (@FunctionNames IS NULL OR  CHARINDEX('ALTER PROCEDURE [dbo].[TestProcedure]', @FunctionNames) = 0)
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'method does not return true function names';

    ROLLBACK TRANSACTION Test;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessItem]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessItem]
    @Address TSTRING, @MessageBody TSTRING, @MessageTime DATETIME, @ProviderInfoId INT, @MessagePatternId INT = NULL OUTPUT,
    @InboxMessageProcessStateId INT = NULL OUTPUT, @ErrorMessage TJSON = NULL OUTPUT
AS
BEGIN
    DECLARE @MessageLastData TJSON;
    DECLARE @WaitStepId INT;

    -- Consts
    DECLARE @ProcessState_Proceed INT = dspconst.InboxMessageProcessState_Processed();
    DECLARE @ProcessState_ProceedNotPair INT = dspconst.InboxMessageProcessState_ProcessedNotPair();

    SET @ErrorMessage = NULL;
    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;
    BEGIN TRY
        -- Get appropriate PatternId
        EXEC dspInboxMessage.InboxMessageProcess_$GetAppropriatePatternId @MessageBody = @MessageBody, @MessageTime = @MessageTime, @Address = @Address,
            @ProviderInfoId = @ProviderInfoId, @MessagePatternId = @MessagePatternId OUTPUT, @MessageLastData = @MessageLastData OUTPUT,
            @WaitStepId = @WaitStepId OUTPUT;

        -- Process pattern when it founded sucess
        IF @MessagePatternId IS NOT NULL
        BEGIN
            SET @InboxMessageProcessStateId = @ProcessState_Proceed;

            -- Start process pattern steps
            EXEC dspInboxMessage.InboxMessageProcess_$ProcessSteps @MessagePatternId = @MessagePatternId, @WaitStepId = @WaitStepId,
                @ProviderInfoId = @ProviderInfoId, @Address = @Address, @MessageBody = @MessageBody, @MessageLastData = @MessageLastData OUTPUT,
                @InboxMessageProcessStateId = @InboxMessageProcessStateId OUTPUT, @ErrorMessage = @ErrorMessage OUTPUT;
        END;
        ELSE
            SET @InboxMessageProcessStateId = @ProcessState_ProceedNotPair;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;

        SET @ErrorMessage = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;

END;
GO
PRINT N'Creating [dsp].[Init_Cleanup]'
GO

CREATE PROCEDURE [dsp].[Init_Cleanup]
AS
BEGIN
    SET NOCOUNT ON;

	-- Protect production environment
	EXEC dsp.Util_ProtectProductionEnvironment
			
	-- Delete Junction Tables 

	-- Delete base tables 

	-- Delete Lookup tables (may not required)

END
		
GO
PRINT N'Creating [dsp].[Table_HasTemporalAttributes]'
GO

CREATE  FUNCTION [dsp].[Table_HasTemporalAttributes] (@SchemaName TSTRING = 'dbo',
    @TableName TSTRING)
RETURNS TABLE
RETURN SELECT   IIF((   SELECT  COUNT(1)
                          FROM  sys.columns C
                                INNER JOIN sys.tables T ON T.object_id = C.object_id
                                INNER JOIN sys.schemas SCh ON SCh.schema_id = T.schema_id
                         WHERE  T.name = @TableName --
                            AND SCh.name = @SchemaName --
                            AND (C.name = 'VersioningStartTime' OR C.name = 'VersioningEndTime')) = 2,
                    1,
                    0) HasVersioningFields;

GO
PRINT N'Creating [tCodeQuality].[test Find functions with tSQLt schema in test functioncs- for existing functions]'
GO
CREATE   PROCEDURE [tCodeQuality].[test Find functions with tSQLt schema in test functioncs- for existing functions]
AS
BEGIN
    --------------------------------
    -- Checking: InvalidOperation exception is expected when tSQLt objects wrong use in tests
    --------------------------------
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'Checking 1: InvalidOperation exception is expected when tSQLt objects wrong use in tests';

    DECLARE @FunctionNames TSTRING = dsptest.Database_FindFunctionsWithTSQLTSchemaInTestFunctioncs();

    SET @FunctionNames = REPLACE(@FunctionNames, 'ALTER PROCEDURE [tCodeQuality].[test Find functions with tSQLt schema in test functioncs]', '');

    IF (LEN(@FunctionNames) > 0)
    BEGIN
        SET @FunctionNames = CHAR(10) + CHAR(13) + @FunctionNames;
        EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = 'These procedures use tSQLt objects: {0}', @Param0 = @FunctionNames;
    END;
END;

GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessItems]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessItems]
    @InboxMessageItems TJSON, @InboxMessageResultItems TJSON = NULL OUTPUT
AS
BEGIN
    -- Provisioning parameters
    DECLARE @InboxMessageId BIGINT;
    DECLARE @Address TSTRING;
    DECLARE @MessageBody TSTRING;
    DECLARE @MessageTime DATETIME;
    DECLARE @ProviderInfoId INT;
    DECLARE @MessagePatternId INT;
    DECLARE @InboxMessageProcessStateId INT;
    DECLARE @ErrorMessage TJSON;

    -- Create temp for result
    DECLARE @Temp TABLE (InboxMessageId BIGINT PRIMARY KEY,
        MessagePatternId INT NULL,
        InboxMessageProcessStateId INT NOT NULL,
        Error TJSON NULL);

    DECLARE MessagesCursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  InboxMessageId, Address, MessageBody, MessageTime, ProviderInfoId
      FROM
        OPENJSON(@InboxMessageItems)
        WITH (InboxMessageId BIGINT, Address TSTRING, MessageBody TSTRING, MessageTime DATETIME, ProviderInfoId BIGINT);

    OPEN MessagesCursor;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM MessagesCursor
         INTO @InboxMessageId, @Address, @MessageBody, @MessageTime, @ProviderInfoId;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        DECLARE @TranCount INT = @@TRANCOUNT;
        IF (@TranCount = 0)
            BEGIN TRANSACTION;
        BEGIN TRY

            -- Call ProcessItem
            EXEC dspInboxMessage.[InboxMessageProcess_$ProcessItem] @Address = @Address, @MessageBody = @MessageBody, @MessageTime = @MessageTime,
                @ProviderInfoId = @ProviderInfoId, @MessagePatternId = @MessagePatternId OUTPUT,
                @InboxMessageProcessStateId = @InboxMessageProcessStateId OUTPUT, @ErrorMessage = @ErrorMessage OUTPUT;

            -- Fill successfull result
            INSERT INTO @Temp (InboxMessageId, MessagePatternId, InboxMessageProcessStateId, Error) --@InboxMessageProcessStateId
            VALUES (@InboxMessageId, @MessagePatternId, @InboxMessageProcessStateId, @ErrorMessage);

            IF (@TranCount = 0) COMMIT;
        END TRY
        BEGIN CATCH
            IF (@TranCount = 0)
                ROLLBACK TRANSACTION;

            -- Validate error
            SET @ErrorMessage = dsp.Message_CommonExceptionFormat(@@PROCID, ERROR_MESSAGE());

            -- Fill successfull result
            INSERT INTO @Temp (InboxMessageId, InboxMessageProcessStateId, Error)
            VALUES (@InboxMessageId, dspconst.InboxMessageProcessState_ProcessedFailed(), @ErrorMessage);

            SET @InboxMessageResultItems = (   SELECT   InboxMessageId, MessagePatternId, InboxMessageProcessStateId, Error
                                                 FROM   @Temp
                                               FOR JSON AUTO);
        END CATCH;
    END;
    CLOSE MessagesCursor;
    DEALLOCATE MessagesCursor;

    SET @InboxMessageResultItems = (   SELECT   InboxMessageId, MessagePatternId, InboxMessageProcessStateId, Error
                                         FROM   @Temp
                                       FOR JSON AUTO);
END;
GO
PRINT N'Creating [dsp].[Init_FillExceptions]'
GO

CREATE PROCEDURE [dsp].[Init_FillExceptions]
AS
BEGIN
    SET NOCOUNT ON;

	-- delclare your application exceptions here. NOTE: ExceptionId must be started from 56000
	INSERT	dsp.Exception (ExceptionId, ExceptionName, Description)
	VALUES (56001, N'Error1', N'Error1 description'),
		(56002, N'Error2', N'Error2 description');

END
		
GO
PRINT N'Creating [dspconst].[Table_IsTemporalHistory]'
GO

CREATE   FUNCTION [dspconst].[Table_IsTemporalHistory] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;                                                       
END;


GO
PRINT N'Creating [dsp].[Database_CheckPrimaryOnTables]'
GO
CREATE  FUNCTION [dsp].[Database_CheckPrimaryOnTables] (@ExceptedSchemaName TSTRING = 'tSQLt')
RETURNS TABLE
RETURN SELECT   SCh.name AS SchemaName, tab.name AS TableName 
         FROM   sys.tables tab
                INNER JOIN sys.schemas SCh ON SCh.schema_id = tab.schema_id
                LEFT OUTER JOIN sys.indexes pk ON tab.object_id = pk.object_id AND  pk.is_primary_key = 1
                OUTER APPLY dsp.Table_HasTemporalAttributes(DEFAULT, tab.name) THSAE
        WHERE   pk.name IS NULL --
           AND  (@ExceptedSchemaName IS NULL OR SCh.name <> 'tSQLt') --
           AND  tab.temporal_type <> dspconst.Table_IsTemporalHistory() --
           AND  THSAE.HasVersioningFields = 0;
GO
PRINT N'Creating [tCodeQuality].[test Find functions with tSQLt schema in test functioncs]'
GO
CREATE   PROCEDURE [tCodeQuality].[test Find functions with tSQLt schema in test functioncs]
AS
BEGIN
    --------------------------------
    -- Checking: InvalidOperation exception is expected when we have a function with one of "tSQLt" schema objects and code quality method does not return function name
    --------------------------------
    EXEC dsp.Log_Trace @ProcId = @@PROCID,
        @Message = 'Checking 1: InvalidOperation exception is expected when we have a function with one of "tSQLt" schema objects and code quality method does not return function name';

    SAVE TRANSACTION Test;

    EXEC ('CREATE OR ALTER PROCEDURE tRequest.TestProcedure
	AS
	BEGIN
	EXEC tSQLt.AssertEquals @Expected = 1, @Actual = NULL	
	END');

    DECLARE @FunctionNames TSTRING = dsptest.Database_FindFunctionsWithTSQLTSchemaInTestFunctioncs();

    IF (@FunctionNames IS NULL OR   CHARINDEX('[tRequest].[TestProcedure]', @FunctionNames) = 0)
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Method does not return true function names';

    ROLLBACK TRANSACTION Test;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$ProcessNotRegisteredAddress]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$ProcessNotRegisteredAddress]
    @MaxInboxMessageId BIGINT
AS
BEGIN
    DECLARE @AddressRegistrationIsActive BIT;
    EXEC dspInboxMessage.Setting_GetProps @AddressRegistrationIsActive = @AddressRegistrationIsActive OUTPUT;

    -- Check address registration activation
    IF (@AddressRegistrationIsActive = 1)
    BEGIN
        -- Get distinct of addresses
        DECLARE @MessageAddress TJSON = (   SELECT  IM.Address, P.ProviderTypeId
                                              FROM  dspInboxMessage.InboxMessage IM
                                                    INNER JOIN dspInboxMessage.ProviderInfo PI ON PI.ProviderInfoId = IM.ProviderInfoId
                                                    INNER JOIN dspInboxMessage.Provider P ON P.ProviderId = PI.ProviderId
                                             WHERE  IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_NotProcessed()*/ 1 --
                                                AND IM.InboxMessageId <= @MaxInboxMessageId
                    
					                        FOR JSON AUTO);

        -- Call client api to get registered address
        EXEC InboxMessage.InboxMessageProcess_ProcessAddressRegistration @MessageAddress = @MessageAddress, @ResultAddress = @MessageAddress OUTPUT;

        -- Update state that not contain in registered address
        ;WITH RegisteredAddress
            AS (SELECT  Address, ProviderTypeId
                  FROM
                    OPENJSON(@MessageAddress)
                    WITH (Address TSTRING, ProviderTypeId INT, UserId INT)
                 WHERE  UserId IS NOT NULL)
        UPDATE  IM
           SET  InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_AddressNotRegistered() */ 6, --
            IM.ProcessStartTime = GETDATE(), --
            IM.ProcessEndTime = GETDATE()
          FROM  dspInboxMessage.InboxMessage IM
                INNER JOIN dspInboxMessage.ProviderInfo PI ON PI.ProviderInfoId = IM.ProviderInfoId
                INNER JOIN dspInboxMessage.Provider P ON P.ProviderId = PI.ProviderId
                LEFT JOIN RegisteredAddress RA ON RA.Address = IM.Address AND   RA.ProviderTypeId = P.ProviderTypeId
         WHERE  IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_NotProcessed()*/ 1 --
            AND RA.Address IS NULL --
            AND IM.InboxMessageId <= @MaxInboxMessageId;


    -- TODO: Need perfomance tunning
    --UPDATE  IM
    --   SET  InboxMessageProcessStateId = dspconst.InboxMessageProcessState_AddressNotRegistered()
    --  FROM  InboxMessage.InboxMessage IM
    -- WHERE  IM.InboxMessageProcessStateId = /*dspconst.InboxMessageProcessState_NotProcessed()*/ 1 --
    --    AND NOT EXISTS (   SELECT   1
    --                         FROM   InboxMessage.RegisteredAddress RA
    --                        WHERE   RA.Address = IM.Address) --
    --    AND IM.InboxMessageId <= @MaxInboxMessageId;
    END;
END;
GO
PRINT N'Creating [dsp].[Init_TemporalTables]'
GO
CREATE PROCEDURE [dsp].[Init_TemporalTables]
AS
BEGIN
    SET NOCOUNT ON;

    -- Cursor on all temporal tables
    DECLARE _Cursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY READ_ONLY FOR -- 
    SELECT  SchemaName, TableName
      FROM  dsp.SystemTable
     WHERE  TemporalTypeId = /*dspconst.TemporalType_Temporal()*/ 2;

    OPEN _Cursor;

    DECLARE @SchemaName TSTRING;
    DECLARE @TableName TSTRING;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM _Cursor
         INTO @SchemaName, @TableName;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        -- Enable temporal
        EXEC dsp.Table_EnableTemporalAttribute @SchemaName = @SchemaName, @TableName = @TableName;
    END;
    CLOSE _Cursor;
    DEALLOCATE _Cursor;
END;
GO
PRINT N'Creating [tCodeQuality].[test None of tests should have RETURN phrase]'
GO
CREATE PROCEDURE [tCodeQuality].[test None of tests should have RETURN phrase]
AS
BEGIN

    -- find first tests with [RET URN] phrase 
    DECLARE @ObjectName TSTRING;

    SELECT  @ObjectName = S.name + '.' + O.name
      FROM  sys.objects AS O
            INNER JOIN sys.schemas AS S ON S.schema_id = O.schema_id
            INNER JOIN sys.extended_properties AS EP ON EP.major_id = S.schema_id
     WHERE  O.name LIKE 'test%' --
        AND CHARINDEX('RETURN', OBJECT_DEFINITION(O.object_id)) > 0 --
        AND O.name <> 'test None of tests should have RETURN phrase';

    DECLARE @ErrorMessage TSTRING = @ObjectName + ' has [RETURN] phrase';

    IF (@ObjectName IS NOT NULL) --
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @ErrorMessage;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_$SetState]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_$SetState]
    @InboxMessageItems TJSON
AS
BEGIN
    -- Update ProcessStateId 
    UPDATE  IM
       SET  IM.MessagePatternId = Items.MessagePatternId, --
        IM.InboxMessageProcessStateId = Items.InboxMessageProcessStateId, --
        IM.ProcessEndTime = GETDATE(), --
        IM.Error = Items.Error
      FROM
        OPENJSON(@InboxMessageItems)
        WITH (InboxMessageId BIGINT, MessagePatternId INT, InboxMessageProcessStateId INT, Error TJSON) Items
        INNER JOIN dspInboxMessage.InboxMessage IM ON IM.InboxMessageId = Items.InboxMessageId;
END;

GO
PRINT N'Creating [dsp].[Job_Create]'
GO
CREATE PROCEDURE [dsp].[Job_Create]
	@Command TSTRING, @JobName TSTRING, @Owner TSTRING = NULL, @DataBaseName TSTRING = NULL
AS
BEGIN
	BEGIN TRANSACTION;
	
	SET @Owner = ISNULL(@Owner, SYSTEM_USER);
	SET @DataBaseName = DB_NAME();
	DECLARE @ReturnCode INT;
	SELECT	@ReturnCode = 0;
	    
	IF NOT EXISTS (SELECT	name
						FROM msdb.dbo.syscategories
					WHERE	name = N'[Uncategorized (Local)]' AND	category_class = 1)
	BEGIN
		EXEC @ReturnCode = msdb.dbo.sp_add_category @class = N'JOB', @type = N'LOCAL', @name = N'[Uncategorized (Local)]';
		IF (@@ERROR <> 0 OR @ReturnCode <> 0)
			GOTO QuitWithRollback;
	END;
	
	DECLARE @jobId BINARY(16);
	EXEC @ReturnCode = msdb.dbo.sp_add_job @job_name = @JobName, @enabled = 1, @notify_level_eventlog = 0, @notify_level_email = 0, @notify_level_netsend = 0,
		@notify_level_page = 0, @delete_level = 1, @description = N'No description available.', @category_name = N'[Uncategorized (Local)]',
		@owner_login_name = @Owner, @job_id = @jobId OUTPUT;
	IF (@@ERROR <> 0 OR @ReturnCode <> 0)
		GOTO QuitWithRollback;
	EXEC @ReturnCode = msdb.dbo.sp_add_jobstep @job_id = @jobId, @step_name = N'FirstStep', @step_id = 1, @cmdexec_success_code = 0, @on_success_action = 1,
		@on_success_step_id = 0, @on_fail_action = 2, @on_fail_step_id = 0, @retry_attempts = 0, @retry_interval = 0, @os_run_priority = 0,
		@subsystem = N'TSQL', @command = @Command, @database_name = @DataBaseName, @flags = 0;
	IF (@@ERROR <> 0 OR @ReturnCode <> 0)
		GOTO QuitWithRollback;
	EXEC @ReturnCode = msdb.dbo.sp_update_job @job_id = @jobId, @start_step_id = 1;
	IF (@@ERROR <> 0 OR @ReturnCode <> 0)
		GOTO QuitWithRollback;

	EXEC @ReturnCode = msdb.dbo.sp_add_jobserver @job_id = @jobId, @server_name = N'(local)';
	IF (@@ERROR <> 0 OR @ReturnCode <> 0)
		GOTO QuitWithRollback;
	COMMIT TRANSACTION;
	GOTO EndSave;
	QuitWithRollback:
	IF (@@TRANCOUNT > 0)
		ROLLBACK TRANSACTION;
	EndSave:
END;




GO
PRINT N'Creating [dsp].[Database_ServerName]'
GO
CREATE FUNCTION [dsp].[Database_ServerName] ()
RETURNS TSTRING
AS
BEGIN
	RETURN @@SERVERNAME;
END;

GO
PRINT N'Creating [tCodeQuality].[test Pagination]'
GO
/*
	One of the following phrase must exits 
	1) @RecordIndex = @RecordIndex (Means the procedure is a wrapper)
	OR 
	1) EXEC dbo.Validate_RecordCount @RecordCount = @RecordCount OUT
	2) OFFSET @RecordIndex ROWS FETCH NEXT @RecordCount ROWS ONLY
*/
CREATE PROCEDURE [tCodeQuality].[test Pagination]
AS
BEGIN
    -- Declaring pattern
    DECLARE @Pattern_Offset TSTRING = dsp.String_RemoveWhitespaces('OFFSET @RecordIndex ROWS FETCH NEXT @RecordCount ROWS ONLY');
    DECLARE @Pattern_PageIndex TSTRING = dsp.String_RemoveWhitespaces('@RecordIndex = @RecordIndex');
    DECLARE @CurrentProcedure TSTRING;
    DECLARE @msg TSTRING;
    DECLARE @ProcedureName TSTRING;

    -- Getting list all procedures with pagination
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting list all procedures with pagination';
    DECLARE @t TABLE (SchemaName TSTRING,
        ProcedureName TSTRING,
        Script TBIGSTRING);
    INSERT INTO @t
    SELECT  PD.StoredProcedureSchemaName, PD.StoredProcedureName, PD.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(NULL) AS PD
     WHERE  CHARINDEX('@RecordIndex', PD.StoredProcedureDefinitionCode) > 0 AND CHARINDEX('@RecordCount', PD.StoredProcedureDefinitionCode) > 0 AND
            PD.StoredProcedureName NOT IN ( 'Context_ValidatePagination', 'Context_Verify' );


    -- Checking implementation paging in api and dbo StoreProcedure
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Checking implementation paging in api and dbo StoreProcedure';
    SELECT  @ProcedureName = SchemaName + '.' + ProcedureName
      FROM  @t
     WHERE  (   CHARINDEX(@Pattern_PageIndex, Script) > 0 --  Wrapper Phrase: (@RecordIndex = @RecordIndex) 
                AND CHARINDEX(@Pattern_Offset, Script) = 0); --ValidatePage size must exists if it not wrapper

    IF (@ProcedureName IS NOT NULL)
    BEGIN
        SET @msg = 'Paging is not implemented properly in procedure: ' + @ProcedureName;
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
    END;
END;
GO
PRINT N'Creating [dspInboxMessage].[InboxMessageProcess_Refresh]'
GO
CREATE PROCEDURE [dspInboxMessage].[InboxMessageProcess_Refresh]
AS
BEGIN
    -- Process MAX value of InboxMessageId
    DECLARE @MaxInboxMessageId BIGINT = ISNULL((SELECT  MAX(InboxMessageId) FROM    dspInboxMessage.InboxMessage), 0);

    -- Process not registered address
    EXEC dspInboxMessage.[InboxMessageProcess_$ProcessNotRegisteredAddress] @MaxInboxMessageId = @MaxInboxMessageId;

    -- Get nex InboxMessagerocess for process
    DECLARE @GetNextBulkResult TJSON;
    EXEC dspInboxMessage.[InboxMessageProcess_$GetNextBulk] @MaxInboxMessageId = @MaxInboxMessageId, @InboxMessageItems = @GetNextBulkResult OUTPUT;

    -- Process items
    -- This function guarantees that handle exception
    DECLARE @InboxMessageResultItems TJSON;
    EXEC dspInboxMessage.[InboxMessageProcess_$ProcessItems] @InboxMessageItems = @GetNextBulkResult, @InboxMessageResultItems = @InboxMessageResultItems OUTPUT;

    -- Set state
    EXEC dspInboxMessage.InboxMessageProcess_$SetState @InboxMessageItems = @InboxMessageResultItems;
END;

GO
PRINT N'Creating [dsp].[Job_Delete]'
GO
CREATE PROCEDURE [dsp].[Job_Delete]
	@JobNamePattern TSTRING
AS
BEGIN
	DECLARE DeleteJob_Cursor CURSOR FAST_FORWARD FORWARD_ONLY FORWARD_ONLY LOCAL FOR
	SELECT	S.name AS JobName
	FROM msdb.dbo.sysjobs AS S
	WHERE	S.name LIKE @JobNamePattern;

	OPEN DeleteJob_Cursor;

	DECLARE @JobName TSTRING;
	FETCH NEXT FROM DeleteJob_Cursor
	INTO @JobName;

	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		BEGIN TRY
			EXEC msdb.dbo.sp_delete_job @job_name = @JobName;
		END TRY
		BEGIN CATCH

		END CATCH;

		FETCH NEXT FROM DeleteJob_Cursor
		INTO @JobName;
	END;
	CLOSE DeleteJob_Cursor
	DEALLOCATE DeleteJob_Cursor
END;





GO
PRINT N'Creating [dsp].[DateTime_FormatIntervalMillisecond]'
GO
CREATE	FUNCTION [dsp].[DateTime_FormatIntervalMillisecond] (@Millisecond BIGINT,
	@Format TSTRING)
RETURNS TSTRING
AS
BEGIN
	-- Set default format
	SET @Format = ISNULL(@Format, N'h:m:s.t');

	-- Set hour if needed
	IF (CHARINDEX('h', @Format) > 0)
	BEGIN
		DECLARE @Hours BIGINT = @Millisecond / (3600 * 1000);
		SET @Format = REPLACE(@Format, 'h', FORMAT(@Hours, '0#'));
		SET @Millisecond = @Millisecond - (@Hours * 3600 * 1000);
	END;

	-- Set minute if needed
	IF (CHARINDEX('m', @Format) > 0)
	BEGIN
		DECLARE @Minutes BIGINT = @Millisecond / (60 * 1000);
		SET @Format = REPLACE(@Format, 'm', FORMAT(@Minutes, '0#'));
		SET @Millisecond = @Millisecond - (@Minutes * 60 * 1000);
	END;

	-- Set minute if needed
	IF (CHARINDEX('s', @Format) > 0)
	BEGIN
		DECLARE @Seconds INT = @Millisecond / (1 * 1000);
		SET @Format = REPLACE(@Format, 's', FORMAT(@Seconds, '0#'));
		SET @Millisecond = @Millisecond - (@Seconds * 1 * 1000);
	END;

	-- Set second if needed
	IF (CHARINDEX('t', @Format) > 0)
		SET @Format = REPLACE(@Format, 't', FORMAT(@Millisecond, '00#'));

	RETURN @Format;
END;






GO
PRINT N'Creating [tCodeQuality].[test Relations for ForeignKeys]'
GO
CREATE PROCEDURE [tCodeQuality].[test Relations for ForeignKeys]
AS
BEGIN

    DECLARE @TableName TSTRING;
    DECLARE @ColumnName TSTRING;
    DECLARE @major_id INT;
    DECLARE @minor_id INT;

    -- SQL Prompt Formatting Off
	DECLARE ForeignKeysCusrsor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
    SELECT  tables.name, columns.name, tables.object_id AS major_id, column_id AS minor_id
      FROM  sys.tables
            INNER JOIN sys.schemas ON schemas.schema_id = tables.schema_id
            INNER JOIN sys.columns ON columns.object_id = tables.object_id
     WHERE  columns.name LIKE N'%Id%' AND   schemas.name = 'dbo'
        -- to do
        -- Must be remove from query
        AND tables.name != 'sysdiagrams' AND columns.name != tables.name + 'Id'
     ORDER BY tables.name;

    OPEN ForeignKeysCusrsor;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM ForeignKeysCusrsor
         INTO @TableName, @ColumnName, @major_id, @minor_id;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        DECLARE @Description TSTRING = NULL;
        SELECT  @Description = dsp.Convert_ToString(ep.value)
          FROM  sys.extended_properties AS ep
         WHERE  ep.name = 'MS_Description' AND  ep.major_id = @major_id AND ep.minor_id = @minor_id;
        SET @Description = LOWER(ISNULL(@Description, ''));

        -- ignore /NoFk column
        IF (CHARINDEX('/nofk', @Description) > 0)
        BEGIN
            EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = '**** NoFk: {0}.{1}', @Param0 = @TableName, @Param1 = @ColumnName;
            CONTINUE;
        END;

		IF NOT EXISTS (   SELECT    1
                            FROM    sys.foreign_keys AS f
                                    INNER JOIN sys.foreign_key_columns AS fc ON f.object_id = fc.constraint_object_id
                           WHERE (OBJECT_NAME(f.parent_object_id) = @TableName OR   OBJECT_NAME(f.referenced_object_id) = @TableName) -- 
						   AND (COL_NAME(fc.parent_object_id, fc.parent_column_id) = @ColumnName OR COL_NAME(fc.referenced_object_id, fc.referenced_column_id) = @ColumnName))
        BEGIN
            DECLARE @msg TSTRING = 'Properly relation does not exists for "' + @TableName + '.' + @ColumnName + '"';
            EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
        END;

        IF EXISTS (   SELECT    1
                        FROM    sys.foreign_keys AS f
                                INNER JOIN sys.foreign_key_columns AS fc ON f.object_id = fc.constraint_object_id
                       WHERE (OBJECT_NAME(f.parent_object_id) = @TableName OR   OBJECT_NAME(f.referenced_object_id) = @TableName) --
					   AND (COL_NAME(fc.parent_object_id, fc.parent_column_id) = @ColumnName OR COL_NAME(fc.referenced_object_id, fc.referenced_column_id) = @ColumnName) --
					   AND f.name NOT LIKE N'%Id' COLLATE SQL_Latin1_General_CP1_CS_AS)
        BEGIN
            SET @msg = 'Properly RelatioName does not correct for "' + @TableName + '.' + @ColumnName + '"';
            EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @msg;
        END;
    END;
    CLOSE ForeignKeysCusrsor;
    DEALLOCATE ForeignKeysCusrsor;
END;
GO
PRINT N'Creating [dsp].[SetIfChanged_Time]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_Time]
    @ProcId INT, @PropName TSTRING, @NewValue DATETIME, @OldValue DATETIME OUTPUT, @HasPermission BIT = NULL, @NullAsNotSet BIT = 0,
    @IsUpdated BIT = NULL OUTPUT
AS
BEGIN
    SET @HasPermission = ISNULL(@HasPermission, 1);

    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;



GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_$Validate]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_$Validate]
    @MessagePatternId INT = NULL, @PatternName TSTRING = '<notset>', @StartTime DATETIME = '1753-01-01', @ExpirationTime DATETIME = '1753-01-01',
    @MessagePatternSepratorId INT = -1, @PatternKey TSTRING = '<notset>', @MessagePatternStateId INT = -1, @Description TSTRING = '<notset>',
    @ResponseProcedureSchemaName TSTRING = '<notset>', @ResponseProcedureName TSTRING = '<notset>'
AS
BEGIN
    SET NOCOUNT ON;

    -- Validate Call Mode
    -- Is Better to Create dspconst Function
    DECLARE @State_Create INT = 1;
    DECLARE @State_SetProp INT = 2;
    DECLARE @ValidateState INT = CASE
                                     WHEN @MessagePatternId IS NOT NULL
                                         THEN @State_SetProp ELSE @State_Create
                                 END;
    -- Call GetProp and read required old feilds value for validation
    IF (@ValidateState = @State_SetProp)
    BEGIN
        DECLARE @OldStartTime DATETIME;
        DECLARE @OldExpirationTime DATETIME;
        EXEC dspInboxMessage.MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @StartTime = @OldStartTime OUTPUT,
            @ExpirationTime = @OldExpirationTime OUTPUT;

        EXEC dsp.SetIfChanged_Time @ProcId = @@PROCID, @PropName = 'StartTime', @OldValue = @OldStartTime OUT, @NewValue = @StartTime;
        EXEC dsp.SetIfChanged_Time @ProcId = @@PROCID, @PropName = 'ExpirationTime', @OldValue = @OldExpirationTime OUT, @NewValue = @ExpirationTime;
    END;
    ELSE
    BEGIN
        SELECT  @OldStartTime = @StartTime, @OldExpirationTime = @ExpirationTime;
    END;

    -- Validate parameters
    IF dsp.Param_IsSet(@PatternName) = 1 --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'PatternName', @ArgumentValue = @PatternName;

    IF (dsp.Param_IsSet(@StartTime) = 1) --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'StartTime', @ArgumentValue = @StartTime;

    IF (dsp.Param_IsSet(@ExpirationTime) = 1) --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'ExpirationTime', @ArgumentValue = @ExpirationTime;

    IF (dsp.Param_IsSet(@PatternKey) = 1)
    BEGIN
        -- Validate PatternKey
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'PatternKey', @ArgumentValue = @PatternKey;

        IF EXISTS (   SELECT    *
                        FROM    dspInboxMessage.MessagePatternSeprator
                       WHERE CHARINDEX(MessagePatternSeprator, SUBSTRING(@PatternKey, 2, LEN(@PatternKey))) > 0)
            EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'PatternKey', @ArgumentValue = @PatternKey,
                @Message = 'PatternKey Can not include seprator charecter';
    END;

    -- Validate MessagePatternSepratorId
    IF (dsp.Param_IsSet(@MessagePatternSepratorId) = 1) --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'MessagePatternSepratorId', @ArgumentValue = @MessagePatternSepratorId;

    IF (dsp.Param_IsSet(@StartTime) = 1) OR (dsp.Param_IsSet(@ExpirationTime) = 1)
        IF @OldStartTime > @OldExpirationTime
            EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'StartTime', @ArgumentValue = @StartTime,
                @Message = 'StartTime Can not be Bigger Than ExpirationTime';

    -- Validate MessagePatternStateId is not null
    IF (dsp.Param_IsSet(@MessagePatternStateId) = 1) --
    BEGIN
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = '@MessagePatternStateId', @ArgumentValue = @MessagePatternStateId;

        -- Validate MessagePatternStateId
        IF (@MessagePatternStateId = dspconst.MessagePatternStateId_Started())
        BEGIN
            IF (NOT EXISTS (   SELECT   1
                                 FROM   dspInboxMessage.MessagePatternStep
                                WHERE   MessagePatternId = @MessagePatternId))
                EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'MessagePatternStateId', @ArgumentValue = @StartTime,
                    @Message = 'MessagePattern must have steps';

            IF (NOT EXISTS (   SELECT   1
                                 FROM   dspInboxMessage.MessagePatternStep
                                WHERE   MessagePatternId = @MessagePatternId --
                                   AND  MessagePatternStepTypeId = dspconst.MessagePatternStepType_DoCheckConfirmActivation() --
                                   AND  [Order] = 0))
                EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'MessagePatternStateId', @ArgumentValue = @StartTime,
                    @Message = 'MessagePattern must have DoCheckConfirmActivation step as first order';


            IF (NOT EXISTS (   SELECT   1
                                 FROM   dspInboxMessage.MessagePatternStep
                                WHERE   MessagePatternId = @MessagePatternId --
                                   AND  MessagePatternStepTypeId = dspconst.MessagePatternStepType_DoRun() --
                                   AND  [Order] = (   SELECT    MAX([Order])
                                                        FROM    dspInboxMessage.MessagePatternStep
                                                       WHERE MessagePatternId = @MessagePatternId)))
                EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'MessagePatternStateId', @ArgumentValue = @StartTime,
                    @Message = 'MessagePattern must have DoRun step as last order';
        END;
    END;

    -- Validate PatternKey repetitive
    IF (dsp.Param_IsSet(@PatternKey) = 1)
    BEGIN
        IF EXISTS (   SELECT    *
                        FROM    dspInboxMessage.vw_MessagePattern
                       WHERE MessagePatternId <> ISNULL(@MessagePatternId, 0) AND   PatternKey = @PatternKey)
            EXEC dsperr.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = 'PatternKey can not be duplicate';
    END;

    -- Validate PatternName
    IF (dsp.Param_IsSet(@PatternName) = 1)
    BEGIN
        IF EXISTS (   SELECT    *
                        FROM    dspInboxMessage.vw_MessagePattern
                       WHERE MessagePatternId <> ISNULL(@MessagePatternId, 0) AND   PatternName = @PatternName)
            EXEC dsperr.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = 'PatternName can not be duplicate';
    END;

    -- Validate ResponseProcedureSchemaName
    IF (dsp.Param_IsSet(@ResponseProcedureSchemaName) = 1) EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'ResponseProcedureSchemaName',
                                                           @ArgumentValue = @ResponseProcedureSchemaName;


    -- Validate ResponseProcedureName
    IF (dsp.Param_IsSet(@ResponseProcedureName) = 1) EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'ResponseProcedureName',
                                                     @ArgumentValue = @ResponseProcedureName;

    -- Validate response procedure existance
    IF (dsp.Param_IsSet(@ResponseProcedureSchemaName) = 1) OR   (dsp.Param_IsSet(@ResponseProcedureName) = 1)
    BEGIN
        DECLARE @ResponseProcedureFullName TSTRING = @ResponseProcedureSchemaName + '.' + @ResponseProcedureName;
        IF NOT EXISTS (   SELECT    *
                            FROM    sys.objects O
                           WHERE O.object_id = OBJECT_ID(@ResponseProcedureFullName) AND O.type = 'P')
            EXEC dsp.ThrowInvalidArgument @ProcId = @@PROCID, @ArgumentName = 'ResponseProcedureName', @ArgumentValue = @ResponseProcedureName,
                @Message = 'ResponseProcedureName is invalid';
    END;

    IF @ValidateState = @State_SetProp
        IF EXISTS (   SELECT    *
                        FROM    dspInboxMessage.InboxMessage
                       WHERE MessagePatternId = @MessagePatternId)
        BEGIN
            DECLARE @ExceptionId INT = dsperr.ObjectIsInUseId();
            EXEC dsp.ThrowAppException @ProcId = @@PROCID, @ExceptionId = @ExceptionId, @Message = 'Object is in use, can not SetProp';
        END;


END;
GO
PRINT N'Creating [dsp].[Json_ReadWithColumns]'
GO
CREATE PROCEDURE [dsp].[Json_ReadWithColumns]
    @Json NVARCHAR(MAX) /*NQC*/
AS
BEGIN
    DECLARE @Query NVARCHAR(MAX) /*NQC*/ = dsp.Json_GetSelectScript(@Json);
    EXEC (@Query);
END;
GO
PRINT N'Creating [dsp].[DateTime_FormatInterval]'
GO
CREATE	FUNCTION [dsp].[DateTime_FormatInterval] (@Second BIGINT,
	@Format TSTRING)
RETURNS TSTRING
AS
BEGIN
	-- Set default format
	SET @Format = ISNULL(@Format, N'h:m:s');
	RETURN dsp.DateTime_FormatIntervalMillisecond(@Second * 1000, @Format);
END;




GO
PRINT N'Creating [tCodeQuality].[test Table with IsDeleted Field must have vw... View & ..._GetProps Procedure]'
GO
CREATE PROCEDURE [tCodeQuality].[test Table with IsDeleted Field must have vw... View & ..._GetProps Procedure]
AS
BEGIN

    DECLARE @ViewId INT;
    DECLARE @ProcedureId INT;
    DECLARE @TableName sysname;
    DECLARE @ProcUseView BIT;
    DECLARE @ViewUseIsDeletedWhereClause BIT;
    DECLARE @msg TSTRING = '';

    DECLARE TablesCursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
    SELECT  TableName = T.name, ViewId = V.object_id, ProcedureId = PRC.object_id,
        ProcUseView = CASE
                          WHEN CHARINDEX('vw_' + T.name, OBJECT_DEFINITION(PRC.object_id)) < 1
                              THEN 0 ELSE 1
                      END, ViewUseIsDeletedWhereClause = CASE
                                                             WHEN OBJECT_DEFINITION(V.object_id) LIKE '%IsDeleted = 0%'
                                                                 THEN 1 ELSE 0
                                                         END
      FROM  sys.columns C
            INNER JOIN sys.tables T ON T.object_id = C.object_id
            LEFT OUTER JOIN sys.views V ON V.name = 'vw_' + T.name AND  V.schema_id = T.schema_id
            LEFT OUTER JOIN sys.procedures PRC ON PRC.name = T.name + '_GetProps' AND   PRC.schema_id = T.schema_id
     WHERE  (1 = 1) AND C.name LIKE '%IsDeleted%';

    OPEN TablesCursor;
    FETCH NEXT FROM TablesCursor
     INTO @TableName, @ViewId, @ProcedureId, @ProcUseView, @ViewUseIsDeletedWhereClause;
    WHILE @@FETCH_STATUS = 0
    BEGIN
        -- Check view existance
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'For Table "{0}": Checking : View "vw_{1}" object existance', @Param0 = @TableName,
        @Param1 = @TableName;
        IF @ViewId IS NULL
            SET @msg = @msg + '--> For Table "' + @TableName + '": Check : View "vw_' + @TableName + '" object NOT Exist' + CHAR(13);

        -- Check view has "IsDeleted = 0" in where clause
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'For Table "{0}": Checking : View "vw_{1}" Use "IsDelete = 0" expression in where clause',
            @Param0 = @TableName, @Param1 = @TableName, @Param2 = @TableName;
        IF @ViewUseIsDeletedWhereClause = 0
            SET @msg =
                @msg + '--> For Table "' + @TableName + '": Check : View "vw_' + @TableName + '" Dont use "IsDelete = 0" expression in where clause' + CHAR(13);

        -- Check _GetProps procedure existance
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'For Table "{0}": Checking : Procedure "{1}_GetProps" object existance', @Param0 = @TableName,
            @Param1 = @TableName;
        IF @ProcedureId IS NULL
            SET @msg = @msg + '--> For Table "' + @TableName + '": Check : Procedure "' + @TableName + '_GetProps" object NOT Exist' + CHAR(13);

        -- Check _GetProps use vw_... view
        EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = 'For Table "{0}": Checking : Procedure "{1}_GetProps" Use View "vw_{2}" for fetch datas',
            @Param0 = @TableName, @Param1 = @TableName, @Param2 = @TableName;
        IF @ProcUseView = 0
            SET @msg =
                @msg + '--> For Table "' + @TableName + '": Check : Procedure "' + @TableName + '_GetProps" Dont use View "vw_' + @TableName
                + '" for fetch datas' + CHAR(13);

        FETCH NEXT FROM TablesCursor
         INTO @TableName, @ViewId, @ProcedureId, @ProcUseView, @ViewUseIsDeletedWhereClause;
    END;
    CLOSE TablesCursor;
    DEALLOCATE TablesCursor;

    IF @msg <> ''
    BEGIN
        SET @msg = CHAR(13) + @msg;
        EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = @msg;
    END;


END;

GO
PRINT N'Creating [dsp].[SetIfChanged_String]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_String]
    @ProcId INT, @PropName TSTRING, @NewValue TSTRING, @OldValue TSTRING OUTPUT, @HasPermission BIT = NULL, @NullAsNotSet BIT = 0, @IsUpdated BIT = NULL OUTPUT
AS
BEGIN
    SET @HasPermission = ISNULL(@HasPermission, 1);

    IF (dsp.Param_IsChanged(dsp.Convert_ToSqlvariant(@OldValue), dsp.Convert_ToSqlvariant(@NewValue), @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;






GO
PRINT N'Creating [dsp].[SetIfChanged_Int]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_Int]
    @ProcId INT, @PropName TSTRING, @NewValue BIGINT, @OldValue BIGINT OUTPUT, @HasPermission BIT = NULL, @NullAsNotSet BIT = 0, @IsUpdated BIT = NULL OUTPUT
AS
BEGIN
    SET @IsUpdated = ISNULL(@IsUpdated, 0);
    SET @HasPermission = ISNULL(@HasPermission, 1);
    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;


GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_$Validate]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePatternStep_$Validate]
    @MessagePatternId INT, @MessagePatternStepId INT = -1, @MessagePatternStepTypeId INT = -1, @ParameterName TSTRING = '<notset>',
    @SendMessageValue TSTRING = '<notset>', @DefaultValue TSTRING = '<notset>', @ConfirmHasCustomValidation INT = -1, @HasCustomValue INT = -1, @Order INT = -1
AS
BEGIN
    SET NOCOUNT ON;

    /* MessagePatternStepType behavior table
	MessagePatternStepTypeId	MessagePatternStepType		CanHasDefaultValue	IsProcedureParam	CanSendMessage	ConfirmHasCustomValidation	HasCustomValue
						1		InputParam					1					1					0				0							1
						2		OutputParam					0					1					0				0							0
						3		InputOutputParam			1					1					0				0							1
						4		SendMessage					0					0					1				0							0
						5		Confirm						0					0					1				1							0
						6		DoRun						0					0					1				0							0
						7		DoCheckConfirmActivation	0					0					0				0							0
	*/

    --consts
    DECLARE @TypeIs_Input TINYINT = dspconst.MessagePatternStepType_InputParam();
    DECLARE @TypeIs_Output TINYINT = dspconst.MessagePatternStepType_OutputParam();
    DECLARE @TypeIs_InputOutput TINYINT = dspconst.MessagePatternStepType_InputOutputParam();
    DECLARE @TypeIs_Confirmation TINYINT = dspconst.MessagePatternStepType_Confirm();
    DECLARE @TypeIs_SendMessage TINYINT = dspconst.MessagePatternStepType_SendMessage();
    DECLARE @TypeIs_DoRun TINYINT = dspconst.MessagePatternStepType_DoRun();
    DECLARE @TypeIs_DoCheckConfirmActivation TINYINT = dspconst.MessagePatternStepType_DoCheckConfirmActivation();

    --Validate Call Mode
    --Is Better to Create dspconst Function
    DECLARE @State_Create INT = 1;
    DECLARE @State_SetProp INT = 2;
    DECLARE @ValidateState INT = CASE
                                     WHEN ISNULL(@MessagePatternStepId, 0) > 0
                                         THEN @State_SetProp ELSE @State_Create
                                 END;

    -- call GetProps for required data in validation
    DECLARE @OldMessagePatternStepTypeId INT;
    DECLARE @OldParameterName TSTRING;
    DECLARE @OldSendMessageValue TSTRING;
    DECLARE @OldDefaultValue TSTRING;
    DECLARE @OldConfirmHasCustomValidation BIT;
    DECLARE @OldHasCustomValue BIT;
    DECLARE @OldOrder INT;

    IF @ValidateState = @State_SetProp
    BEGIN
        EXEC dspInboxMessage.MessagePatternStep_GetProps @MessagePatternStepId = @MessagePatternStepId,
            @MessagePatternStepTypeId = @OldMessagePatternStepTypeId OUTPUT, @ParameterName = @OldParameterName OUTPUT,
            @SendMessageValue = @OldSendMessageValue OUTPUT, @DefaultValue = @OldDefaultValue OUTPUT,
            @ConfirmHasCustomValidation = @OldConfirmHasCustomValidation OUTPUT, @HasCustomValue = @OldHasCustomValue OUTPUT, @Order = @OldOrder OUTPUT;
    END;

    -- Validate MessagePatternId
    IF (@ValidateState = @State_Create) --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'MessagePatternId', @ArgumentValue = @MessagePatternId;

    -- Validate MessagePatternStepTypeId
    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'MessagePatternStepTypeId', @OldValue = @OldMessagePatternStepTypeId OUT,
        @NewValue = @MessagePatternStepTypeId;
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'MessagePatternStepTypeId', @ArgumentValue = @OldMessagePatternStepTypeId;

    -- Validate ParameterName
    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'ParameterName', @OldValue = @OldParameterName OUT, @NewValue = @ParameterName;
    IF @OldMessagePatternStepTypeId IN ( @TypeIs_Input, @TypeIs_Output, @TypeIs_InputOutput )
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'ParameterName', @ArgumentValue = @OldParameterName;
    ELSE IF @OldParameterName IS NOT NULL
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ParameterName can not assign';

    -- Validate SendMessageValue
    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'SendMessageValue', @OldValue = @OldSendMessageValue OUT, @NewValue = @SendMessageValue;
    IF @OldMessagePatternStepTypeId IN ( @TypeIs_SendMessage, @TypeIs_Confirmation )
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'SendMessageValue', @ArgumentValue = @OldSendMessageValue;
    ELSE IF (@OldMessagePatternStepTypeId NOT IN ( @TypeIs_DoRun ) AND  @OldSendMessageValue IS NOT NULL) --
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'SendMessageValue can not assign';

    -- Validate HasCustomValue
    EXEC dsp.SetIfChanged_Int @ProcId = @@PROCID, @PropName = 'HasCustomValue', @OldValue = @OldHasCustomValue OUT, @NewValue = @HasCustomValue;
    IF @OldMessagePatternStepTypeId IN ( @TypeIs_Input, @TypeIs_InputOutput )
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'HasCustomValue', @ArgumentValue = @OldHasCustomValue;
    ELSE IF @OldHasCustomValue IS NOT NULL AND  @OldHasCustomValue = 1
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'HasCustomValue can not assign';

    -- Validate ConfirmHasCustomValidation
    EXEC dsp.SetIfChanged_Int @ProcId = @@PROCID, @PropName = 'ConfirmHasCustomValidation', @OldValue = @OldConfirmHasCustomValidation OUT,
        @NewValue = @ConfirmHasCustomValidation;
    IF (@OldMessagePatternStepTypeId IN ( @TypeIs_Confirmation )) --
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'ConfirmHasCustomValidation', @ArgumentValue = @OldConfirmHasCustomValidation;
    ELSE IF (ISNULL(@OldConfirmHasCustomValidation,0) <> 0) --
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ConfirmHasCustomValidation can not assign';

    -- Validate DefaultValue
    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'DefaultValue', @OldValue = @OldDefaultValue OUT, @NewValue = @DefaultValue;

    IF (   @OldMessagePatternStepTypeId IN ( @TypeIs_SendMessage, @TypeIs_Output, @TypeIs_DoRun, @TypeIs_DoCheckConfirmActivation ) --
           AND  @OldDefaultValue IS NOT NULL)
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'DefaultValue can not assign';

    -- Validate Order
    EXEC dsp.SetIfChanged_Int @ProcId = @@PROCID, @PropName = 'Order', @OldValue = @OldOrder OUT,
        @NewValue = @Order;
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'Order', @ArgumentValue = @OldOrder;
	IF @OldMessagePatternStepTypeId = @TypeIs_DoCheckConfirmActivation AND @OldOrder <> 0
        EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'Order can not change';


    -- Validate ParameterName Existance
    IF @OldMessagePatternStepTypeId IN ( @TypeIs_Input, @TypeIs_Output, @TypeIs_InputOutput )
    BEGIN
        -- call GetProps for get @ResponseProcedureName
        DECLARE @ResponseProcedureName TSTRING;
        DECLARE @ResponseProcedureSchemaName TSTRING;
        EXEC dspInboxMessage.MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @ResponseProcedureSchemaName = @ResponseProcedureSchemaName OUTPUT,
            @ResponseProcedureName = @ResponseProcedureName OUTPUT;
        SET @ResponseProcedureName = @ResponseProcedureSchemaName + '.' + @ResponseProcedureName;

        IF NOT EXISTS (   SELECT    'Parameter_name' = name
                            FROM    sys.parameters
                           WHERE object_id = OBJECT_ID(@ResponseProcedureName) AND  REPLACE(name, '@', '') = REPLACE(@ParameterName, '@', ''))
            EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ParameterName is invalid';

        -- Validate Output ParameterName is define OUTPUT in Response procedure
        IF (@OldMessagePatternStepTypeId IN ( dspconst.MessagePatternStepType_OutputParam(), dspconst.MessagePatternStepType_InputOutputParam())) AND
           NOT EXISTS (   SELECT    'Parameter_name' = name
                            FROM    sys.parameters
                           WHERE   object_id = OBJECT_ID(@ResponseProcedureName) AND   REPLACE(name, '@', '') = REPLACE(@ParameterName, '@', '') AND
                                   is_output = 1)
            EXEC dsperr.ThrowInvalidArgument @ProcId = @@PROCID, @Message = 'ParameterName is not output parameter';
    END;

END;
GO
PRINT N'Creating [tCodeQuality].[test ValidateSubstitutionOfFunctioncallWithInteger]'
GO
CREATE PROCEDURE [tCodeQuality].[test ValidateSubstitutionOfFunctioncallWithInteger]
AS
BEGIN
    SET NOCOUNT ON;

    -- Getting Stored Procedures and Functions definition
    EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Getting Stored Procedures definition';
    DECLARE Text_Cursor CURSOR FAST_FORWARD FORWARD_ONLY FORWARD_ONLY LOCAL FOR --
    SELECT  PD.StoredProcedureSchemaName, PD.StoredProcedureName, dsp.String_RemoveWhitespacesBig(PD.StoredProcedureDefinitionCode)
      FROM  dsp.StoredProcedure_List(NULL) AS PD
     WHERE  PD.StoredProcedureSchemaName IN ( 'api', 'dbo' )
    UNION ALL
    SELECT  FL.FunctionSchemaName, FL.FunctionName, FL.FunctionDefinitionCode
      FROM  dsp.Function_List(NULL) AS FL;


    OPEN Text_Cursor;

    DECLARE @Script TBIGSTRING;
    DECLARE @ObjectName TSTRING;
    DECLARE @SchemaName TSTRING;
    DECLARE @Pattern TSTRING = '/*co' + 'nst.';

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM Text_Cursor
         INTO @SchemaName, @ObjectName, @Script;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        -- Cutting out text before /*co+nst
        DECLARE @StartIndex INT = CHARINDEX(@Pattern, @Script);
        SET @Script = SUBSTRING(@Script, @StartIndex - 1, (LEN(@Script) - @StartIndex) + 1);

        IF (CHARINDEX(@Pattern, @Script) = 0)
            CONTINUE;

        -- Validate Function Id with Corresponding value
        WHILE (CHARINDEX(@Pattern, @Script) > 0)
        BEGIN
            DECLARE @ConstFunctionName TSTRING;
            DECLARE @ConstValueInFunction INT;
            DECLARE @ConstValueInScript INT;
            DECLARE @IsMatch BIT;
            EXEC tCodeQuality.Private_CompareConstFunctionReturnValueWithScriptValue @Script = @Script OUTPUT, @ConstFunctionName = @ConstFunctionName OUTPUT,
                @ConstValueInFunction = @ConstValueInFunction OUTPUT, @ConstValueInScript = @ConstValueInScript OUTPUT, @IsMatch = @IsMatch OUTPUT;

            IF (@IsMatch = 0)
            BEGIN
                DECLARE @FullObjectName TSTRING = @SchemaName + '.' + @ObjectName;
                DECLARE @Message TSTRING;
                EXEC @Message = dsp.Formatter_FormatMessage @Message = N'\nConstValueInFunction({0}) and ConstValueInScript({1}) are inconsistence;\nthe function name is: {2} in the SP: {3}',
                    @Param0 = @ConstValueInFunction, @Param1 = @ConstValueInScript, @Param2 = @ConstFunctionName, @Param3 = @FullObjectName;

                SET @Message = dsp.String_ReplaceEnter(@Message);
                EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message;
            END;

            SET @StartIndex = CHARINDEX(@Pattern, @Script);
            SET @Script = SUBSTRING(@Script, @StartIndex, (LEN(@Script) - @StartIndex) + 1);
        END;
    END;
    CLOSE Text_Cursor;
    DEALLOCATE Text_Cursor;
END;



GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_Create]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePatternStep_Create]
    @MessagePatternId INT, @MessagePatternStepTypeId INT = NULL, @ParameterName TSTRING = NULL, @SendMessageValue TSTRING = NULL, @DefaultValue TSTRING = NULL,
    @Description TSTRING = NULL, @Order INT = NULL, @ConfirmHasCustomValidation BIT = NULL, @HasCustomValue BIT = NULL, @MessagePatternStepId INT = NULL OUTPUT
AS
BEGIN
    SET NOCOUNT ON;
    --validate data
    EXEC dspInboxMessage.[MessagePatternStep_$Validate] @MessagePatternId = @MessagePatternId, @MessagePatternStepId = @MessagePatternStepId,
        @MessagePatternStepTypeId = @MessagePatternStepTypeId, @ParameterName = @ParameterName, @SendMessageValue = @SendMessageValue,
        @DefaultValue = @DefaultValue, @ConfirmHasCustomValidation = @ConfirmHasCustomValidation, @HasCustomValue = @HasCustomValue, @Order = @Order;

    --insert data
    INSERT INTO dspInboxMessage.MessagePatternStep (MessagePatternId, MessagePatternStepTypeId, ParameterName, SendMessageValue, [Order], DefaultValue,
        Description, ConfirmHasCustomValidation, HasCustomValue)
    VALUES (@MessagePatternId, @MessagePatternStepTypeId, @ParameterName, @SendMessageValue, @Order, @DefaultValue, @Description, @ConfirmHasCustomValidation,
        @HasCustomValue);

    SET @MessagePatternStepId = SCOPE_IDENTITY();
END;
GO
PRINT N'Creating [dsp].[Lock_IsHold]'
GO
CREATE	PROCEDURE [dsp].[Lock_IsHold]
	@ObjectTypeName TSTRING, @ObjectName TSTRING = NULL, @IsTransactionMode BIT = 1, @IsLockHold BIT = NULL OUT
AS
BEGIN
	SET @ObjectName = ISNULL(@ObjectName, '');
	SET @IsTransactionMode = ISNULL(@IsTransactionMode, 0);
	DECLARE @LockName TSTRING = @ObjectTypeName + @ObjectName;
	DECLARE @LockOwner TSTRING = IIF(@IsTransactionMode = 1, 'Transaction', 'Session');

	-- Check that Session in Lock
	SET @IsLockHold = IIF(APPLOCK_TEST('public', @LockName, 'Exclusive', @LockOwner) = 1, 0, 1);
END;
































GO
PRINT N'Creating [api].[System_Api]'
GO

/*
#MetaStart
{
	"DataAccessMode": "ReadSnapshot"
} 
#MetaEnd
*/
CREATE PROCEDURE [api].[System_Api]
	@Context TCONTEXT OUTPUT, @Api TJSON = NULL OUT
WITH EXECUTE AS OWNER
AS
BEGIN
	SET NOCOUNT ON;
	EXEC dsp.Context_Verify @Context = @Context OUT, @ProcId = @@PROCID;

	-- Any user should have access to this procedure

	-- Call dsp
	EXEC dsp.System_Api @Api = @Api OUTPUT;
END;
GO
PRINT N'Creating [dsp].[DaysOfTheWeek_FromString]'
GO

CREATE FUNCTION [dsp].[DaysOfTheWeek_FromString] (@Days NVARCHAR(MAX /*NCQ*/))
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
	-- SQL Prompt Formatting Off
	DECLARE @ret INT = 0;
	IF ( @Days LIKE '%sun%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x01;
	IF ( @Days LIKE '%mon%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x02;
	IF ( @Days LIKE '%tue%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x04;
	IF ( @Days LIKE '%wed%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x08;
	IF ( @Days LIKE '%thu%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x10;
	IF ( @Days LIKE '%fri%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x20;
	IF ( @Days LIKE '%sat%' COLLATE Latin1_General_CI_AI) SET @ret = @ret  | 0x40;
	RETURN @ret
END
GO
PRINT N'Creating [dsp].[DateTime_GetLastDayTimeOfWeek]'
GO

CREATE   FUNCTION [dsp].[DateTime_GetLastDayTimeOfWeek] (@DayOfWeek INT,
    @Time TIME)
RETURNS DATETIME
AS
BEGIN
    -- Calculate last settlement date by SettlementDayOfWeek
    DECLARE @Date DATE = GETDATE();
    WHILE (dsp.DaysOfTheWeek_FromString(DATENAME(WEEKDAY, @Date)) <> @DayOfWeek)
    SET @Date = DATEADD(DAY, -1, @Date);

    DECLARE @LastDayTime DATETIME = CONVERT(DATETIME2, CONCAT(@Date, ' ', @Time));

    RETURN @LastDayTime;
END;
GO
PRINT N'Creating [tCodeQuality].[test Wrong use of Private class]'
GO
CREATE PROCEDURE [tCodeQuality].[test Wrong use of Private class]
AS
BEGIN
    -- Declaring pattern
    DECLARE @SchemaName TSTRING;
    DECLARE @ObjectName TSTRING;
    DECLARE @Script TBIGSTRING;
    DECLARE @ClassName TSTRING;

    -- Get procedures and find className
    DECLARE Procedures_Cursor CURSOR LOCAL FAST_FORWARD READ_ONLY FOR --
    SELECT  PD.StoredProcedureSchemaName, --
        PD.StoredProcedureName, REPLACE(REPLACE(REPLACE(PD.StoredProcedureDefinitionCode, CHAR(10), ''), CHAR(13), ''), CHAR(9), ' '), --
        SUBSTRING(PD.StoredProcedureName, 1, CHARINDEX('_', PD.StoredProcedureName) - 1) AS ClassName
      FROM  dsp.StoredProcedure_List(NULL) AS PD
     WHERE  PD.StoredProcedureName NOT LIKE '%test%' --
        AND CHARINDEX('_', PD.StoredProcedureName) > 0 --
        AND CHARINDEX('_$', PD.StoredProcedureDefinitionCode) > 0 --
        AND CHARINDEX('_$', PD.StoredProcedureName) = 0 AND PD.StoredProcedureSchemaName <> 'tUtil';

    OPEN Procedures_Cursor;

    FETCH NEXT FROM Procedures_Cursor
     INTO @SchemaName, @ObjectName, @Script, @ClassName;

    SET @ClassName = REPLACE(@ClassName, '[', '');
    DECLARE @Msg TSTRING;

    WHILE (@@FETCH_STATUS = 0)
    BEGIN
        DECLARE @HasWrongClassName BIT = 0;
        SELECT  @HasWrongClassName = 1
          FROM  STRING_SPLIT(@Script, ' ') AS SS
         WHERE  CHARINDEX('_$', SS.value) > 0 AND   REPLACE(SS.value, '[', '') NOT LIKE '%.' + @ClassName + '_$%';

        EXEC @Msg = dsp.Formatter_FormatMessage @Message = 'ObjectName: [{0}].[{1}]', @Param0 = @SchemaName, @Param1 = @ObjectName;
        IF (@HasWrongClassName = 1) --
            EXEC dsptest.Fail @ProcId = @@PROCID, @Message0 = @Msg;

        -- fetch next record
        FETCH NEXT FROM Procedures_Cursor
         INTO @SchemaName, @ObjectName, @Script, @ClassName;
    END;

    CLOSE Procedures_Cursor;
    DEALLOCATE Procedures_Cursor;
END;

GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_CreateBulk]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePatternStep_CreateBulk]
    @MessagePatternId INT, @StepItems TJSON
AS
BEGIN
    -- Declare variable for step cursor
    DECLARE @MessagePatternStepId INT;
    DECLARE @MessagePatternStepTypeId TINYINT;
    DECLARE @ParameterName TSTRING;
    DECLARE @SendMessageValue TSTRING;
    DECLARE @Order INT;
    DECLARE @DefaultValue TSTRING;
    DECLARE @StepDescription TSTRING;
    DECLARE @ConfirmHasCustomValidation BIT;
	DECLARE @HasCustomValue BIT;

    DECLARE _Cursor CURSOR LOCAL FAST_FORWARD FORWARD_ONLY FOR -- 
    SELECT  MessagePatternStepId, MessagePatternStepTypeId, ParameterName, SendMessageValue, [Order], DefaultValue, Description, ConfirmHasCustomValidation, HasCustomValue
      FROM
        OPENJSON(@StepItems)
        WITH (MessagePatternStepId INT, MessagePatternStepTypeId TINYINT, ParameterName TSTRING, SendMessageValue TSTRING, [Order] INT, DefaultValue TSTRING,
            [Description] TSTRING, ConfirmHasCustomValidation BIT, HasCustomValue BIT);

    OPEN _Cursor;

    WHILE (1 = 1)
    BEGIN
        FETCH NEXT FROM _Cursor
         INTO @MessagePatternStepId, @MessagePatternStepTypeId, @ParameterName, @SendMessageValue, @Order, @DefaultValue, @StepDescription,
             @ConfirmHasCustomValidation, @HasCustomValue;
        IF (@@FETCH_STATUS <> 0)
            BREAK;

        -- Call create for step
        EXEC dspInboxMessage.MessagePatternStep_Create @MessagePatternId = @MessagePatternId, @MessagePatternStepTypeId = @MessagePatternStepTypeId,
            @ParameterName = @ParameterName, @SendMessageValue = @SendMessageValue, @DefaultValue = @DefaultValue, @Description = @StepDescription,
            @Order = @Order, @ConfirmHasCustomValidation = @ConfirmHasCustomValidation, @HasCustomValue = @HasCustomValue;

    END;
    CLOSE _Cursor;
    DEALLOCATE _Cursor;
END;
GO
PRINT N'Creating [dsp].[Lock_Release]'
GO
CREATE	PROCEDURE [dsp].[Lock_Release]
	@LockId TSTRING
AS
BEGIN
	-- Ignore if no lock obtained
	IF (@LockId IS NULL)
		RETURN;

	DECLARE @LockName TSTRING = JSON_VALUE(@LockId, '$.LockName');
	DECLARE @LockOwner TSTRING = JSON_VALUE(@LockId, '$.LockOwner');

	-- Don't release lock for transaction to prevent release on uncommitted lock
	IF (@LockOwner = 'Transaction')
	BEGIN
		SET @LockId = NULL;
		RETURN;
	END;

	-- Release the lock
	DECLARE @Result INT;
	EXEC @Result = sys.sp_releaseapplock @Resource = @LockName, @LockOwner = @LockOwner;

	-- throw error for error result
	IF (@Result < 0) --
		EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = N'Release AppLock Error! ErrorNumber: {0}', @Param0 = @Result;

	SET @LockId = NULL;
END;















GO
PRINT N'Creating [dsp].[DaysOfTheWeek_ToString]'
GO
CREATE   FUNCTION [dsp].[DaysOfTheWeek_ToString] (@DaysOfWeek INT)
RETURNS TSTRING
AS
BEGIN
    DECLARE @ret TSTRING = '';
    IF (@DaysOfWeek & 0x01 = 0x01)
        SET @ret = @ret + 'sun,';
    IF (@DaysOfWeek & 0x02 = 0x02)
        SET @ret = @ret + 'mon,';
    IF (@DaysOfWeek & 0x04 = 0x04)
        SET @ret = @ret + 'tue,';
    IF (@DaysOfWeek & 0x08 = 0x08)
        SET @ret = @ret + 'wed,';
    IF (@DaysOfWeek & 0x10 = 0x10)
        SET @ret = @ret + 'thu,';
    IF (@DaysOfWeek & 0x20 = 0x20)
        SET @ret = @ret + 'fri,';
    IF (@DaysOfWeek & 0x40 = 0x40)
        SET @ret = @ret + 'sat,';

    SET @ret = IIF(@ret LIKE '%,', LEFT(@ret, LEN(@ret) - 1), @ret);
    RETURN @ret;
END;
GO
PRINT N'Creating [dspInboxMessage].[MessagePatternStep_CreateCheckConfirmActivationStep]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePatternStep_CreateCheckConfirmActivationStep]
    @MessagePatternId INT
AS
BEGIN
    INSERT INTO dspInboxMessage.MessagePatternStep (MessagePatternId, MessagePatternStepTypeId, [Order])
    VALUES (@MessagePatternId, dspconst.MessagePatternStepType_DoCheckConfirmActivation(), 0);
END;
GO
PRINT N'Creating [dsp].[Log_Enable]'
GO
CREATE PROCEDURE [dsp].[Log_Enable]
    @RemoveAllFilters AS BIT = 0
AS
BEGIN
    SET @RemoveAllFilters = ISNULL(@RemoveAllFilters, 0);

	-- Find current status
    DECLARE @IsEnabled BIT;
    SELECT  @IsEnabled = LU.IsEnabled
      FROM  dsp.LogUser AS LU
     WHERE  LU.UserName = SYSTEM_USER;

    -- Set enable flag
    IF (@IsEnabled IS NULL)
        INSERT  dsp.LogUser (UserName, IsEnabled)
        VALUES (SYSTEM_USER, 1);
    ELSE
        UPDATE  dsp.LogUser
           SET  IsEnabled = 1
         WHERE  UserName = SYSTEM_USER;

    -- Remove All old filters
    IF (@RemoveAllFilters = 1)
        EXEC dsp.Log_RemoveFilter @Filter = NULL;

   -- Cache the result
    EXEC sys.sp_set_session_context 'dsp.Log_IsEnabled', 1, @read_only = 0;

    PRINT 'LogSystem> LogSystem has been enabled.';
END;





GO
PRINT N'Creating [dsp].[Log_RemoveFilter]'
GO
-- @Filter if NULL then all filter will be removed
CREATE PROCEDURE [dsp].[Log_RemoveFilter]
    @Filter TSTRING = NULL
AS
BEGIN
	SET NOCOUNT ON;
	-- Enable the Log System
    IF ( dsp.Log_IsEnabled() = 0 )
        EXEC dsp.Log_Enable;

	-- Remove all filters
    IF ( @Filter IS NULL )
    BEGIN
        DELETE  dsp.LogFilterSetting
        WHERE   UserName = SYSTEM_USER;
        PRINT 'LogSystem> All filters have been removed.';
        RETURN;
    END;
	
	-- Remove the existing filter
    IF EXISTS ( SELECT 1 FROM dsp.LogFilterSetting AS LFS WHERE LFS.Log_Filter = @Filter AND LFS.UserName = SYSTEM_USER )
    BEGIN
        DELETE  LogFilterSetting
        WHERE   Log_Filter = @Filter AND UserName = SYSTEM_USER;
        PRINT 'LogSystem> Filter has been removed.';
        RETURN;
    END;
	
	-- Print not-find message
    PRINT 'LogSystem> Could not find the filter.';
END;


GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_Create]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_Create]
    @MessagePatternId INT = NULL OUTPUT, @PatternName TSTRING = NULL, @StartTime DATETIME = NULL, @ExpirationTime DATETIME = NULL,
    @MessagePatternSepratorId INT = NULL, @ResponseProcedureSchemaName TSTRING = NULL, @ResponseProcedureName TSTRING = NULL, @PatternKey TSTRING = NULL,
    @Description TSTRING = NULL, @StepItems TJSON = NULL
AS
BEGIN
    SET NOCOUNT ON;
    SET @MessagePatternId = NULL;

    DECLARE @MessagePatternStateId INT;
    SET @MessagePatternStateId = dspconst.MessagePatternStateId_Drafted();

    -- Validate Data
    EXEC dspInboxMessage.MessagePattern_$Validate @MessagePatternId = @MessagePatternId, @PatternName = @PatternName, @StartTime = @StartTime,
        @ExpirationTime = @ExpirationTime, @MessagePatternSepratorId = @MessagePatternSepratorId, @PatternKey = @PatternKey,
        @MessagePatternStateId = @MessagePatternStateId, @ResponseProcedureSchemaName = @ResponseProcedureSchemaName,
        @ResponseProcedureName = @ResponseProcedureName;

    -- Insert Into MessagePattern Table
    DECLARE @TranCount INT = @@TRANCOUNT;
    BEGIN TRY
        IF (@TranCount = 0)
            BEGIN TRANSACTION;

        -- Insert header data
        INSERT INTO dspInboxMessage.MessagePattern (PatternName, StartTime, ExpirationTime, MessagePatternSepratorId, PatternKey, MessagePatternStateId,
            [Description], ResponseProcedureSchemaName, ResponseProcedureName)
        VALUES (@PatternName, @StartTime, @ExpirationTime, @MessagePatternSepratorId, @PatternKey, @MessagePatternStateId, @Description,
            @ResponseProcedureSchemaName, @ResponseProcedureName);

        SET @MessagePatternId = SCOPE_IDENTITY();

        -- Create steps
        EXEC dspInboxMessage.MessagePatternStep_CreateCheckConfirmActivationStep @MessagePatternId = @MessagePatternId;
        EXEC dspInboxMessage.MessagePatternStep_CreateBulk @MessagePatternId = @MessagePatternId, @StepItems = @StepItems;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION; --
        DECLARE @ErrorMessage TSTRING = ERROR_MESSAGE();
        EXEC dsp.Exception_ThrowWithCommonFormat @ProcId = @@PROCID, @ErrorMessage = @ErrorMessage;
    END CATCH;
END;

GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_Delete]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_Delete]
    @MessagePatternId INT
AS
BEGIN
    -- Check if tag does not exists
    DECLARE @MessagePatternStateId INT;
    EXEC dspInboxMessage.MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @MessagePatternStateId = @MessagePatternStateId OUTPUT;

    -- Check if Pattern State Is Started Then Throw
    IF (@MessagePatternStateId = dspconst.MessagePatternStateId_Started())
        EXEC dsp.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Pattern With Started State can not Deleted';

    -- Check if Pattern State Is Paused Then Throw
    IF (@MessagePatternStateId = dspconst.MessagePatternStateId_Paused())
        EXEC dsp.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Pattern With Paused State can not Deleted';

    -- Delete from local pattern
    UPDATE  dspInboxMessage.MessagePattern
       SET  IsDeleted = 1
     WHERE  MessagePatternId = @MessagePatternId;
END;
GO
PRINT N'Creating [dsp].[Log_AddFilter]'
GO
CREATE PROCEDURE [dsp].[Log_AddFilter]
    @Filter TSTRING = NULL,
    @IsExclude BIT = 0
AS
BEGIN
	SET NOCOUNT ON;
	SET @IsExclude = ISNULL(@IsExclude, 0);

	-- Enable the Log System
	IF (dsp.Log_IsEnabled() = 0)
		EXEC dsp.Log_Enable;
	
	-- Clear Filters
	IF (@Filter IS NULL AND @IsExclude = 1)
	BEGIN
		DELETE dsp.LogFilterSetting WHERE UserName = SYSTEM_USER AND IsExludedFilter = 1;
		PRINT 'LogSystem> All exclude filters have been removed.';
		RETURN;
	END

	IF (@Filter IS NULL AND @IsExclude = 0)
	BEGIN
		DELETE dsp.LogFilterSetting WHERE UserName = SYSTEM_USER AND IsExludedFilter = 0;
		PRINT 'LogSystem> All include filters have been removed.';
		RETURN;
	END

	-- Insert or Update Filters
	IF EXISTS( SELECT 1 FROM dsp.LogFilterSetting AS LFS WHERE LFS.Log_Filter = @Filter)
	BEGIN
		UPDATE dsp.LogFilterSetting SET IsExludedFilter = @IsExclude WHERE Log_Filter = @Filter AND UserName = SYSTEM_USER;
		PRINT 'LogSystem> Filter has been updated.';
	END
	ELSE 
	BEGIN
		INSERT dsp.LogFilterSetting ( UserName, IsExludedFilter, Log_Filter )
		VALUES  (SYSTEM_USER, @IsExclude, @Filter);
		PRINT 'LogSystem> Filter has been added.';
	END

END



GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_DeleteMessagePatternSteps]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_DeleteMessagePatternSteps]
    @MessagePatternId INT
AS
BEGIN
    DECLARE @StepType_DoCheckConfirmActivation TINYINT = dspconst.MessagePatternStepType_DoCheckConfirmActivation();

    DELETE  FROM dspInboxMessage.MessagePatternStep
     WHERE  MessagePatternId = @MessagePatternId --
        AND MessagePatternStepTypeId <> @StepType_DoCheckConfirmActivation;
END;


GO
PRINT N'Creating [dsp].[Log_Disable]'
GO
-- Stop Logging System but keep settings
CREATE PROCEDURE [dsp].[Log_Disable]
AS
BEGIN
	
	-- Set enable flag
	UPDATE dsp.LogUser SET	IsEnabled = 0 WHERE UserName = SYSTEM_USER;
	PRINT 'LogSystem> LogSystem has been disbaled.';

	EXEC sp_set_session_context 'dsp.Log_IsEnabled', 0, @read_only = 0;

END


GO
PRINT N'Creating [dsp].[Log_Filter]'
GO
CREATE PROCEDURE [dsp].[Log_Filter]
	@Filter TSTRING = NULL
AS
BEGIN
	SET @Filter = NULLIF(@Filter, '');

	-- remove all old filters
	EXEC dsp.Log_RemoveFilter @Filter = NULL;
	IF (@Filter IS NULL)
		RETURN;

	-- set new filter
	EXEC dsp.Log_AddFilter @Filter = @Filter, @IsExclude = 0;
END;

GO
PRINT N'Creating [dsp].[Param_IsSetForMaxSize]'
GO
CREATE FUNCTION [dsp].[Param_IsSetForMaxSize] (@Value NVARCHAR(MAX /*NCQ*/))
RETURNS BIT
WITH SCHEMABINDING
AS
BEGIN
    IF (@Value IS NULL)
        RETURN 0;

    IF (CAST(@Value AS NVARCHAR(MAX /*NoCodeChecker*/)) = '<notset>' OR CAST(@Value AS NVARCHAR(/*NoCodeChecker*/ 10)) = '<noaccess>')
        RETURN 0;

    RETURN 1;
END;














GO
PRINT N'Creating [dspInboxMessage].[MessagePattern_SetProps]'
GO
CREATE PROCEDURE [dspInboxMessage].[MessagePattern_SetProps]
    @MessagePatternId INT, @PatternName TSTRING = '<notset>', @StartTime DATETIME = '1753-01-01', @ExpirationTime DATETIME = '1753-01-01',
    @MessagePatternSepratorId INT = -1, @ResponseProcedureSchemaName TSTRING = '<notset>', @ResponseProcedureName TSTRING = '<notset>',
    @PatternKey TSTRING = '<notset>', @MessagePatternStateId INT = -1, @Description TSTRING = '<notset>', @StepItems TJSON = '<notset>'
AS
BEGIN
    DECLARE @OldPatternName TSTRING;
    DECLARE @OldStartTime DATETIME;
    DECLARE @OldExpirationTime DATETIME;
    DECLARE @OldMessagePatternSepratorId INT;
    DECLARE @OldResponseProcedureSchemaName TSTRING;
    DECLARE @OldResponseProcedureName TSTRING;
    DECLARE @OldPatternKey TSTRING;
    DECLARE @OldMessagePatternStateId INT;
    DECLARE @OldDescription TSTRING;
    DECLARE @OldSuccessfulProcessMessage TSTRING;

    -- Validate data
    EXEC [dspInboxMessage].[MessagePattern_$Validate] @MessagePatternId = @MessagePatternId, @PatternName = @PatternName, @StartTime = @StartTime,
        @ExpirationTime = @ExpirationTime, @MessagePatternSepratorId = @MessagePatternSepratorId, @ResponseProcedureSchemaName = @ResponseProcedureSchemaName,
        @ResponseProcedureName = @ResponseProcedureName, @PatternKey = @PatternKey, @MessagePatternStateId = @MessagePatternStateId,
        @Description = @Description;

    -- Get old props and validate Existance
    EXEC [dspInboxMessage].MessagePattern_GetProps @MessagePatternId = @MessagePatternId, @PatternName = @OldPatternName OUTPUT,
        @StartTime = @OldStartTime OUTPUT, @ExpirationTime = @OldExpirationTime OUTPUT, @MessagePatternSepratorId = @OldMessagePatternSepratorId OUTPUT,
        @ResponseProcedureSchemaName = @OldResponseProcedureSchemaName OUTPUT, @ResponseProcedureName = @OldResponseProcedureName OUTPUT,
        @PatternKey = @OldPatternKey OUTPUT, @MessagePatternStateId = @OldMessagePatternStateId OUTPUT, @Description = @Description OUTPUT;

    -- Detect if there are any changes
    DECLARE @IsRecordUpdated BIT = 0;

    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'PatternName', @IsUpdated = @IsRecordUpdated OUT, @OldValue = @OldPatternName OUT,
        @NewValue = @PatternName;

    EXEC dsp.SetIfChanged_Time @ProcId = @@PROCID, @PropName = 'StartTime', @IsUpdated = @IsRecordUpdated OUT, @OldValue = @OldStartTime OUT,
        @NewValue = @StartTime;

    EXEC dsp.SetIfChanged_Time @ProcId = @@PROCID, @PropName = 'ExpireTime', @IsUpdated = @IsRecordUpdated OUT, @OldValue = @OldExpirationTime OUT,
        @NewValue = @ExpirationTime;

    EXEC dsp.SetIfChanged_Int @ProcId = @@PROCID, @PropName = 'MessagePatternSepratorId', @IsUpdated = @IsRecordUpdated OUT,
        @OldValue = @OldMessagePatternSepratorId OUT, @NewValue = @MessagePatternSepratorId;

    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'ResponseProcedureSchemaName', @IsUpdated = @IsRecordUpdated OUT,
        @OldValue = @OldResponseProcedureSchemaName OUT, @NewValue = @ResponseProcedureSchemaName;

    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'ResponseProcedureName', @IsUpdated = @IsRecordUpdated OUT,
        @OldValue = @OldResponseProcedureName OUT, @NewValue = @ResponseProcedureName;

    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'PatternKey', @IsUpdated = @IsRecordUpdated OUT, @OldValue = @OldPatternKey OUT,
        @NewValue = @PatternKey;

    EXEC dsp.SetIfChanged_Int @ProcId = @@PROCID, @PropName = 'MessagePatternStateId', @IsUpdated = @IsRecordUpdated OUT,
        @OldValue = @OldMessagePatternStateId OUT, @NewValue = @MessagePatternStateId;

    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'Description', @IsUpdated = @IsRecordUpdated OUT, @OldValue = @OldDescription OUT,
        @NewValue = @Description;

    BEGIN
        DECLARE @TranCount INT = @@TRANCOUNT;
        IF (@TranCount = 0)
            BEGIN TRANSACTION;
        BEGIN TRY

            -- Update table if neccassary
            IF (@IsRecordUpdated = 1)
            BEGIN
                UPDATE  [dspInboxMessage].MessagePattern
                   SET  PatternName = @OldPatternName, StartTime = @OldStartTime, ExpirationTime = @OldExpirationTime,
                    MessagePatternSepratorId = @OldMessagePatternSepratorId, ResponseProcedureSchemaName = @OldResponseProcedureSchemaName,
                    ResponseProcedureName = @OldResponseProcedureName, PatternKey = @OldPatternKey, MessagePatternStateId = @OldMessagePatternStateId,
                    [Description] = @OldDescription
                 WHERE  MessagePatternId = @MessagePatternId;
            END;

            IF (dsp.Param_IsSetForMaxSize(@StepItems) = 1)
            BEGIN
                -- Call delete for old steps
                EXEC [dspInboxMessage].MessagePattern_DeleteMessagePatternSteps @MessagePatternId = @MessagePatternId;

                -- Call create step
                EXEC [dspInboxMessage].[MessagePatternStep_CreateBulk] @MessagePatternId = @MessagePatternId, @StepItems = @StepItems;
            END;
            IF (@TranCount = 0) COMMIT;
        END TRY
        BEGIN CATCH
            IF (@TranCount = 0)
                ROLLBACK TRANSACTION;
            THROW;
        END CATCH;
    END;
END;


GO
PRINT N'Creating [dsp].[Log_TraceTime]'
GO
CREATE PROCEDURE [dsp].[Log_TraceTime]
	@Time AS DATETIME OUT, @Tag TSTRING
AS
BEGIN
	SET @Time = ISNULL(@Time, GETDATE());
	DECLARE @TimeDiff INT = DATEDIFF(MILLISECOND, @Time, GETDATE());

	DECLARE @Msg TSTRING;
	EXEC @Msg = dsp.Log_FormatMessage2 @ProcId = @@PROCID, @Message = '{0}: {1}', @Param0 = @Tag, @Param1 = @TimeDiff, @Elipsis = 0;
    RAISERROR(@Msg, 0, 1) WITH NOWAIT; -- force to flush the buffer

	SET @Time = GETDATE();
END;









GO
PRINT N'Creating [tSQLt].[Private_GetQuotedTableNameForConstraint]'
GO
CREATE FUNCTION [tSQLt].[Private_GetQuotedTableNameForConstraint](@ConstraintObjectId INT)
RETURNS TABLE
AS
RETURN
  SELECT QUOTENAME(SCHEMA_NAME(newtbl.schema_id)) + '.' + QUOTENAME(OBJECT_NAME(newtbl.object_id)) QuotedTableName,
         SCHEMA_NAME(newtbl.schema_id) SchemaName,
         OBJECT_NAME(newtbl.object_id) TableName,
         OBJECT_NAME(constraints.parent_object_id) OrgTableName
      FROM sys.objects AS constraints
      JOIN sys.extended_properties AS p
      JOIN sys.objects AS newtbl
        ON newtbl.object_id = p.major_id
       AND p.minor_id = 0
       AND p.class_desc = 'OBJECT_OR_COLUMN'
       AND p.name = 'tSQLt.FakeTable_OrgTableName'
        ON OBJECT_NAME(constraints.parent_object_id) = CAST(p.value AS NVARCHAR(4000))
       AND constraints.schema_id = newtbl.schema_id
       AND constraints.object_id = @ConstraintObjectId;
GO
PRINT N'Creating [tSQLt].[Private_ApplyUniqueConstraint]'
GO
CREATE PROCEDURE [tSQLt].[Private_ApplyUniqueConstraint] 
  @ConstraintObjectId INT
AS
BEGIN
  DECLARE @SchemaName NVARCHAR(MAX);
  DECLARE @OrgTableName NVARCHAR(MAX);
  DECLARE @TableName NVARCHAR(MAX);
  DECLARE @ConstraintName NVARCHAR(MAX);
  DECLARE @CreateConstraintCmd NVARCHAR(MAX);
  DECLARE @AlterColumnsCmd NVARCHAR(MAX);
  
  SELECT @SchemaName = SchemaName,
         @OrgTableName = OrgTableName,
         @TableName = TableName,
         @ConstraintName = OBJECT_NAME(@ConstraintObjectId)
    FROM tSQLt.Private_GetQuotedTableNameForConstraint(@ConstraintObjectId);
      
  SELECT @AlterColumnsCmd = NotNullColumnCmd,
         @CreateConstraintCmd = CreateConstraintCmd
    FROM tSQLt.Private_GetUniqueConstraintDefinition(@ConstraintObjectId, QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName));

  EXEC tSQLt.Private_RenameObjectToUniqueName @SchemaName, @ConstraintName;
  EXEC (@AlterColumnsCmd);
  EXEC (@CreateConstraintCmd);
END;
GO
PRINT N'Creating [dspInboxMessage].[ProviderInfo_GetProps]'
GO
CREATE PROCEDURE [dspInboxMessage].[ProviderInfo_GetProps]
    @ProviderInfoId INT, @ProviderId INT = NULL OUTPUT, @ContactInfo TSTRING = NULL OUTPUT, @IsEnable BIT = NULL OUTPUT, @Description TSTRING = NULL OUTPUT,
    @ProviderTypeId TINYINT = NULL OUTPUT
AS
BEGIN
    DECLARE @ActualId INT;

    -- Get props
    SELECT  @ActualId = PI.ProviderInfoId, @ProviderId = PI.ProviderId, @ContactInfo = PI.ContactInfo, @IsEnable = PI.IsEnable, @Description = PI.Description,
        @ProviderTypeId = P.ProviderTypeId
      FROM  dspInboxMessage.ProviderInfo PI
            INNER JOIN dspInboxMessage.Provider P ON P.ProviderId = PI.ProviderId
     WHERE  PI.ProviderInfoId = @ProviderInfoId;

    -- Validate data existance
    IF @ActualId IS NULL
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = 'ProviderInfoId';

END;


GO
PRINT N'Creating [dsp].[SetIfChanged_Decimal]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_Decimal]
    @ProceId INT, @PropName TSTRING, @NewValue DECIMAL, @OldValue DECIMAL OUT, @HasPermission BIT = 1, @NullAsNotSet BIT = 0, @IsUpdated BIT OUT
AS
BEGIN
    SET @HasPermission = ISNULL(@HasPermission, 0);

    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProceId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;
GO
PRINT N'Creating [tSQLt].[Private_ApplyForeignKeyConstraint]'
GO
CREATE PROCEDURE [tSQLt].[Private_ApplyForeignKeyConstraint] 
  @ConstraintObjectId INT,
  @NoCascade BIT
AS
BEGIN
  DECLARE @SchemaName NVARCHAR(MAX);
  DECLARE @OrgTableName NVARCHAR(MAX);
  DECLARE @TableName NVARCHAR(MAX);
  DECLARE @ConstraintName NVARCHAR(MAX);
  DECLARE @CreateFkCmd NVARCHAR(MAX);
  DECLARE @AlterTableCmd NVARCHAR(MAX);
  DECLARE @CreateIndexCmd NVARCHAR(MAX);
  DECLARE @FinalCmd NVARCHAR(MAX);
  
  SELECT @SchemaName = SchemaName,
         @OrgTableName = OrgTableName,
         @TableName = TableName,
         @ConstraintName = OBJECT_NAME(@ConstraintObjectId)
    FROM tSQLt.Private_GetQuotedTableNameForConstraint(@ConstraintObjectId);
      
  SELECT @CreateFkCmd = cmd, @CreateIndexCmd = CreIdxCmd
    FROM tSQLt.Private_GetForeignKeyDefinition(@SchemaName, @OrgTableName, @ConstraintName, @NoCascade);
  SELECT @AlterTableCmd = 'ALTER TABLE ' + QUOTENAME(@SchemaName) + '.' + QUOTENAME(@TableName) + 
                          ' ADD ' + @CreateFkCmd;
  SELECT @FinalCmd = @CreateIndexCmd + @AlterTableCmd;

  EXEC tSQLt.Private_RenameObjectToUniqueName @SchemaName, @ConstraintName;
  EXEC (@FinalCmd);
END;
GO
PRINT N'Creating [dspInboxMessage].[Setting_SetProps]'
GO

CREATE PROCEDURE [dspInboxMessage].[Setting_SetProps]
    @WaitExpirationTreshold INT = -1, @RefreshRecordCount INT = -1, @ProcessRecordCount INT = -1, @FailedConfirmStepMessage TSTRING = '<notset>',
    @AddressRegistrationIsActive INT = -1, @FaildConfirmActivationMessage TSTRING = '<notset>'
AS
BEGIN
    IF (dsp.Param_IsSetOrNotNull(@WaitExpirationTreshold) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  WaitExpirationTreshold = @WaitExpirationTreshold;

    IF (dsp.Param_IsSetOrNotNull(@RefreshRecordCount) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  RefreshRecordCount = @RefreshRecordCount;

    IF (dsp.Param_IsSetOrNotNull(@ProcessRecordCount) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  ProcessRecordCount = @ProcessRecordCount;

    IF (dsp.Param_IsSetOrNotNull(@FailedConfirmStepMessage) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  FailedConfirmStepMessage = @FailedConfirmStepMessage;

    IF (dsp.Param_IsSetOrNotNull(@AddressRegistrationIsActive) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  AddressRegistrationIsActive = @AddressRegistrationIsActive;

    IF (dsp.Param_IsSetOrNotNull(@FaildConfirmActivationMessage) = 1)
        UPDATE  dspInboxMessage.Setting
           SET  FaildConfirmActivationMessage = @FaildConfirmActivationMessage;
END;

GO
PRINT N'Creating [dsp].[SetIfChanged_Float]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_Float]
    @ProcId INT, @PropName TSTRING, @NewValue FLOAT, @OldValue FLOAT OUT, @HasPermission BIT = 1, @NullAsNotSet BIT = 0, @IsUpdated BIT = NULL OUTPUT
AS
BEGIN
    SET @HasPermission = ISNULL(@HasPermission, 1);
    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;
GO
PRINT N'Creating [tSQLt].[Private_RemoveSchemaBinding]'
GO
CREATE PROCEDURE [tSQLt].[Private_RemoveSchemaBinding]
  @object_id INT
AS
BEGIN
  DECLARE @cmd NVARCHAR(MAX);
  SELECT @cmd = tSQLt.[Private]::GetAlterStatementWithoutSchemaBinding(SM.definition)
    FROM sys.sql_modules AS SM
   WHERE SM.object_id = @object_id;
   EXEC(@cmd);
END;
GO
PRINT N'Creating [tSQLt].[Private_ApplyCheckConstraint]'
GO
CREATE PROCEDURE [tSQLt].[Private_ApplyCheckConstraint]
  @ConstraintObjectId INT
AS
BEGIN
  DECLARE @Cmd NVARCHAR(MAX);
  SELECT @Cmd = 'CONSTRAINT ' + QUOTENAME(name) + ' CHECK' + definition 
    FROM sys.check_constraints
   WHERE object_id = @ConstraintObjectId;
  
  DECLARE @QuotedTableName NVARCHAR(MAX);
  
  SELECT @QuotedTableName = QuotedTableName FROM tSQLt.Private_GetQuotedTableNameForConstraint(@ConstraintObjectId);

  EXEC tSQLt.Private_RenameObjectToUniqueNameUsingObjectId @ConstraintObjectId;
  SELECT @Cmd = 'ALTER TABLE ' + @QuotedTableName + ' ADD ' + @Cmd
    FROM sys.objects 
   WHERE object_id = @ConstraintObjectId;

  EXEC (@Cmd);

END;
GO
PRINT N'Creating [dsptest].[AssertEquals]'
GO
CREATE PROCEDURE [dsptest].[AssertEquals]
    @Expected SQL_VARIANT, @Actual SQL_VARIANT, @Message NVARCHAR(MAX /*NCQ*/) = ''
AS
BEGIN
    IF ((@Expected = @Actual) OR (@Actual IS NULL AND   @Expected IS NULL))
        RETURN 0;

    DECLARE @GeneratedMessage NVARCHAR(MAX /*NCQ*/);
    SET @GeneratedMessage =
        N'Expected: <' + ISNULL(CAST(@Expected AS NVARCHAR(MAX /*NCQ*/)), 'NULL') + N'> but was: <' + ISNULL(CAST(@Actual AS NVARCHAR(MAX /*NCQ*/)), 'NULL')
        + N'>';

    IF ((COALESCE(@Message, '') <> '') AND  (@Message NOT LIKE '% '))
        SET @Message = @Message + ' ';

    EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message, @Param0 = @GeneratedMessage;
END;
GO
PRINT N'Creating [dsp].[SetIfChanged_Money]'
GO
CREATE PROCEDURE [dsp].[SetIfChanged_Money]
    @ProcId INT, @PropName TSTRING, @NewValue MONEY, @OldValue MONEY OUT, @HasPermission BIT = 1, @NullAsNotSet BIT = 0, @IsUpdated BIT = NULL OUTPUT
AS
BEGIN
    SET @HasPermission = ISNULL(@HasPermission, 1);

    IF (dsp.Param_IsChanged(@OldValue, @NewValue, @NullAsNotSet) = 0)
        RETURN;

    IF (@HasPermission = 0) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @ProcId, @Message = 'PropName: {0}', @Param0 = @PropName;

    SET @IsUpdated = 1;
    SET @OldValue = @NewValue;
END;
GO
PRINT N'Creating [dsp].[Exception_InvalidArgumentName]'
GO
CREATE FUNCTION [dsp].[Exception_InvalidArgumentName] (
	@ErrorMessage TSTRING
)
RETURNS TSTRING
AS
BEGIN
	RETURN JSON_VALUE(JSON_VALUE(@ErrorMessage, '$.errorMessage'), '$.ArgumentName');
END;


GO
PRINT N'Creating [tSQLt].[ApplyConstraint]'
GO
CREATE PROCEDURE [tSQLt].[ApplyConstraint]
       @TableName NVARCHAR(MAX),
       @ConstraintName NVARCHAR(MAX),
       @SchemaName NVARCHAR(MAX) = NULL, --parameter preserved for backward compatibility. Do not use. Will be removed soon.
       @NoCascade BIT = 0
AS
BEGIN
  DECLARE @ConstraintType NVARCHAR(MAX);
  DECLARE @ConstraintObjectId INT;
  
  SELECT @ConstraintType = ConstraintType, @ConstraintObjectId = ConstraintObjectId
    FROM tSQLt.Private_ResolveApplyConstraintParameters (@TableName, @ConstraintName, @SchemaName);

  IF @ConstraintType = 'CHECK_CONSTRAINT'
  BEGIN
    EXEC tSQLt.Private_ApplyCheckConstraint @ConstraintObjectId;
    RETURN 0;
  END

  IF @ConstraintType = 'FOREIGN_KEY_CONSTRAINT'
  BEGIN
    EXEC tSQLt.Private_ApplyForeignKeyConstraint @ConstraintObjectId, @NoCascade;
    RETURN 0;
  END;  
   
  IF @ConstraintType IN('UNIQUE_CONSTRAINT', 'PRIMARY_KEY_CONSTRAINT')
  BEGIN
    EXEC tSQLt.Private_ApplyUniqueConstraint @ConstraintObjectId;
    RETURN 0;
  END;  
   
  RAISERROR ('ApplyConstraint could not resolve the object names, ''%s'', ''%s''. Be sure to call ApplyConstraint and pass in two parameters, such as: EXEC tSQLt.ApplyConstraint ''MySchema.MyTable'', ''MyConstraint''', 
             16, 10, @TableName, @ConstraintName);
  RETURN 0;
END;
GO
PRINT N'Creating [dsptest].[AssertEqualsJsonWithValue]'
GO
CREATE PROCEDURE [dsptest].[AssertEqualsJsonWithValue]
    @Expected TJSON, @Actual TJSON, @Message NVARCHAR(MAX) = ''
AS
BEGIN

    DECLARE @AreSame BIT;
    EXEC dsp.Json_Compare @Json1 = @Expected, @Json2 = @Actual, @IncludeValue = 1, @IsThrow = 0, @AreSame = @AreSame OUTPUT;

    IF (@AreSame = 1)
        RETURN 0;

    DECLARE @GeneratedMessage NVARCHAR(MAX);
    SELECT  @GeneratedMessage =
        N'Expected: <' + ISNULL(CAST(@Expected AS NVARCHAR(MAX)), 'NULL') + N'> but was: <' + ISNULL(CAST(@Actual AS NVARCHAR(MAX)), 'NULL') + N'>';
    IF ((COALESCE(@Message, '') <> '') AND  (@Message NOT LIKE '% '))
        SET @Message = @Message + ' ';
    EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message, @Param0 = @GeneratedMessage;
END;

GO
PRINT N'Creating [dsp].[Formatter_FormatCardNumber]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatCardNumber] (@CardNumber TSTRING)
RETURNS TSTRING
AS
BEGIN
	SET @CardNumber = dsp.Formatter_FormatString(@CardNumber);
	SET @CardNumber = REPLACE(@CardNumber, ' ', '');
	SET @CardNumber = REPLACE(@CardNumber, '-', '');
	SET @CardNumber = REPLACE(@CardNumber, '$', '');
	RETURN IIF(ISNUMERIC(@CardNumber) = 1 AND (LEN(@CardNumber) = 16 OR		LEN(@CardNumber) = 20), @CardNumber, NULL);
END;

GO
PRINT N'Creating [dsptest].[AssertEqualsString]'
GO
CREATE   PROCEDURE [dsptest].[AssertEqualsString]
    @Expected NVARCHAR(MAX), @Actual NVARCHAR(MAX), @Message NVARCHAR(MAX) = ''
AS
BEGIN
    IF ((@Expected = @Actual) OR (@Actual IS NULL AND   @Expected IS NULL))
        RETURN 0;

    DECLARE @Msg NVARCHAR(MAX);
	SELECT  @Msg =
        CHAR(13) + CHAR(10) + N'Expected: ' + ISNULL('<' + @Expected + '>', 'NULL') + CHAR(13) + CHAR(10) + N'but was : ' + ISNULL('<' + @Actual + '>', 'NULL');
		
	EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Msg;
END;

GO
PRINT N'Creating [dsp].[Validate_IsValidEmail]'
GO

-- Email must contain @ and dot and should not finish by dot
CREATE FUNCTION [dsp].[Validate_IsValidEmail] (@Email TSTRING)
RETURNS BIT
AS
BEGIN
	DECLARE @pattern TSTRING;
	IF (@Email LIKE '%_@_%' AND @Email LIKE '%_._%' AND @Email NOT LIKE '%[.]')
		RETURN 1;
	RETURN 0;
END;


GO
PRINT N'Creating [tSQLt].[ApplyTrigger]'
GO
CREATE PROCEDURE [tSQLt].[ApplyTrigger]
  @TableName NVARCHAR(MAX),
  @TriggerName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @OrgTableObjectId INT;
  SELECT @OrgTableObjectId = OrgTableObjectId FROM tSQLt.Private_GetOriginalTableInfo(OBJECT_ID(@TableName)) orgTbl
  IF(@OrgTableObjectId IS NULL)
  BEGIN
    RAISERROR('%s does not exist or was not faked by tSQLt.FakeTable.', 16, 10, @TableName);
  END;
  
  DECLARE @FullTriggerName NVARCHAR(MAX);
  DECLARE @TriggerObjectId INT;
  SELECT @FullTriggerName = QUOTENAME(SCHEMA_NAME(schema_id))+'.'+QUOTENAME(name), @TriggerObjectId = object_id
  FROM sys.objects WHERE PARSENAME(@TriggerName,1) = name AND parent_object_id = @OrgTableObjectId;
  
  DECLARE @TriggerCode NVARCHAR(MAX);
  SELECT @TriggerCode = m.definition
    FROM sys.sql_modules m
   WHERE m.object_id = @TriggerObjectId;
  
  IF (@TriggerCode IS NULL)
  BEGIN
    RAISERROR('%s is not a trigger on %s', 16, 10, @TriggerName, @TableName);
  END;
 
  EXEC tSQLt.RemoveObject @FullTriggerName;
  
  EXEC(@TriggerCode);
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_MaxKey]'
GO

CREATE FUNCTION [dsp].[StoredProcedure_MaxKey] (@SchemaName TSTRING)
RETURNS INT
AS
BEGIN
    DECLARE @MaxKey INT;

    -- Get the max API key
    SELECT  TOP 1 @MaxKey = CAST(DSP.StoredProcedureKey AS INT)
      FROM  dsp.StoredProcedure_List(@SchemaName) AS DSP
     ORDER BY CAST(DSP.StoredProcedureKey AS INT) DESC;

    SET @MaxKey = ISNULL(@MaxKey, 0);
    SET @MaxKey = @MaxKey + 1;

    RETURN @MaxKey;
END;




GO
PRINT N'Creating [dsp].[StoredProcedure_AssignKey]'
GO
CREATE PROCEDURE [dsp].[StoredProcedure_AssignKey]
    @SchemaName TSTRING, @StoredProcedureName TSTRING
AS
BEGIN
    -- Get the max API key
    DECLARE @MaxKey TSTRING = dsp.StoredProcedure_MaxKey(@SchemaName);

    -- Get the stored procedure data attributes
    DECLARE @StoredProcedureMetadata TJSON;
    SELECT  @StoredProcedureMetadata = SPM.StoredProcedureMetadata
      FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
     WHERE  SPM.StoredProcedureName = @StoredProcedureName;

    -- Append HasNewVersion attribute
    DECLARE @NewMetadata TJSON = JSON_MODIFY(@StoredProcedureMetadata, '$.ApiKey', @MaxKey);
    SET @NewMetadata =
        REPLACE(
            @NewMetadata, CHAR(/*No Codequality Error*/ 13) + CHAR(/*No Codequality Error*/ 10) + ',"ApiKey":"' + @MaxKey + '"',
            dsp.String_ReplaceEnter(',\n	"ApiKey":"' + @MaxKey + '"\n'));

    -- Alter the stored procedure
    DECLARE @StoreProcedureDefinitionCode TBIGSTRING;
    SELECT  @StoreProcedureDefinitionCode = StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(@SchemaName)
     WHERE  StoredProcedureName = @StoredProcedureName;

    SET @StoreProcedureDefinitionCode = REPLACE(@StoreProcedureDefinitionCode, @StoredProcedureMetadata, @NewMetadata);
    SET @StoreProcedureDefinitionCode = REPLACE(@StoreProcedureDefinitionCode, 'CREATE PROCEDURE', 'ALTER PROCEDURE');

    EXEC sys.sp_executesql @StoreProcedureDefinitionCode;
END;















GO
PRINT N'Creating [dsp].[Formatter_FormatEmail]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatEmail] (@Email TSTRING)
RETURNS TSTRING
AS
BEGIN
	SET @Email = dsp.Formatter_FormatString(@Email);
	RETURN IIF(dsp.Validate_IsValidEmail(@Email) = 1, @Email, NULL);
END;

GO
PRINT N'Creating [tSQLt].[TableToText]'
GO
CREATE PROCEDURE [tSQLt].[TableToText]
    @txt NVARCHAR(MAX) OUTPUT,
    @TableName NVARCHAR(MAX),
    @OrderBy NVARCHAR(MAX) = NULL,
    @PrintOnlyColumnNameAliasList NVARCHAR(MAX) = NULL
AS
BEGIN
    SET @txt = tSQLt.Private::TableToString(@TableName, @OrderBy, @PrintOnlyColumnNameAliasList);
END;
GO
PRINT N'Creating [tSQLt].[Private_SqlVariantFormatter]'
GO
CREATE FUNCTION [tSQLt].[Private_SqlVariantFormatter](@Value SQL_VARIANT)
RETURNS NVARCHAR(MAX)
AS
BEGIN
  RETURN CASE UPPER(CAST(SQL_VARIANT_PROPERTY(@Value,'BaseType')AS sysname))
           WHEN 'FLOAT' THEN CONVERT(NVARCHAR(MAX),@Value,2)
           WHEN 'REAL' THEN CONVERT(NVARCHAR(MAX),@Value,1)
           WHEN 'MONEY' THEN CONVERT(NVARCHAR(MAX),@Value,2)
           WHEN 'SMALLMONEY' THEN CONVERT(NVARCHAR(MAX),@Value,2)
           WHEN 'DATE' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'DATETIME' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'DATETIME2' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'DATETIMEOFFSET' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'SMALLDATETIME' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'TIME' THEN CONVERT(NVARCHAR(MAX),@Value,126)
           WHEN 'BINARY' THEN CONVERT(NVARCHAR(MAX),@Value,1)
           WHEN 'VARBINARY' THEN CONVERT(NVARCHAR(MAX),@Value,1)
           ELSE CAST(@Value AS NVARCHAR(MAX))
         END;
END
GO
PRINT N'Creating [dsptest].[AssertNotEquals]'
GO
CREATE   PROCEDURE [dsptest].[AssertNotEquals]
    @Expected SQL_VARIANT, @Actual SQL_VARIANT, @Message NVARCHAR(MAX) = ''
AS
BEGIN
    IF (@Expected = @Actual) OR (@Expected IS NULL AND  @Actual IS NULL)
    BEGIN
        DECLARE @Msg NVARCHAR(MAX);
        SET @Msg = N'Expected actual value to not ' + COALESCE('equal <' + tSQLt.Private_SqlVariantFormatter(@Expected) + '>', 'be NULL') + N'.';
        EXEC dsptest.ThrowFail @ProcId = @@PROCID, @Message = @Message, @Param0 = @Msg;
    END;
    RETURN 0;
END;
GO
PRINT N'Creating [dsp].[Formatter_FormatMobileNumber]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatMobileNumber] (@MobileNumber TSTRING)
RETURNS TSTRING
BEGIN
	SET @MobileNumber = REPLACE(@MobileNumber, ' ', '');
	SET @MobileNumber = REPLACE(@MobileNumber, '-', '');
	SET @MobileNumber = REPLACE(@MobileNumber, '.', '');

	-- 9124445566
	IF (LEN(@MobileNumber) = 10)
		SET @MobileNumber = '+98' + @MobileNumber;

	-- 09124445566
	IF (LEN(@MobileNumber) = 11 AND SUBSTRING(@MobileNumber, 1, 1) = '0')
		SET @MobileNumber = '+98' + SUBSTRING(@MobileNumber, 2, 10);

	-- 989124445566
	IF (LEN(@MobileNumber) > 10 AND SUBSTRING(@MobileNumber, 1, 1) <> '+')
		SET @MobileNumber = '+' + @MobileNumber;

	-- Remove plus
	SET @MobileNumber = SUBSTRING(@MobileNumber, 2, LEN(@MobileNumber) - 1);

	-- checking length >=11 amd <=13
	IF (LEN(@MobileNumber) NOT BETWEEN 11 AND 13)
		RETURN NULL;

	IF (@MobileNumber LIKE '%[^0-9]%')
		SET @MobileNumber = NULL;

	RETURN @MobileNumber;
END;




GO
PRINT N'Creating [dsp].[ThrowFatalError]'
GO

CREATE PROCEDURE [dsp].[ThrowFatalError] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dsperr.FatalErrorId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [DatabaseVersioning].[Databaseversioning_DisableTemporal]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Databaseversioning_DisableTemporal]
    @SchemaName TSTRING, @TableName TSTRING
AS
BEGIN
    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- Validate SchemaName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'SchemaName', @ArgumentValue = @SchemaName,
    @Message = 'SchemaName could not be allow null';

    -- Validate TemporalType
    IF NOT EXISTS (   SELECT    *
                        FROM    dsp.SystemTable
                       WHERE SchemaName = @SchemaName AND   TableName = @TableName AND  TemporalTypeId = dspconst.TemporalType_Temporal())
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'TemporalType is not Temporal';

    -- Disable Temporal
    EXEC dsp.Table_DisableTemporalAttribute @SchemaName = @SchemaName, @TableName = @TableName;
END;




GO
PRINT N'Creating [dsp].[Formatter_FormatNationalNumber]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatNationalNumber] (@NationalNumber TSTRING)
RETURNS TSTRING
AS
BEGIN
	SET @NationalNumber = REPLACE(dsp.Formatter_FormatString(@NationalNumber), '-', '');
	RETURN IIF(ISNUMERIC(@NationalNumber) = 1 AND LEN(@NationalNumber) = 10, @NationalNumber, NULL);
END;

GO
PRINT N'Creating [tSQLt].[AssertObjectExists]'
GO
CREATE PROCEDURE [tSQLt].[AssertObjectExists]
    @ObjectName NVARCHAR(MAX),
    @Message NVARCHAR(MAX) = ''
AS
BEGIN
    DECLARE @Msg NVARCHAR(MAX);
    IF(@ObjectName LIKE '#%')
    BEGIN
     IF OBJECT_ID('tempdb..'+@ObjectName) IS NULL
     BEGIN
         SELECT @Msg = '''' + COALESCE(@ObjectName, 'NULL') + ''' does not exist';
         EXEC tSQLt.Fail @Message, @Msg;
         RETURN 1;
     END;
    END
    ELSE
    BEGIN
     IF OBJECT_ID(@ObjectName) IS NULL
     BEGIN
         SELECT @Msg = '''' + COALESCE(@ObjectName, 'NULL') + ''' does not exist';
         EXEC tSQLt.Fail @Message, @Msg;
         RETURN 1;
     END;
    END;
    RETURN 0;
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_NameByApiKey]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_NameByApiKey] (@SchemaName TSTRING,
    @ApiKey TSTRING)
RETURNS @StoredProcedure_NameByApiKey TABLE (StoredProcedureName TSTRING)
AS
BEGIN
    DECLARE @StoredProcedureName TSTRING;

    -- Find stored procedure by api key and schema
    SELECT TOP 1    @StoredProcedureName = StoredProcedureName
      FROM  dsp.StoredProcedure_List(@SchemaName)
     WHERE  StoredProcedureKey = @ApiKey; --

    INSERT INTO @StoredProcedure_NameByApiKey (StoredProcedureName)
    VALUES (@StoredProcedureName);

    RETURN;
END;




GO
PRINT N'Creating [dsp].[StoredProcedure_CreateTempCopy]'
GO
CREATE PROCEDURE [dsp].[StoredProcedure_CreateTempCopy]
    @SchemaName TSTRING, @StoredProcedureName TSTRING
AS
BEGIN

    -- Get stored procedure API key and definiton code
    DECLARE @StoredProcedureDefinitionCode TBIGSTRING;
    DECLARE @ApiKey TJSON;
    SELECT --
        @ApiKey = SPM.StoredProcedureKey, --
        @StoredProcedureDefinitionCode = SPM.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
     WHERE  SPM.StoredProcedureName = @StoredProcedureName;

    -- Should not be exists another temp with the current API key
    IF EXISTS (   SELECT    *
                    FROM    dsp.StoredProcedure_NameByApiKey('temp', @ApiKey)
                   WHERE StoredProcedureName IS NOT NULL) --
        EXEC dsp.ThrowFatalError @ProcId = @@PROCID, @Message = 'Another API already exists with new procedure''s APIkey, ApiKey ={0}', @Param0 = @ApiKey;

    IF (@StoredProcedureDefinitionCode IS NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Could not find stored procedure';

    -- Create stored procedure temp copy
    DECLARE @TempName TSTRING = 'temp.' + @StoredProcedureName;
    DECLARE @CreatedStoredProcedureName TSTRING = @SchemaName + '.' + @StoredProcedureName;
    DECLARE @CreatedStoredProcedureNameWithBracker TSTRING = CONCAT(QUOTENAME(@SchemaName), '.', QUOTENAME(@StoredProcedureName));
    SET @StoredProcedureDefinitionCode = REPLACE(@StoredProcedureDefinitionCode, @CreatedStoredProcedureName, @TempName);
    SET @StoredProcedureDefinitionCode = REPLACE(@StoredProcedureDefinitionCode, @CreatedStoredProcedureNameWithBracker, @TempName);
    EXEC sys.sp_executesql @StoredProcedureDefinitionCode;
END;



















GO
PRINT N'Creating [dsp].[Formatter_FormatNumeric]'
GO


CREATE FUNCTION [dsp].[Formatter_FormatNumeric] (@NumberStr TSTRING)
RETURNS TSTRING
AS
BEGIN
	RETURN REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(@NumberStr, '*', ''), '-', ''), '_', ''), '/', ''), ' ', ''), '#', '');
END;


GO
PRINT N'Creating [tSQLt].[AssertEmptyTable]'
GO
CREATE PROCEDURE [tSQLt].[AssertEmptyTable]
  @TableName NVARCHAR(MAX),
  @Message NVARCHAR(MAX) = ''
AS
BEGIN
  EXEC tSQLt.AssertObjectExists @TableName;

  DECLARE @FullName NVARCHAR(MAX);
  IF(OBJECT_ID(@TableName) IS NULL AND OBJECT_ID('tempdb..'+@TableName) IS NOT NULL)
  BEGIN
    SET @FullName = CASE WHEN LEFT(@TableName,1) = '[' THEN @TableName ELSE QUOTENAME(@TableName)END;
  END;
  ELSE
  BEGIN
    SET @FullName = tSQLt.Private_GetQuotedFullName(OBJECT_ID(@TableName));
  END;

  DECLARE @cmd NVARCHAR(MAX);
  DECLARE @exists INT;
  SET @cmd = 'SELECT @exists = CASE WHEN EXISTS(SELECT 1 FROM '+@FullName+') THEN 1 ELSE 0 END;'
  EXEC sp_executesql @cmd,N'@exists INT OUTPUT', @exists OUTPUT;
  
  IF(@exists = 1)
  BEGIN
    DECLARE @TableToText NVARCHAR(MAX);
    EXEC tSQLt.TableToText @TableName = @FullName,@txt = @TableToText OUTPUT;
    DECLARE @Msg NVARCHAR(MAX);
    SET @Msg = @FullName + ' was not empty:' + CHAR(13) + CHAR(10)+ @TableToText;
    EXEC tSQLt.Fail @Message,@Msg;
  END
END
GO
PRINT N'Creating [err].[AccessDeniedOrObjectNotExistsId]'
GO

CREATE FUNCTION [err].[AccessDeniedOrObjectNotExistsId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55002;  
END
GO
PRINT N'Creating [err].[ThrowAccessDeniedOrObjectNotExists]'
GO

CREATE PROCEDURE [err].[ThrowAccessDeniedOrObjectNotExists] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.AccessDeniedOrObjectNotExistsId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[StoredProcedure_MakeOldVersion]'
GO
CREATE PROCEDURE [dsp].[StoredProcedure_MakeOldVersion]
    @TargetStoredProcedureName TSTRING
AS
BEGIN

    -- Get the last version number
    DECLARE @LastVersionNumber TSTRING = dsp.StoreProcedure_MaxVersionNumber();

    -- Get the temp stored procedure defintion code
    DECLARE @ProcedureDefinitionCode TBIGSTRING;
    SELECT  @ProcedureDefinitionCode = DSP.StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List('temp') AS DSP
     WHERE  DSP.StoredProcedureName = @TargetStoredProcedureName;

    -- Get the StoredProcedureVersionNumberPrefix  from settings
    DECLARE @StoredProcedureVersionNumberPrefix TSTRING;
    EXEC dsp.Setting_GetProps @StoredProcedureVersionNumberPrefix = @StoredProcedureVersionNumberPrefix OUTPUT;

    -- Replace the temp schema name with the api schema name
    DECLARE @StoredProcedureName TSTRING = @TargetStoredProcedureName + @StoredProcedureVersionNumberPrefix + @LastVersionNumber;
    SET @ProcedureDefinitionCode =
        REPLACE(@ProcedureDefinitionCode, 'CREATE PROCEDURE temp.' + @TargetStoredProcedureName, 'CREATE PROCEDURE api.' + @StoredProcedureName);
    EXEC sys.sp_executesql @ProcedureDefinitionCode;


END;











GO
PRINT N'Creating [DatabaseVersioning].[DatabaseVersioning_EnableTemporal]'
GO

CREATE PROCEDURE [DatabaseVersioning].[DatabaseVersioning_EnableTemporal]
    @SchemaName TSTRING, @TableName TSTRING
AS
BEGIN
    -- Validate TableName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'TableName', @ArgumentValue = @TableName, @Message = 'TableName could not be allow null';

    -- Validate SchemaName
    EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'SchemaName', @ArgumentValue = @SchemaName,
    @Message = 'SchemaName could not be allow null';

    -- Validate for existstance "Temporal" in extended property
    DECLARE @TemporalTypeValue INT = dspconst.TemporalType_Temporal();
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dsp.SystemTable
                       WHERE SchemaName = @SchemaName AND   TableName = @TableName AND  TemporalTypeId = /*dspconst.TemporalType_Temporal()*/ 2)
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'TemporalType is not Temporal';

    -- Enable Temporal
    EXEC dsp.Table_EnableTemporalAttribute @SchemaName = @SchemaName, @TableName = @TableName;
END;









GO
PRINT N'Creating [dsp].[Formatter_FormatPostalCode]'
GO
CREATE	FUNCTION [dsp].[Formatter_FormatPostalCode] (@PostalCode TSTRING)
RETURNS TSTRING
AS
BEGIN
	SET @PostalCode = dsp.Formatter_FormatString(@PostalCode);
	RETURN IIF(ISNUMERIC(@PostalCode) = 1 AND LEN(@PostalCode) = 10, @PostalCode, NULL);
END;

GO
PRINT N'Creating [tSQLt].[AssertEqualsString]'
GO
CREATE PROCEDURE [tSQLt].[AssertEqualsString]
    @Expected NVARCHAR(MAX),
    @Actual NVARCHAR(MAX),
    @Message NVARCHAR(MAX) = ''
AS
BEGIN
    IF ((@Expected = @Actual) OR (@Actual IS NULL AND @Expected IS NULL))
      RETURN 0;

    DECLARE @Msg NVARCHAR(MAX);
    SELECT @Msg = CHAR(13)+CHAR(10)+
                  'Expected: ' + ISNULL('<'+@Expected+'>', 'NULL') +
                  CHAR(13)+CHAR(10)+
                  'but was : ' + ISNULL('<'+@Actual+'>', 'NULL');
    EXEC tSQLt.Fail @Message, @Msg;
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_SetCreatedTime]'
GO
CREATE PROCEDURE [dsp].[StoredProcedure_SetCreatedTime]
    @SchemaName TSTRING, @StoredProcedureName TSTRING
AS
BEGIN
    -- Get the stored procedure metadata
    DECLARE @StoredProcedureMetadata TJSON;
    SELECT  @StoredProcedureMetadata = SPM.StoredProcedureMetadata
      FROM  dsp.StoredProcedure_List(@SchemaName) AS SPM
     WHERE  SPM.StoredProcedureName = @StoredProcedureName;

    -- Check if storedProcedure has created time 
    IF (JSON_VALUE(@StoredProcedureMetadata, '$.CreatedTime') IS NOT NULL) --
        RETURN;

    DECLARE @CreatedTime TSTRING = CONVERT(NVARCHAR, GETDATE(), 120);
    -- Append HasNewVersion attribute
    DECLARE @NewMetadata TJSON = JSON_MODIFY(@StoredProcedureMetadata, '$.CreatedTime', @CreatedTime);
    SET @NewMetadata =
        REPLACE(
            @NewMetadata, CHAR(/*No Codequality Error*/ 13) + CHAR(/*No Codequality Error*/ 10) + ',"CreatedTime":"' + @CreatedTime + '"',
            dsp.String_ReplaceEnter(',\n	"CreatedTime":"' + @CreatedTime + '"\n'));

    -- Alter the stored procedure
    DECLARE @StoreProcedureDefinitionCode TBIGSTRING;
    SELECT  @StoreProcedureDefinitionCode = StoredProcedureDefinitionCode
      FROM  dsp.StoredProcedure_List(@SchemaName)
     WHERE  StoredProcedureName = @StoredProcedureName;

    SET @StoreProcedureDefinitionCode = REPLACE(@StoreProcedureDefinitionCode, @StoredProcedureMetadata, @NewMetadata);
    SET @StoreProcedureDefinitionCode = REPLACE(@StoreProcedureDefinitionCode, 'CREATE PROCEDURE', 'ALTER PROCEDURE');

    EXEC sys.sp_executesql @StoreProcedureDefinitionCode;
END;





















GO
PRINT N'Creating [dsp].[Formatter_RedactCardNumber]'
GO
CREATE FUNCTION [dsp].[Formatter_RedactCardNumber] (@CardNumber NVARCHAR(/*NoCodeQuality*/4000))
RETURNS NVARCHAR(/*NoCodeQuality*/4000)
WITH SCHEMABINDING
AS
BEGIN
    SET @CardNumber = dsp.Formatter_FormatString(@CardNumber);
    RETURN LEFT(@CardNumber, 6) + REPLICATE('x', LEN(@CardNumber) - 6 - 4) + RIGHT(@CardNumber, 4);
END;





GO
PRINT N'Creating [tSQLt].[Private_CompareTablesFailIfUnequalRowsExists]'
GO
CREATE PROCEDURE [tSQLt].[Private_CompareTablesFailIfUnequalRowsExists]
 @UnequalRowsExist INT,
 @ResultTable NVARCHAR(MAX),
 @ResultColumn NVARCHAR(MAX),
 @ColumnList NVARCHAR(MAX),
 @FailMsg NVARCHAR(MAX)
AS
BEGIN
  IF @UnequalRowsExist > 0
  BEGIN
   DECLARE @TableToTextResult NVARCHAR(MAX);
   DECLARE @OutputColumnList NVARCHAR(MAX);
   SELECT @OutputColumnList = '[_m_],' + @ColumnList;
   EXEC tSQLt.TableToText @TableName = @ResultTable, @OrderBy = @ResultColumn, @PrintOnlyColumnNameAliasList = @OutputColumnList, @txt = @TableToTextResult OUTPUT;
   
   DECLARE @Message NVARCHAR(MAX);
   SELECT @Message = @FailMsg + CHAR(13) + CHAR(10);

    EXEC tSQLt.Fail @Message, @TableToTextResult;
  END;
END
GO
PRINT N'Creating [err].[AmbiguousExceptionId]'
GO

CREATE FUNCTION [err].[AmbiguousExceptionId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55020;  
END
GO
PRINT N'Creating [err].[ThrowAmbiguousException]'
GO

CREATE PROCEDURE [err].[ThrowAmbiguousException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.AmbiguousExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[StoredProcedure_Signature]'
GO
CREATE PROCEDURE [dsp].[StoredProcedure_Signature]
    @SchemaName TSTRING, @StoredProcedureName AS TSTRING, @Json TJSON = NULL OUTPUT
AS
BEGIN

    DECLARE @ObjectId INT;

    SELECT  @ObjectId = P.object_id
      FROM  sys.procedures AS P
     WHERE  P.name = @StoredProcedureName --
        AND P.schema_id = SCHEMA_ID(@SchemaName);

    DECLARE @Params TABLE (ParamName TSTRING,
        IsOutput BIT,
        TypeName TSTRING,
        Length INT,
        object_id INT);

    INSERT INTO @Params (ParamName, IsOutput, TypeName, Length, object_id)
    SELECT  Params.name AS ParamName, Params.is_output, TYPE_NAME(Type.system_type_id) AS TypeName, Params.max_length AS Length, Params.object_id
      FROM  sys.parameters AS Params
            INNER JOIN sys.types AS Type ON Type.user_type_id = Params.user_type_id
     WHERE  Params.object_id = @ObjectId;

    -- Check if params table is empty
    IF NOT EXISTS (SELECT   TOP 1 1 FROM    @Params AS P)
    BEGIN
        SET @Json = (   SELECT  @StoredProcedureName AS StoredProcedureName
                        FOR JSON PATH, WITHOUT_ARRAY_WRAPPER);
        RETURN;
    END;

    SET @Json = (   SELECT  SP.name StoredProcedureName, Params.ParamName, Params.TypeName, Params.Length, Params.IsOutput
                      FROM  @Params AS Params
                            INNER JOIN sys.procedures AS SP ON SP.object_id = Params.object_id
                    FOR JSON AUTO, WITHOUT_ARRAY_WRAPPER, INCLUDE_NULL_VALUES);

END;






GO
PRINT N'Creating [dsp].[Formatter_RedactMobileNumber]'
GO
CREATE	FUNCTION [dsp].[Formatter_RedactMobileNumber] (@MobileNumber TSTRING)
RETURNS TSTRING
BEGIN
	SET @MobileNumber = dsp.Formatter_FormatMobileNumber(@MobileNumber);
	IF (@MobileNumber IS NOT NULL)
		RETURN '*********' + SUBSTRING(@MobileNumber, LEN(@MobileNumber) - 1, 2);

	RETURN NULL;
END;



GO
PRINT N'Creating [dsp].[Synonym_Create]'
GO
CREATE PROCEDURE [dsp].[Synonym_Create]
	@SchemaName TSTRING, @SynonymName TSTRING, @ObjectName TSTRING
AS
BEGIN
	DECLARE @sql TSTRING;

	-- drop if already exists
	SET @sql = 'DROP SYNONYM IF EXISTS ' + @SchemaName + '.' + @SynonymName;
	EXEC (@sql);

	-- create synonym
	SET @sql = 'CREATE SYNONYM ' + @SchemaName + '.' + @SynonymName + ' FOR ' + @ObjectName;
	EXEC (@sql);
END;







GO
PRINT N'Creating [dsp].[Formatter_RemoveLikeInjection]'
GO
CREATE	FUNCTION [dsp].[Formatter_RemoveLikeInjection] (@Value TSTRING)
RETURNS TSTRING
AS
BEGIN
	SET @Value = dsp.Formatter_FormatString(@Value);
	SET @Value = REPLACE(@Value, '%', '');
	SET @Value = REPLACE(@Value, '[', '');
	SET @Value = REPLACE(@Value, '_', '[_]');

	RETURN @Value;
END;



GO
PRINT N'Creating [err].[BatchIsNotAllowedId]'
GO

CREATE FUNCTION [err].[BatchIsNotAllowedId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55023;  
END
GO
PRINT N'Creating [err].[ThrowBatchIsNotAllowed]'
GO

CREATE PROCEDURE [err].[ThrowBatchIsNotAllowed] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.BatchIsNotAllowedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Table_$CreateTemporalStage]'
GO
CREATE PROCEDURE [dsp].[Table_$CreateTemporalStage]
    @SchemaName TSTRING, @TableName TSTRING, @Postfix TSTRING
AS
BEGIN
    DECLARE @table_name sysname;
    SELECT  @table_name = @SchemaName + '.' + @TableName;

    DECLARE @object_name sysname, @object_id INT;

    SELECT  @object_name = '' + s.name + '.' + o.name + '', @object_id = o.object_id
      FROM  sys.objects o WITH (NOWAIT)
            JOIN sys.schemas s WITH (NOWAIT) ON o.schema_id = s.schema_id
     WHERE  s.name + '.' + o.name = @table_name AND o.type = 'U' AND o.is_ms_shipped = 0;

    DECLARE @SQL NVARCHAR(MAX) = N'';
    WITH index_column
        AS (SELECT  ic.object_id, ic.index_id, ic.is_descending_key, ic.is_included_column, c.name
              FROM  sys.index_columns ic WITH (NOWAIT)
                    JOIN sys.columns c WITH (NOWAIT) ON ic.object_id = c.object_id AND  ic.column_id = c.column_id
             WHERE  ic.object_id = @object_id), fk_columns
        AS (SELECT  k.constraint_object_id, cname = c.name, rcname = rc.name
              FROM  sys.foreign_key_columns k WITH (NOWAIT)
                    JOIN sys.columns rc WITH (NOWAIT) ON rc.object_id = k.referenced_object_id AND  rc.column_id = k.referenced_column_id
                    JOIN sys.columns c WITH (NOWAIT) ON c.object_id = k.parent_object_id AND c.column_id = k.parent_column_id
             WHERE  k.parent_object_id = @object_id)
    SELECT  @SQL =
        N'CREATE TABLE ' + @object_name + @Postfix + CHAR(13) + N'(' + CHAR(13)
        + STUFF(
            (   SELECT      CHAR(9) + ', [' + c.name + '] '
                            + CASE
                                  WHEN c.is_computed = 1
                                      THEN 'AS ' + cc.definition ELSE
                                                                     UPPER(tp.name)
                                                                     + CASE
                                                                           WHEN tp.name IN ( 'varchar', 'char', 'varbinary', 'binary', 'text' )
                                                                               THEN '(' + CASE
                                                                                              WHEN c.max_length = -1
                                                                                                  THEN 'MAX' ELSE CAST(c.max_length AS VARCHAR(5))
                                                                                          END + ')'
                                                                           WHEN tp.name IN ( 'nvarchar', 'nchar', 'ntext' )
                                                                               THEN '(' + CASE
                                                                                              WHEN c.max_length = -1
                                                                                                  THEN 'MAX' ELSE CAST(c.max_length / 2 AS VARCHAR(5))
                                                                                          END + ')'
                                                                           WHEN tp.name IN ( 'datetime2', 'time2', 'datetimeoffset' )
                                                                               THEN '(' + CAST(c.scale AS VARCHAR(5)) + ')'
                                                                           WHEN tp.name = 'decimal'
                                                                               THEN '(' + CAST(c.precision AS VARCHAR(5)) + ',' + CAST(c.scale AS VARCHAR(5))
                                                                                    + ')' ELSE ''
                                                                       END + CASE
                                                                                 WHEN c.collation_name IS NOT NULL
                                                                                     THEN ' COLLATE ' + c.collation_name ELSE ''
                                                                             END + CASE
                                                                                       WHEN c.is_nullable = 1
                                                                                           THEN ' NULL' ELSE ' NOT NULL'
                                                                                   END + CASE
                                                                                             WHEN dc.definition IS NOT NULL
                                                                                                 THEN ' DEFAULT' + dc.definition ELSE ''
                                                                                         END
                                                                     + CASE
                                                                           WHEN ic.is_identity = 1
                                                                               THEN ' IDENTITY(' + CAST(ISNULL(ic.seed_value, '0') AS CHAR(1)) + ','
                                                                                    + CAST(ISNULL(ic.increment_value, '1') AS CHAR(1)) + ')' ELSE ''
                                                                       END
                              END + CHAR(13)
                  FROM      sys.columns c WITH (NOWAIT)
                            JOIN sys.types tp WITH (NOWAIT) ON c.user_type_id = tp.user_type_id
                            LEFT JOIN sys.computed_columns cc WITH (NOWAIT) ON c.object_id = cc.object_id AND   c.column_id = cc.column_id
                            LEFT JOIN sys.default_constraints dc WITH (NOWAIT) ON c.default_object_id != 0 AND  c.object_id = dc.parent_object_id AND
                                                                                  c.column_id = dc.parent_column_id
                            LEFT JOIN sys.identity_columns ic WITH (NOWAIT) ON c.is_identity = 1 AND c.object_id = ic.object_id AND c.column_id = ic.column_id
                 WHERE   c.object_id = @object_id
                 ORDER BY c.column_id
                FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, CHAR(9) + ' ')
        + ISNULL(
          (   SELECT    CHAR(9) + ', CONSTRAINT [' + k.name + @Postfix + '] PRIMARY KEY ('
                        + (SELECT   STUFF((   SELECT    ', [' + c.name + '] ' + CASE
                                                                                    WHEN ic.is_descending_key = 1
                                                                                        THEN 'DESC' ELSE 'ASC'
                                                                                END
                                                FROM    sys.index_columns ic WITH (NOWAIT)
                                                        JOIN sys.columns c WITH (NOWAIT) ON c.object_id = ic.object_id AND c.column_id = ic.column_id
                                               WHERE ic.is_included_column = 0 AND  ic.object_id = k.parent_object_id AND   ic.index_id = k.unique_index_id
                                              FOR XML PATH(N''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '')) + ')' + CHAR(13)
                FROM    sys.key_constraints k WITH (NOWAIT)
               WHERE k.parent_object_id = @object_id AND k.type = 'PK'), '') + N')' + CHAR(13)
        + ISNULL(
          (SELECT   (   SELECT  CHAR(13) + 'ALTER TABLE ' + @object_name + @Postfix + ' WITH' + CASE
                                                                                                    WHEN fk.is_not_trusted = 1
                                                                                                        THEN ' NOCHECK' ELSE ' CHECK'
                                                                                                -------------------------------------------
                                                                                                END + ' ADD CONSTRAINT [' + fk.name + @Postfix + '] FOREIGN KEY('
                                + STUFF((   SELECT  ', [' + k.cname + ']'
                                              FROM  fk_columns k
                                             WHERE k.constraint_object_id = fk.object_id
                                            FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '') + ')' + ' REFERENCES [' + SCHEMA_NAME(ro.schema_id)
                                + '].[' + ro.name + '] (' + STUFF((   SELECT    ', [' + k.rcname + ']'
                                                                        FROM    fk_columns k
                                                                       WHERE   k.constraint_object_id = fk.object_id
                                                                      FOR XML PATH(''), TYPE).value('.', 'NVARCHAR(MAX)'), 1, 2, '') + ')'
                                + CASE
                                      WHEN fk.delete_referential_action = 1
                                          THEN ' ON DELETE CASCADE'
                                      WHEN fk.delete_referential_action = 2
                                          THEN ' ON DELETE SET NULL'
                                      WHEN fk.delete_referential_action = 3
                                          THEN ' ON DELETE SET DEFAULT' ELSE ''
                                  END + CASE
                                            WHEN fk.update_referential_action = 1
                                                THEN ' ON UPDATE CASCADE'
                                            WHEN fk.update_referential_action = 2
                                                THEN ' ON UPDATE SET NULL'
                                            WHEN fk.update_referential_action = 3
                                                THEN ' ON UPDATE SET DEFAULT' ELSE ''
                                        ----------------------------------------------------------------------------------------------------------
                                        END + CHAR(13) + 'ALTER TABLE ' + @object_name + @Postfix + ' CHECK CONSTRAINT [' + fk.name + @Postfix + ']' + CHAR(13)
                          FROM  sys.foreign_keys fk WITH (NOWAIT)
                                JOIN sys.objects ro WITH (NOWAIT) ON ro.object_id = fk.referenced_object_id
                         WHERE  fk.parent_object_id = @object_id
                        FOR XML PATH(N''), TYPE).value('.', 'NVARCHAR(MAX)')), '');
    EXEC sys.sp_executesql @SQL;
END;





GO
PRINT N'Creating [dsp].[Table_GetMaxPrimaryKeyValue]'
GO
CREATE PROCEDURE [dsp].[Table_GetMaxPrimaryKeyValue] (
    @SchemaName TSTRING, @TableName TSTRING, @MaxPrimaryColumnValue BIGINT = NULL OUTPUT)
AS
BEGIN
    -- Validate PrimaryColumn
    DECLARE @PrimaryKeyColumnName TSTRING = dsp.Table_GetPrimaryKey(@SchemaName, @TableName);
    IF (@PrimaryKeyColumnName IS NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table does not have primary column';

    DECLARE @ResultMaxValue TSTRING;
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;
    SET @Query =
        CONCAT(
            'SET @MaxPrimaryKey = (SELECT MAX(', @PrimaryKeyColumnName, ') as ', @PrimaryKeyColumnName, ' FROM ', @SchemaName, '.' + @TableName,
            ' FOR JSON AUTO)');
    SET @Params = '@MaxPrimaryKey NVARCHAR(MAX) OUTPUT';
    EXEC sys.sp_executesql @Query, @Params, @MaxPrimaryKey = @ResultMaxValue OUTPUT;

    DECLARE @Path TJSON = REPLACE('$[0].@Id', '@Id', @PrimaryKeyColumnName);
    SET @MaxPrimaryColumnValue = JSON_VALUE(@ResultMaxValue, @Path);
END;




GO
PRINT N'Creating [err].[DuplicateRequestExceptionId]'
GO

CREATE FUNCTION [err].[DuplicateRequestExceptionId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55030;  
END
GO
PRINT N'Creating [err].[ThrowDuplicateRequestException]'
GO

CREATE PROCEDURE [err].[ThrowDuplicateRequestException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.DuplicateRequestExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Table_InitTemporal]'
GO


CREATE PROCEDURE [dsp].[Table_InitTemporal]
	@Schema TSTRING = 'dbo', @TableName TSTRING, @Enable BIT = 1
AS
BEGIN
	DECLARE @Msg TSTRING = ERROR_MESSAGE();

	-- Check SystemVersion is On over the table
	DECLARE @temporal_type INT = (SELECT temporal_type FROM sys.tables WHERE name = @TableName);

	DECLARE @TableNameHistory TSTRING = @TableName + 'History';

	-- Enable System Versioning
	IF (@Enable = 1)
	BEGIN
		-- do not enable if it was already on
		IF (@temporal_type != 0)
			RETURN;

		-- check if table is empty
		DECLARE @RowCount INT = 0;
		DECLARE @Query TSTRING = 'SELECT @Exists = COUNT(*) FROM ' + @Schema + '.' + @TableName + '';
		EXEC sys.sp_executesql @Query, N'@Exists int out', @RowCount OUT;
		IF (@RowCount > 1)
		BEGIN
			SET @Msg = 'To InitTemporal table please empty the table (' + @Schema + '.' + @TableName + ')';
			EXEC dsp.ThrowGeneralException @ProcId = @@PROCID, @Message = @Msg;
		END;

		-- Drop if exits
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP CONSTRAINT IF EXISTS DF_' + @TableName + 'SysStartTime;');
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP CONSTRAINT IF EXISTS DF_' + @TableName + 'SysEndTime;');
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP COLUMN IF EXISTS SysStartTime;');
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP COLUMN IF EXISTS SysEndTime;');

		-- Apply Temporal
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' ADD SysStartTime DATETIME2(7) GENERATED ALWAYS AS ROW START HIDDEN constraint DF_' + @TableName + 'SysStartTime DEFAULT SYSUTCDATETIME(), SysEndTime DATETIME2(7) GENERATED ALWAYS AS ROW END HIDDEN constraint DF_' + @TableName + 'SysEndTime DEFAULT ''9999.12.31 23:59:59.99'' , PERIOD FOR SYSTEM_TIME (SysStartTime, SysEndTime);');
		EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' SET (SYSTEM_VERSIONING = ON (HISTORY_TABLE = ' + @Schema + '.' + @TableNameHistory + ')) ');
	END;
	ELSE
	BEGIN
		-- Set SYSTEM_VERSIONING off if is on
		EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Trying to SET the SYSTEM_VERSIONING OFF. Table: {0}', @Param0 = @TableName;
		BEGIN TRY
			EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' SET (SYSTEM_VERSIONING = OFF)');
		END TRY
		BEGIN CATCH
			SET @Msg = ERROR_MESSAGE();
			EXEC dsp.Log_Error @ProcId = @@PROCID, @Message = @Msg;
		END CATCH;

		--  Drop PERIOD life time
		EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Dropping PERIOD FOR SYSTEM_TIME; Table: {0}', @Param0 = @TableName;
		BEGIN TRY
			EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP PERIOD FOR SYSTEM_TIME;');
		END TRY
		BEGIN CATCH
			SET @Msg = ERROR_MESSAGE();
			EXEC dsp.Log_Error @ProcId = @@PROCID, @Message = @Msg;
		END CATCH;

	-- Drop TableHistory
	-- EXEC ('DROP TABLE ' + @Schema + '.' + @TableNameHistory);

	-- Drop SysStartTime constraint
	-- EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP CONSTRAINT DF_' + @TableName + 'SysStartTime;');

	-- Drop SysEndTime constraint
	-- EXEC('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP CONSTRAINT DF_'+ @TableName+ 'SysEndTime;');

	-- Drop columns SysStartTime in disbale mode
	-- EXEC ('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP COLUMN SysStartTime;');

	-- Drop columns SysEndTime
	-- EXEC('ALTER TABLE ' + @Schema + '.' + @TableName + ' DROP COLUMN SysEndTime;');
	END;


END;



GO
PRINT N'Creating [dsp].[Log_FormatMessage]'
GO
CREATE	FUNCTION [dsp].[Log_FormatMessage] (@ProcId INT,
	@Message TSTRING,
	@Elipsis BIT = 0,
	@Param0 TSTRING = '<notset>',
	@Param1 TSTRING = '<notset>',
	@Param2 TSTRING = '<notset>',
	@Param3 TSTRING = '<notset>')
RETURNS TSTRING
AS
BEGIN
	-- Validate Inputs
	SET @Elipsis = ISNULL(@Elipsis, 0);

	-- Format Message
	SET @Message = dsp.Formatter_FormatMessage(@Message, @Param0, @Param1, @Param2, @Param3);

	-- Put Elipsis
	IF (@Elipsis = 1)
	BEGIN
		DECLARE @LastString TSTRING = SUBSTRING(@Message, LEN(@Message), 1);
		IF (@LastString NOT LIKE '[.?!:>;]')
			SET @Message = @Message + ' ...';
	END;

	-- Set Schema and ProcName
	DECLARE @ProcName TSTRING = ISNULL(OBJECT_NAME(@ProcId), '(NoSP)');
	DECLARE @SchemaName TSTRING = OBJECT_SCHEMA_NAME(@ProcId);
	IF (@SchemaName IS NOT NULL)
		SET @ProcName = @SchemaName + '.' + @ProcName;

	-- Format message 
	DECLARE @msg TSTRING = @ProcName + '> ' + @Message;
	RETURN @msg;
END;


















GO
PRINT N'Creating [tSQLt].[Private_ValidateThatAllDataTypesInTableAreSupported]'
GO
CREATE PROCEDURE [tSQLt].[Private_ValidateThatAllDataTypesInTableAreSupported]
 @ResultTable NVARCHAR(MAX),
 @ColumnList NVARCHAR(MAX)
AS
BEGIN
    BEGIN TRY
      EXEC('DECLARE @EatResult INT; SELECT @EatResult = COUNT(1) FROM ' + @ResultTable + ' GROUP BY ' + @ColumnList + ';');
    END TRY
    BEGIN CATCH
      RAISERROR('The table contains a datatype that is not supported for tSQLt.AssertEqualsTable. Please refer to http://tsqlt.org/user-guide/assertions/assertequalstable/ for a list of unsupported datatypes.',16,10);
    END CATCH
END;
GO
PRINT N'Creating [tSQLt].[Private_GetCommaSeparatedColumnList]'
GO
CREATE FUNCTION [tSQLt].[Private_GetCommaSeparatedColumnList] (@Table NVARCHAR(MAX), @ExcludeColumn NVARCHAR(MAX))
RETURNS NVARCHAR(MAX)
AS 
BEGIN
  RETURN STUFF((
     SELECT ',' + CASE WHEN system_type_id = TYPE_ID('timestamp') THEN ';TIMESTAMP columns are unsupported!;' ELSE QUOTENAME(name) END 
       FROM sys.columns 
      WHERE object_id = OBJECT_ID(@Table) 
        AND name <> @ExcludeColumn 
      ORDER BY column_id
     FOR XML PATH(''), TYPE).value('.','NVARCHAR(MAX)')
    ,1, 1, '');
        
END;
GO
PRINT N'Creating [tSQLt].[Private_CreateResultTableForCompareTables]'
GO
CREATE PROCEDURE [tSQLt].[Private_CreateResultTableForCompareTables]
 @ResultTable NVARCHAR(MAX),
 @ResultColumn NVARCHAR(MAX),
 @BaseTable NVARCHAR(MAX)
AS
BEGIN
  DECLARE @Cmd NVARCHAR(MAX);
  SET @Cmd = '
     SELECT ''='' AS ' + @ResultColumn + ', Expected.* INTO ' + @ResultTable + ' 
       FROM tSQLt.Private_NullCellTable N 
       LEFT JOIN ' + @BaseTable + ' AS Expected ON N.I <> N.I 
     TRUNCATE TABLE ' + @ResultTable + ';' --Need to insert an actual row to prevent IDENTITY property from transfering (IDENTITY_COL can't be NULLable);
  EXEC(@Cmd);
END
GO
PRINT N'Creating [tSQLt].[Private_CompareTables]'
GO
CREATE PROCEDURE [tSQLt].[Private_CompareTables]
    @Expected NVARCHAR(MAX),
    @Actual NVARCHAR(MAX),
    @ResultTable NVARCHAR(MAX),
    @ColumnList NVARCHAR(MAX),
    @MatchIndicatorColumnName NVARCHAR(MAX)
AS
BEGIN
    DECLARE @cmd NVARCHAR(MAX);
    DECLARE @RestoredRowIndexCounterColName NVARCHAR(MAX);
    SET @RestoredRowIndexCounterColName = @MatchIndicatorColumnName + '_RR';
    
    SELECT @cmd = 
    '
    INSERT INTO ' + @ResultTable + ' (' + @MatchIndicatorColumnName + ', ' + @ColumnList + ') 
    SELECT 
      CASE 
        WHEN RestoredRowIndex.'+@RestoredRowIndexCounterColName+' <= CASE WHEN [_{Left}_]<[_{Right}_] THEN [_{Left}_] ELSE [_{Right}_] END
         THEN ''='' 
        WHEN RestoredRowIndex.'+@RestoredRowIndexCounterColName+' <= [_{Left}_] 
         THEN ''<'' 
        ELSE ''>'' 
      END AS ' + @MatchIndicatorColumnName + ', ' + @ColumnList + '
    FROM(
      SELECT SUM([_{Left}_]) AS [_{Left}_], 
             SUM([_{Right}_]) AS [_{Right}_], 
             ' + @ColumnList + ' 
      FROM (
        SELECT 1 AS [_{Left}_], 0[_{Right}_], ' + @ColumnList + '
          FROM ' + @Expected + '
        UNION ALL 
        SELECT 0[_{Left}_], 1 AS [_{Right}_], ' + @ColumnList + ' 
          FROM ' + @Actual + '
      ) AS X 
      GROUP BY ' + @ColumnList + ' 
    ) AS CollapsedRows
    CROSS APPLY (
       SELECT TOP(CASE WHEN [_{Left}_]>[_{Right}_] THEN [_{Left}_] 
                       ELSE [_{Right}_] END) 
              ROW_NUMBER() OVER(ORDER BY(SELECT 1)) 
         FROM (SELECT 1 
                 FROM ' + @Actual + ' UNION ALL SELECT 1 FROM ' + @Expected + ') X(X)
              ) AS RestoredRowIndex(' + @RestoredRowIndexCounterColName + ');';
    
    EXEC (@cmd); --MainGroupQuery
    
    SET @cmd = 'SET @r = 
         CASE WHEN EXISTS(
                  SELECT 1 
                    FROM ' + @ResultTable + 
                 ' WHERE ' + @MatchIndicatorColumnName + ' IN (''<'', ''>'')) 
              THEN 1 ELSE 0 
         END';
    DECLARE @UnequalRowsExist INT;
    EXEC sp_executesql @cmd, N'@r INT OUTPUT',@UnequalRowsExist OUTPUT;
    
    RETURN @UnequalRowsExist;
END;
GO
PRINT N'Creating [tSQLt].[AssertEqualsTable]'
GO
CREATE PROCEDURE [tSQLt].[AssertEqualsTable]
    @Expected NVARCHAR(MAX),
    @Actual NVARCHAR(MAX),
    @Message NVARCHAR(MAX) = NULL,
    @FailMsg NVARCHAR(MAX) = 'Unexpected/missing resultset rows!'
AS
BEGIN

    EXEC tSQLt.AssertObjectExists @Expected;
    EXEC tSQLt.AssertObjectExists @Actual;

    DECLARE @ResultTable NVARCHAR(MAX);    
    DECLARE @ResultColumn NVARCHAR(MAX);    
    DECLARE @ColumnList NVARCHAR(MAX);    
    DECLARE @UnequalRowsExist INT;
    DECLARE @CombinedMessage NVARCHAR(MAX);

    SELECT @ResultTable = tSQLt.Private::CreateUniqueObjectName();
    SELECT @ResultColumn = 'RC_' + @ResultTable;

    EXEC tSQLt.Private_CreateResultTableForCompareTables 
      @ResultTable = @ResultTable,
      @ResultColumn = @ResultColumn,
      @BaseTable = @Expected;
        
    SELECT @ColumnList = tSQLt.Private_GetCommaSeparatedColumnList(@ResultTable, @ResultColumn);

    EXEC tSQLt.Private_ValidateThatAllDataTypesInTableAreSupported @ResultTable, @ColumnList;    
    
    EXEC @UnequalRowsExist = tSQLt.Private_CompareTables 
      @Expected = @Expected,
      @Actual = @Actual,
      @ResultTable = @ResultTable,
      @ColumnList = @ColumnList,
      @MatchIndicatorColumnName = @ResultColumn;
        
    SET @CombinedMessage = ISNULL(@Message + CHAR(13) + CHAR(10),'') + @FailMsg;
    EXEC tSQLt.Private_CompareTablesFailIfUnequalRowsExists 
      @UnequalRowsExist = @UnequalRowsExist,
      @ResultTable = @ResultTable,
      @ResultColumn = @ResultColumn,
      @ColumnList = @ColumnList,
      @FailMsg = @CombinedMessage;   
END;
GO
PRINT N'Creating [dsp].[Table_LastVersioningEndTime]'
GO
CREATE   PROCEDURE [dsp].[Table_LastVersioningEndTime] (
    @SchemaName TSTRING, @TableName TSTRING, @LastVersioningTime DATETIME2 OUTPUT)
AS
BEGIN
    DECLARE @Query TSTRING;
    DECLARE @Params TSTRING;

    SET @Query = CONCAT('SET @Result = (SELECT  MAX(VersioningEndTime) FROM ', @SchemaName, '.', @TableName, 'History )');

    SET @Params = '@Result DATETIME2 OUTPUT';

    EXEC sys.sp_executesql @Query, @Params, @Result = @LastVersioningTime OUTPUT;

END;




GO
PRINT N'Creating [err].[Error1Id]'
GO

CREATE FUNCTION [err].[Error1Id]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 56001;  
END
GO
PRINT N'Creating [err].[ThrowError1]'
GO

CREATE PROCEDURE [err].[ThrowError1] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.Error1Id();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Table_UpdateToUseBlobForFields]'
GO
CREATE PROCEDURE [dsp].[Table_UpdateToUseBlobForFields]
AS
BEGIN
	DECLARE @TableName TSTRING;

	DECLARE Cursor_TableName CURSOR LOCAL FAST_FORWARD READ_ONLY FOR
	SELECT	T2.name
	FROM	sys.tables AS T2
			INNER JOIN sys.columns c ON c.object_id = T2.object_id
			INNER JOIN sys.types t ON c.user_type_id = t.user_type_id
			LEFT OUTER JOIN sys.index_columns ic ON ic.object_id = c.object_id AND	ic.column_id = c.column_id
			LEFT OUTER JOIN sys.indexes i ON ic.object_id = i.object_id AND ic.index_id = i.index_id
			INNER JOIN sys.schemas AS S ON S.schema_id = T2.schema_id
	WHERE	c.max_length = -1 AND	t.name = 'nvarchar' AND S.name = 'dbo'
	GROUP BY T2.name;
	OPEN Cursor_TableName;
	FETCH NEXT FROM Cursor_TableName
	INTO @TableName;

	WHILE (@@FETCH_STATUS = 0)
	BEGIN
		IF (@TableName IS NOT NULL) --
			EXEC sys.sp_tableoption @TableName, 'large value types out of row', 'ON';
		FETCH NEXT FROM Cursor_TableName
		INTO @TableName;
	END;
	CLOSE Cursor_TableName;
	DEALLOCATE Cursor_TableName;
END;


GO
PRINT N'Creating [DatabaseVersioning].[Setting_SetProps]'
GO
CREATE PROCEDURE [DatabaseVersioning].[Setting_SetProps]
    @MirroringIsEnabled INT = -1
AS
BEGIN
IF dsp.Param_IsSetOrNotNull(@MirroringIsEnabled) = 1
    UPDATE  DatabaseVersioning.Setting
       SET  MirroringIsEnabled = @MirroringIsEnabled
     WHERE  Id = 1;
END;
GO
PRINT N'Creating [dsp].[Table_ValidateExtendedPropertyValueByKey]'
GO
CREATE PROCEDURE [dsp].[Table_ValidateExtendedPropertyValueByKey]
    @SchemaName TSTRING, @TableName TSTRING, @ExtendedPropertyName TSTRING
AS
BEGIN
    IF NOT EXISTS (   SELECT TOP 1  1
                        FROM    dsp.Table_GetExtendedPropertyValueByKey(@SchemaName, @TableName, @ExtendedPropertyName) )
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table does not have extended property with name {0}', @Param0 = @ExtendedPropertyName;
END;
GO
PRINT N'Creating [DatabaseVersioning].[SystemTable_SetLevelPriority]'
GO

CREATE PROCEDURE [DatabaseVersioning].[SystemTable_SetLevelPriority]
    @SchemaName TSTRING, @TableName TSTRING, @PriorityLevelValue INT = 1
AS
BEGIN
    MERGE dsp.SystemTable AS target
    USING (SELECT   @SchemaName SchemaName, @TableName TableName, @PriorityLevelValue LevelPriority) AS source (SchemaName, TableName, LevelPriority)
       ON (target.SchemaName = source.SchemaName AND target.TableName = source.TableName)
     WHEN MATCHED
        THEN UPDATE SET target.LevelPriority = source.LevelPriority
     WHEN NOT MATCHED
        THEN INSERT (SystemTableId, SchemaName, TableName, LevelPriority)
             VALUES (OBJECT_ID(source.SchemaName + '.' + source.TableName), source.SchemaName, source.TableName, source.LevelPriority);
END;
GO
PRINT N'Creating [tSQLt].[Private_AssertEqualsTableSchema_Expected]'
GO
CREATE TABLE [tSQLt].[Private_AssertEqualsTableSchema_Expected]
(
[name] [nvarchar] (256) NULL,
[RANK(column_id)] [int] NULL,
[system_type_id] [nvarchar] (max) NULL,
[user_type_id] [nvarchar] (max) NULL,
[max_length] [smallint] NULL,
[precision] [tinyint] NULL,
[scale] [tinyint] NULL,
[collation_name] [nvarchar] (256) NULL,
[is_nullable] [bit] NULL,
[is_identity] [bit] NULL
)
GO
PRINT N'Creating [tSQLt].[Private_AssertEqualsTableSchema_Actual]'
GO
CREATE TABLE [tSQLt].[Private_AssertEqualsTableSchema_Actual]
(
[name] [nvarchar] (256) NULL,
[RANK(column_id)] [int] NULL,
[system_type_id] [nvarchar] (max) NULL,
[user_type_id] [nvarchar] (max) NULL,
[max_length] [smallint] NULL,
[precision] [tinyint] NULL,
[scale] [tinyint] NULL,
[collation_name] [nvarchar] (256) NULL,
[is_nullable] [bit] NULL,
[is_identity] [bit] NULL
)
GO
PRINT N'Creating [tSQLt].[AssertEqualsTableSchema]'
GO
CREATE PROCEDURE [tSQLt].[AssertEqualsTableSchema]
    @Expected NVARCHAR(MAX),
    @Actual NVARCHAR(MAX),
    @Message NVARCHAR(MAX) = NULL
AS
BEGIN
  INSERT INTO tSQLt.Private_AssertEqualsTableSchema_Expected([RANK(column_id)],name,system_type_id,user_type_id,max_length,precision,scale,collation_name,is_nullable)
  SELECT 
      RANK()OVER(ORDER BY C.column_id),
      C.name,
      CAST(C.system_type_id AS NVARCHAR(MAX))+QUOTENAME(TS.name) system_type_id,
      CAST(C.user_type_id AS NVARCHAR(MAX))+CASE WHEN TU.system_type_id<> TU.user_type_id THEN QUOTENAME(SCHEMA_NAME(TU.schema_id))+'.' ELSE '' END + QUOTENAME(TU.name) user_type_id,
      C.max_length,
      C.precision,
      C.scale,
      C.collation_name,
      C.is_nullable
    FROM sys.columns AS C
    JOIN sys.types AS TS
      ON C.system_type_id = TS.user_type_id
    JOIN sys.types AS TU
      ON C.user_type_id = TU.user_type_id
   WHERE C.object_id = OBJECT_ID(@Expected);
  INSERT INTO tSQLt.Private_AssertEqualsTableSchema_Actual([RANK(column_id)],name,system_type_id,user_type_id,max_length,precision,scale,collation_name,is_nullable)
  SELECT 
      RANK()OVER(ORDER BY C.column_id),
      C.name,
      CAST(C.system_type_id AS NVARCHAR(MAX))+QUOTENAME(TS.name) system_type_id,
      CAST(C.user_type_id AS NVARCHAR(MAX))+CASE WHEN TU.system_type_id<> TU.user_type_id THEN QUOTENAME(SCHEMA_NAME(TU.schema_id))+'.' ELSE '' END + QUOTENAME(TU.name) user_type_id,
      C.max_length,
      C.precision,
      C.scale,
      C.collation_name,
      C.is_nullable
    FROM sys.columns AS C
    JOIN sys.types AS TS
      ON C.system_type_id = TS.user_type_id
    JOIN sys.types AS TU
      ON C.user_type_id = TU.user_type_id
   WHERE C.object_id = OBJECT_ID(@Actual);
  
  EXEC tSQLt.AssertEqualsTable 'tSQLt.Private_AssertEqualsTableSchema_Expected','tSQLt.Private_AssertEqualsTableSchema_Actual',@Message=@Message,@FailMsg='Unexpected/missing column(s)';  
END;
GO
PRINT N'Creating [err].[Error2Id]'
GO

CREATE FUNCTION [err].[Error2Id]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 56002;  
END
GO
PRINT N'Creating [err].[ThrowError2]'
GO

CREATE PROCEDURE [err].[ThrowError2] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.Error2Id();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [DatabaseVersioning].[SystemTable_SetTemporalType]'
GO
CREATE PROCEDURE [DatabaseVersioning].[SystemTable_SetTemporalType]
    @SchemaName TSTRING, @TableName TSTRING, @TemporalTypeId INT
AS
BEGIN
    MERGE dsp.SystemTable AS target
    USING (SELECT   @SchemaName SchemaName, @TableName TableName, @TemporalTypeId TemporalTypeId) AS source (SchemaName, TableName, TemporalTypeId)
       ON (target.SchemaName = source.SchemaName AND target.TableName = source.TableName)
     WHEN MATCHED
        THEN UPDATE SET target.TemporalTypeId = source.TemporalTypeId
     WHEN NOT MATCHED
        THEN INSERT (SystemTableId, SchemaName, TableName, TemporalTypeId)
             VALUES (OBJECT_ID(source.SchemaName + '.' + source.TableName), source.SchemaName, source.TableName, source.TemporalTypeId);
END;

GO
PRINT N'Creating [tSQLt].[AssertLike]'
GO
CREATE PROCEDURE [tSQLt].[AssertLike] 
  @ExpectedPattern NVARCHAR(MAX),
  @Actual NVARCHAR(MAX),
  @Message NVARCHAR(MAX) = ''
AS
BEGIN
  IF (LEN(@ExpectedPattern) > 4000)
  BEGIN
    RAISERROR ('@ExpectedPattern may not exceed 4000 characters.', 16, 10);
  END;

  IF ((@Actual LIKE @ExpectedPattern) OR (@Actual IS NULL AND @ExpectedPattern IS NULL))
  BEGIN
    RETURN 0;
  END

  DECLARE @Msg NVARCHAR(MAX);
  SELECT @Msg = CHAR(13) + CHAR(10) + 'Expected: <' + ISNULL(@ExpectedPattern, 'NULL') + '>' +
                CHAR(13) + CHAR(10) + ' but was: <' + ISNULL(@Actual, 'NULL') + '>';
  EXEC tSQLt.Fail @Message, @Msg;
END;
GO
PRINT N'Creating [tSQLt].[AssertNotEquals]'
GO
CREATE PROCEDURE [tSQLt].[AssertNotEquals]
    @Expected SQL_VARIANT,
    @Actual SQL_VARIANT,
    @Message NVARCHAR(MAX) = ''
AS
BEGIN
  IF (@Expected = @Actual)
  OR (@Expected IS NULL AND @Actual IS NULL)
  BEGIN
    DECLARE @Msg NVARCHAR(MAX);
    SET @Msg = 'Expected actual value to not ' + 
               COALESCE('equal <' + tSQLt.Private_SqlVariantFormatter(@Expected)+'>', 'be NULL') + 
               '.';
    EXEC tSQLt.Fail @Message,@Msg;
  END;
  RETURN 0;
END;
GO
PRINT N'Creating [err].[FatalErrorId]'
GO

CREATE FUNCTION [err].[FatalErrorId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55012;  
END
GO
PRINT N'Creating [err].[ThrowFatalError]'
GO

CREATE PROCEDURE [err].[ThrowFatalError] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.FatalErrorId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[TableVersioning_CheckWithSource]'
GO
CREATE PROCEDURE [dsp].[TableVersioning_CheckWithSource]
    @SourceObject TJSON
AS
BEGIN
    -- Acheive the current database table's structure
    DECLARE @TablesJsonResult TJSON;
    EXEC dsp.Database_Tables @TablesJsonResult = @TablesJsonResult OUTPUT;
    -- Compare 2 Json 
    DECLARE @AreSame BIT;
    EXEC dsp.Json_Compare @Json1 = @SourceObject, @Json2 = @TablesJsonResult, @TwoSided = 1, @IncludeValue = 1, @IsThrow = 0, @AreSame = @AreSame OUTPUT;

    IF (@AreSame = 0) --
        EXEC dsperr.ThrowHasNotSameStrcutre @ProcId = @@PROCID, @Message = 'Source and target Json are not same';
END;
GO
PRINT N'Creating [dsp].[Metadata_ExtendedPropertyValueOfSchema]'
GO
CREATE FUNCTION [dsp].[Metadata_ExtendedPropertyValueOfSchema] (@SchemaName TSTRING,
	@ExtendedPropertyName TSTRING)
RETURNS SQL_VARIANT
AS
BEGIN
	DECLARE @Value SQL_VARIANT;

	SELECT	@Value = value
	FROM	sys.fn_listextendedproperty(NULL, 'SCHEMA', NULL, NULL, NULL, NULL, NULL)
	WHERE	objname = @SchemaName AND	name = @ExtendedPropertyName;

	RETURN @Value;
END;

GO
PRINT N'Creating [tSQLt].[AssertObjectDoesNotExist]'
GO
CREATE PROCEDURE [tSQLt].[AssertObjectDoesNotExist]
    @ObjectName NVARCHAR(MAX),
    @Message NVARCHAR(MAX) = ''
AS
BEGIN
     DECLARE @Msg NVARCHAR(MAX);
     IF OBJECT_ID(@ObjectName) IS NOT NULL
     OR(@ObjectName LIKE '#%' AND OBJECT_ID('tempdb..'+@ObjectName) IS NOT NULL)
     BEGIN
         SELECT @Msg = '''' + @ObjectName + ''' does exist!';
         EXEC tSQLt.Fail @Message,@Msg;
     END;
END;
GO
PRINT N'Creating [tSQLt].[AssertStringIn]'
GO

CREATE PROCEDURE [tSQLt].[AssertStringIn]
  @Expected tSQLt.AssertStringTable READONLY,
  @Actual NVARCHAR(MAX),
  @Message NVARCHAR(MAX) = ''
AS
BEGIN
  IF(NOT EXISTS(SELECT 1 FROM @Expected WHERE value = @Actual))
  BEGIN
    DECLARE @ExpectedMessage NVARCHAR(MAX);
    SELECT value INTO #ExpectedSet FROM @Expected;
    EXEC tSQLt.TableToText @TableName = '#ExpectedSet', @OrderBy = 'value',@txt = @ExpectedMessage OUTPUT;
    SET @ExpectedMessage = ISNULL('<'+@Actual+'>','NULL')+CHAR(13)+CHAR(10)+'is not in'+CHAR(13)+CHAR(10)+@ExpectedMessage;
    EXEC tSQLt.Fail @Message, @ExpectedMessage;
  END;
END;
GO
PRINT N'Creating [err].[GeneralExceptionId]'
GO

CREATE FUNCTION [err].[GeneralExceptionId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55001;  
END
GO
PRINT N'Creating [err].[ThrowGeneralException]'
GO

CREATE PROCEDURE [err].[ThrowGeneralException] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.GeneralExceptionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Metadata_SystemTypeName]'
GO
CREATE FUNCTION [dsp].[Metadata_SystemTypeName] (@TypeName TSTRING)
RETURNS TSTRING
AS
BEGIN
	DECLARE @SystemName TSTRING = @TypeName;

	IF EXISTS (SELECT		1
					FROM	sys.types AS T
				WHERE	T.name = @SystemName AND T.is_user_defined = 1)
	BEGIN
		SELECT	DISTINCT @SystemName = bt.name
		FROM	sys.syscolumns c
				INNER JOIN sys.systypes st ON st.xusertype = c.xusertype
				INNER JOIN sys.systypes bt ON bt.xusertype = c.xtype
		WHERE	st.name = @TypeName;
	END;

	RETURN @SystemName;
END;
GO
PRINT N'Creating [dsp].[ThrowFail]'
GO
CREATE PROCEDURE [dsp].[ThrowFail]
    @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>',
    @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = dspconst.Exception_DspFailErrorId();
    THROW @ExceptionId, @Message, 1;
END;
GO
PRINT N'Creating [tSQLt].[DefaultResultFormatter]'
GO
CREATE PROCEDURE [tSQLt].[DefaultResultFormatter]
AS
BEGIN
    DECLARE @Msg1 NVARCHAR(MAX);
    DECLARE @Msg2 NVARCHAR(MAX);
    DECLARE @Msg3 NVARCHAR(MAX);
    DECLARE @Msg4 NVARCHAR(MAX);
    DECLARE @IsSuccess INT;
    DECLARE @SuccessCnt INT;
    DECLARE @Severity INT;
    
    SELECT ROW_NUMBER() OVER(ORDER BY Result DESC, Name ASC) No,Name [Test Case Name],
           RIGHT(SPACE(7)+CAST(DATEDIFF(MILLISECOND,TestStartTime,TestEndTime) AS VARCHAR(7)),7) AS [Dur(ms)], Result
      INTO #TestResultOutput
      FROM tSQLt.TestResult;
    
    EXEC tSQLt.TableToText @Msg1 OUTPUT, '#TestResultOutput', 'No';

    SELECT @Msg3 = Msg, 
           @IsSuccess = 1 - SIGN(FailCnt + ErrorCnt),
           @SuccessCnt = SuccessCnt
      FROM tSQLt.TestCaseSummary();
      
    SELECT @Severity = 16*(1-@IsSuccess);
    
    SELECT @Msg2 = REPLICATE('-',LEN(@Msg3)),
           @Msg4 = CHAR(13)+CHAR(10);
    
    
    EXEC tSQLt.Private_Print @Msg4,0;
    EXEC tSQLt.Private_Print '+----------------------+',0;
    EXEC tSQLt.Private_Print '|Test Execution Summary|',0;
    EXEC tSQLt.Private_Print '+----------------------+',0;
    EXEC tSQLt.Private_Print @Msg4,0;
    EXEC tSQLt.Private_Print @Msg1,0;
    EXEC tSQLt.Private_Print @Msg2,0;
    EXEC tSQLt.Private_Print @Msg3, @Severity;
    EXEC tSQLt.Private_Print @Msg2,0;
END;
GO
PRINT N'Creating [err].[InvalidCaptchaId]'
GO

CREATE FUNCTION [err].[InvalidCaptchaId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55022;  
END
GO
PRINT N'Creating [err].[ThrowInvalidCaptcha]'
GO

CREATE PROCEDURE [err].[ThrowInvalidCaptcha] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.InvalidCaptchaId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dsp].[Param_IsSetOrNotNullString]'
GO

-- to check if the @value has been set or not
-- String not set value: <notset>
-- Int not set value: -1
-- datetime not set value: '1753-01-01
CREATE FUNCTION [dsp].[Param_IsSetOrNotNullString] (@Value TSTRING)
RETURNS BIT
AS
BEGIN
	RETURN IIF(@Value IS NULL OR dsp.Param_IsSetString(@Value) = 0, 0, 1);
END;





GO
PRINT N'Creating [tSQLt].[Private_CreateFakeFunction]'
GO
CREATE PROCEDURE [tSQLt].[Private_CreateFakeFunction]
  @FunctionName NVARCHAR(MAX),
  @FakeFunctionName NVARCHAR(MAX),
  @FunctionObjectId INT,
  @FakeFunctionObjectId INT,
  @IsScalarFunction BIT
AS
BEGIN
  DECLARE @ReturnType NVARCHAR(MAX);
  SELECT @ReturnType = T.TypeName
    FROM sys.parameters AS P
   CROSS APPLY tSQLt.Private_GetFullTypeName(P.user_type_id,P.max_length,P.precision,P.scale,NULL) AS T
   WHERE P.object_id = @FunctionObjectId
     AND P.parameter_id = 0;
     
  DECLARE @ParameterList NVARCHAR(MAX);
  SELECT @ParameterList = COALESCE(
     STUFF((SELECT ','+P.name+' '+T.TypeName+CASE WHEN T.IsTableType = 1 THEN ' READONLY' ELSE '' END
              FROM sys.parameters AS P
             CROSS APPLY tSQLt.Private_GetFullTypeName(P.user_type_id,P.max_length,P.precision,P.scale,NULL) AS T
             WHERE P.object_id = @FunctionObjectId
               AND P.parameter_id > 0
             ORDER BY P.parameter_id
               FOR XML PATH(''),TYPE
           ).value('.','NVARCHAR(MAX)'),1,1,''),'');
           
  DECLARE @ParameterCallList NVARCHAR(MAX);
  SELECT @ParameterCallList = COALESCE(
     STUFF((SELECT ','+P.name
              FROM sys.parameters AS P
             CROSS APPLY tSQLt.Private_GetFullTypeName(P.user_type_id,P.max_length,P.precision,P.scale,NULL) AS T
             WHERE P.object_id = @FunctionObjectId
               AND P.parameter_id > 0
             ORDER BY P.parameter_id
               FOR XML PATH(''),TYPE
           ).value('.','NVARCHAR(MAX)'),1,1,''),'');


  IF(@IsScalarFunction = 1)
  BEGIN
    EXEC('CREATE FUNCTION '+@FunctionName+'('+@ParameterList+') RETURNS '+@ReturnType+' AS BEGIN RETURN '+@FakeFunctionName+'('+@ParameterCallList+');END;'); 
  END
  ELSE
  BEGIN
    EXEC('CREATE FUNCTION '+@FunctionName+'('+@ParameterList+') RETURNS TABLE AS RETURN SELECT * FROM '+@FakeFunctionName+'('+@ParameterCallList+');'); 
  END;
END;
GO
PRINT N'Creating [dsp].[User_UserIdByAuthUserId]'
GO

CREATE PROCEDURE [dsp].[User_UserIdByAuthUserId]
    @AuthUserId INT, @UserId TSTRING OUT
AS
BEGIN
    SET @UserId = NULL;

    -- find the UserId from your own user table
    -- SELECT  @UserId = U.UserId FROM  dbo.AuthUser AS U WHERE  U.AuthUserId = @AuthUserId;

    IF (@UserId IS NULL) --
        EXEC err.ThrowAuthUserNotFound @ProcId = @@PROCID, @Message = 'AuthUserId: {0}', @Param0 = @AuthUserId;
END;
GO
PRINT N'Creating [err].[InvalidOperationId]'
GO

CREATE FUNCTION [err].[InvalidOperationId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55016;  
END
GO
PRINT N'Creating [err].[ThrowInvalidOperation]'
GO

CREATE PROCEDURE [err].[ThrowInvalidOperation] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.InvalidOperationId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_UserPermissionObject]'
GO
CREATE PROCEDURE [dspAuth].[SecurityDescriptor_UserPermissionObject]
    @ObjectId BIGINT, @ObjectTypeId INT, @UserId INT, @ThrowIfNotExists BIT = 1, @Permissions TSTRING = NULL OUT
AS
BEGIN
    SET @ThrowIfNotExists = ISNULL(@ThrowIfNotExists, 1);

    SET @Permissions = CONCAT('[', (   SELECT   STRING_AGG(dsp.Convert_ToString(SDUPF.PermissionId), ',')
                                         FROM   dspAuth.SecurityDescriptor_UserPermissions(@ObjectId, @ObjectTypeId, @UserId, NULL) AS SDUPF ), ']');

    IF (@Permissions IS NULL AND @ThrowIfNotExists = 1) --	
        EXEC dsp.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @ObjectTypeName = 'Permissions', @ObjectId = @Permissions;

END;

GO
PRINT N'Creating [dsp].[Server_ServerNumber]'
GO

CREATE   FUNCTION [dsp].[Server_ServerNumber] (@ServerName TSTRING)
RETURNS INT
AS
BEGIN
    SET @ServerName = SUBSTRING(@ServerName, LEN(@ServerName), 1);
    RETURN IIF(@ServerName IS NULL OR   ISNUMERIC(@ServerName) != 1, NULL, CAST(@ServerName AS INT));
END;
GO
PRINT N'Creating [tSQLt].[Private_ValidateObjectsCompatibleWithFakeFunction]'
GO
CREATE PROCEDURE [tSQLt].[Private_ValidateObjectsCompatibleWithFakeFunction]
  @FunctionName NVARCHAR(MAX),
  @FakeFunctionName NVARCHAR(MAX),
  @FunctionObjectId INT OUTPUT,
  @FakeFunctionObjectId INT OUTPUT,
  @IsScalarFunction BIT OUTPUT
AS
BEGIN
  SET @FunctionObjectId = OBJECT_ID(@FunctionName);
  SET @FakeFunctionObjectId = OBJECT_ID(@FakeFunctionName);

  IF(@FunctionObjectId IS NULL)
  BEGIN
    RAISERROR('%s does not exist!',16,10,@FunctionName);
  END;
  IF(@FakeFunctionObjectId IS NULL)
  BEGIN
    RAISERROR('%s does not exist!',16,10,@FakeFunctionName);
  END;
  
  DECLARE @FunctionType CHAR(2);
  DECLARE @FakeFunctionType CHAR(2);
  SELECT @FunctionType = type FROM sys.objects WHERE object_id = @FunctionObjectId;
  SELECT @FakeFunctionType = type FROM sys.objects WHERE object_id = @FakeFunctionObjectId;

  IF((@FunctionType IN('FN','FS') AND @FakeFunctionType NOT IN('FN','FS'))
     OR
     (@FunctionType IN('TF','IF','FT') AND @FakeFunctionType NOT IN('TF','IF','FT'))
     OR
     (@FunctionType NOT IN('FN','FS','TF','IF','FT'))
     )    
  BEGIN
    RAISERROR('Both parameters must contain the name of either scalar or table valued functions!',16,10);
  END;
  
  SET @IsScalarFunction = CASE WHEN @FunctionType IN('FN','FS') THEN 1 ELSE 0 END;
  
  IF(EXISTS(SELECT 1 
              FROM sys.parameters AS P
             WHERE P.object_id IN(@FunctionObjectId,@FakeFunctionObjectId)
             GROUP BY P.name, P.max_length, P.precision, P.scale, P.parameter_id
            HAVING COUNT(1) <> 2
           ))
  BEGIN
    RAISERROR('Parameters of both functions must match! (This includes the return type for scalar functions.)',16,10);
  END; 
END;
GO
PRINT N'Creating [tSQLt].[FakeFunction]'
GO
CREATE PROCEDURE [tSQLt].[FakeFunction]
  @FunctionName NVARCHAR(MAX),
  @FakeFunctionName NVARCHAR(MAX)
AS
BEGIN
  DECLARE @FunctionObjectId INT;
  DECLARE @FakeFunctionObjectId INT;
  DECLARE @IsScalarFunction BIT;

  EXEC tSQLt.Private_ValidateObjectsCompatibleWithFakeFunction 
               @FunctionName = @FunctionName,
               @FakeFunctionName = @FakeFunctionName,
               @FunctionObjectId = @FunctionObjectId OUT,
               @FakeFunctionObjectId = @FakeFunctionObjectId OUT,
               @IsScalarFunction = @IsScalarFunction OUT;

  EXEC tSQLt.RemoveObject @ObjectName = @FunctionName;

  EXEC tSQLt.Private_CreateFakeFunction 
               @FunctionName = @FunctionName,
               @FakeFunctionName = @FakeFunctionName,
               @FunctionObjectId = @FunctionObjectId,
               @FakeFunctionObjectId = @FakeFunctionObjectId,
               @IsScalarFunction = @IsScalarFunction;

END;
GO
PRINT N'Creating [dspAuth].[Context_Permissions]'
GO
CREATE PROCEDURE [dspAuth].[Context_Permissions]
    @Context TCONTEXT OUT, @ObjectId BIGINT, @ObjectTypeId INT, @Permissions TSTRING = NULL OUT
AS
BEGIN
    DECLARE @ContextUserId INT = dsp.Context_UserId(@Context);

    EXEC dspAuth.SecurityDescriptor_UserPermissionObject @ObjectId = @ObjectId, @ObjectTypeId = @ObjectTypeId, @UserId = @ContextUserId,
        @Permissions = @Permissions OUTPUT;
END;
GO
PRINT N'Creating [dsp].[Setting_SystemUserId]'
GO
CREATE FUNCTION [dsp].[Setting_SystemUserId] ()
RETURNS INT
AS
BEGIN
    RETURN (SELECT  S.SystemUserId FROM dsp.Setting AS S);
END;




GO
PRINT N'Creating [err].[InvalidParamSignatureId]'
GO

CREATE FUNCTION [err].[InvalidParamSignatureId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55029;  
END
GO
PRINT N'Creating [err].[ThrowInvalidParamSignature]'
GO

CREATE PROCEDURE [err].[ThrowInvalidParamSignature] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.InvalidParamSignatureId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[Init_Cleanup]'
GO

CREATE PROCEDURE [dspAuth].[Init_Cleanup]
AS
BEGIN
    SET NOCOUNT ON;
	
    -- Protect production environment
    EXEC dsp.Util_ProtectProductionEnvironment;

    DELETE  dspAuth.SecurityDescriptorUserPermission;
    DELETE  dspAuth.SecurityDescriptorRolePermission;
    DELETE  dspAuth.PermissionGroupPermission;
    DELETE  dspAuth.PermissionGroup;
    DELETE  dspAuth.Permission;
    DELETE  dspAuth.Role;
    DELETE  dspAuth.SecurityDescriptorParent;
    DELETE  dspAuth.SecurityDescriptor;
    DELETE  dspAuth.ObjectType;
    
	DBCC CHECKIDENT('dspAuth.SecurityDescriptor', RESEED, 10000000000);

END;

GO
PRINT N'Creating [dspAuth].[Role_AddUser]'
GO


CREATE PROCEDURE [dspAuth].[Role_AddUser]
    @AuditUserId INT, @RoleId INT, @UserId INT
AS
BEGIN
    BEGIN TRY
        INSERT  dspAuth.RoleUser (RoleId, UserId, ModifiedByUserId)
        VALUES (@RoleId, @UserId, @AuditUserId);
    END TRY
    BEGIN CATCH
        IF (ERROR_NUMBER() = 2627) -- duplicate key error
            EXEC dsperr.ThrowObjectAlreadyExists @ProcId = @@PROCID, @Message = N'UserId: {0}', @Param0 = @UserId;
        THROW;
    END CATCH;
END;
GO
PRINT N'Creating [err].[InvokerAppVersionId]'
GO

CREATE FUNCTION [err].[InvokerAppVersionId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55026;  
END
GO
PRINT N'Creating [err].[ThrowInvokerAppVersion]'
GO

CREATE PROCEDURE [err].[ThrowInvokerAppVersion] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.InvokerAppVersionId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[SecurityDescriptor_Create]'
GO

CREATE PROCEDURE [dspAuth].[SecurityDescriptor_Create]
    @ObjectId BIGINT, @ObjectTypeId INT, @SecurityDescriptorId BIGINT = NULL OUT
AS
BEGIN
    INSERT  dspAuth.SecurityDescriptor (ObjectId, ObjectTypeId)
    VALUES (@ObjectId, @ObjectTypeId);

    SET @SecurityDescriptorId = SCOPE_IDENTITY();
END;



GO
PRINT N'Creating [DatabaseVersioning].[Validate_Mirroring]'
GO
 CREATE PROCEDURE [DatabaseVersioning].[Validate_Mirroring]
    @CheckForSource BIT = 1
AS
BEGIN
    SET @CheckForSource = ISNULL(@CheckForSource, 1);
    -- Create variables
    DECLARE @Result TABLE (ObjectId INT,
        SchemaName TSTRING,
        TableName TSTRING,
        TemporalTypeId INT,
        LevelPriority INT,
        IsTemporal BIT);

    DECLARE @Message TSTRING;

    -- Get list tables
    INSERT INTO @Result (ObjectId, SchemaName, TableName, TemporalTypeId, LevelPriority, IsTemporal)
    SELECT  SystemTableId ObjectId, SchemaName, TableName, TemporalTypeId, LevelPriority, IsTemporal
      FROM  dsp.SystemTable;
	/*  --
	  IF EXISTS (SELECT * FROM @Result WHERE TemporalTypeId = /*dspconst.TemporalType_Temporal()*/2 AND IsTemporal = 0)
	  EXEC dsp.ThrowFatalError @ProcId = @@PROCID, @Message = ''	  

	  IF EXISTS (SELECT * FROM @Result WHERE TemporalTypeId = /*dspconst.TemporalType_Temporal()*/2 AND IsTemporal = 0)
	  EXEC dsp.ThrowFatalError @ProcId = @@PROCID, @Message = ''	  
	  */
    -- Validate PrimaryKey on tables
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result R
                                OUTER APPLY dsp.Table_HasPrimaryKey(R.SchemaName, R.TableName) THPK
                        WHERE   THPK.HasPrimaryKey = 0 AND  R.TableName NOT LIKE '%History%');

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table(s) does not have PrimaryKey: {0}', @Param0 = @Message;

    -- Validate In destination side temporaltype must be off

    /* SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                        WHERE   R.IsTemporal = 1 AND @CheckForSource = 0);*/

    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                        WHERE   @CheckForSource = 0 AND R.TemporalTypeId = 2);


    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Temporaltype must be off in destination side: {0}', @Param0 = @Message;

    -- Validate TemporalType extended property on all tables
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result R
                        WHERE   R.TemporalTypeId IS NULL);

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'Table(s) does not have TemporalType in extended property: {0}', @Param0 = @Message;

    -- Validate LevelPriority in SystemTable 
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result R
                        WHERE   R.LevelPriority IS NULL);

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID, @Message = 'LevelPriority must be not null in SystemTable: {0}', @Param0 = @Message;

    -- Validate table with transactional TemporalType that does not have CreatedTime
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                                OUTER APPLY DatabaseVersioning.Table_HasColumnName(R.ObjectId, 'CreatedTime') AS THC
                        WHERE   R.TemporalTypeId = dspconst.TemporalType_Transactional() AND THC.HasColumn IS NULL);

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID,
            @Message = 'Table(s) does not have CreatedTime in Transactional temporal type in extended property: {0}', @Param0 = @Message;

    -- Validate table with ordinary TemporalType that does not have CreatedTime
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                                OUTER APPLY DatabaseVersioning.Table_HasColumnName(R.ObjectId, 'CreatedTime') AS THC
                        WHERE   R.TemporalTypeId = dspconst.TemporalType_Ordinary() AND THC.HasColumn IS NULL);
    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID,
            @Message = 'Table(s) does not have CreatedTime in ordinary temporal type in extended property: {0}', @Param0 = @Message;

    -- Validate table with ordinary TemporalType that does not have ModifiedTime for detect updated records
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                                OUTER APPLY DatabaseVersioning.Table_HasColumnName(R.ObjectId, 'ModifiedTime') AS THC
                        WHERE   R.TemporalTypeId = dspconst.TemporalType_Ordinary() AND THC.HasColumn IS NULL);

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID,
            @Message = 'Table(s) does not have ModifiedTime in ordinary temporal type in extended property: {0}', @Param0 = @Message;

    -- Validate table with ordinary TemporalType that does not have ModifiedTime for detect updated records
    SET @Message = (   SELECT   STRING_AGG(R.SchemaName + '.' + R.TableName, ',')
                         FROM   @Result AS R
                                OUTER APPLY DatabaseVersioning.Table_HasColumnName(R.ObjectId, 'ModifiedTime') AS THC
                        WHERE   R.TemporalTypeId = dspconst.TemporalType_Ordinary() AND THC.HasColumn IS NULL);

    IF (@Message IS NOT NULL) --
        EXEC dsperr.ThrowInvalidOperation @ProcId = @@PROCID,
            @Message = 'Table(s) does not have ModifiedTime in ordinary temporal type in extended property: {0}', @Param0 = @Message;

-- Set feature enable
--EXEC DatabaseVersioning.Setting_SetProps @IsFeatureEnabled = 1;

END;

GO
PRINT N'Creating [tSQLt].[Private_GetIdentityDefinition]'
GO
CREATE FUNCTION [tSQLt].[Private_GetIdentityDefinition](@ObjectId INT, @ColumnId INT, @ReturnDetails BIT)
RETURNS TABLE
AS
RETURN SELECT 
              COALESCE(IsIdentity, 0) AS IsIdentityColumn,
              COALESCE(IdentityDefinition, '') AS IdentityDefinition
        FROM (SELECT 1) X(X)
        LEFT JOIN (SELECT 1 AS IsIdentity,
                          ' IDENTITY(' + CAST(seed_value AS NVARCHAR(MAX)) + ',' + CAST(increment_value AS NVARCHAR(MAX)) + ')' AS IdentityDefinition, 
                          object_id, 
                          column_id
                     FROM sys.identity_columns
                  ) AS id
               ON id.object_id = @ObjectId
              AND id.column_id = @ColumnId
              AND @ReturnDetails = 1;
GO
PRINT N'Creating [tSQLt].[Private_GetDefaultConstraintDefinition]'
GO
CREATE FUNCTION [tSQLt].[Private_GetDefaultConstraintDefinition](@ObjectId INT, @ColumnId INT, @ReturnDetails BIT)
RETURNS TABLE
AS
RETURN SELECT 
              COALESCE(IsDefault, 0) AS IsDefault,
              COALESCE(DefaultDefinition, '') AS DefaultDefinition
        FROM (SELECT 1) X(X)
        LEFT JOIN (SELECT 1 AS IsDefault,' DEFAULT '+ definition AS DefaultDefinition,parent_object_id,parent_column_id
                     FROM sys.default_constraints
                  )dc
               ON dc.parent_object_id = @ObjectId
              AND dc.parent_column_id = @ColumnId
              AND @ReturnDetails = 1;
GO
PRINT N'Creating [tSQLt].[Private_CreateFakeOfTable]'
GO
CREATE PROCEDURE [tSQLt].[Private_CreateFakeOfTable]
  @SchemaName NVARCHAR(MAX),
  @TableName NVARCHAR(MAX),
  @OrigTableFullName NVARCHAR(MAX),
  @Identity BIT,
  @ComputedColumns BIT,
  @Defaults BIT
AS
BEGIN
   DECLARE @Cmd NVARCHAR(MAX);
   DECLARE @Cols NVARCHAR(MAX);
   
   SELECT @Cols = 
   (
    SELECT
       ',' +
       QUOTENAME(name) + 
       cc.ColumnDefinition +
       dc.DefaultDefinition + 
       id.IdentityDefinition +
       CASE WHEN cc.IsComputedColumn = 1 OR id.IsIdentityColumn = 1 
            THEN ''
            ELSE ' NULL'
       END
      FROM sys.columns c
     CROSS APPLY tSQLt.Private_GetDataTypeOrComputedColumnDefinition(c.user_type_id, c.max_length, c.precision, c.scale, c.collation_name, c.object_id, c.column_id, @ComputedColumns) cc
     CROSS APPLY tSQLt.Private_GetDefaultConstraintDefinition(c.object_id, c.column_id, @Defaults) AS dc
     CROSS APPLY tSQLt.Private_GetIdentityDefinition(c.object_id, c.column_id, @Identity) AS id
     WHERE object_id = OBJECT_ID(@OrigTableFullName)
     ORDER BY column_id
     FOR XML PATH(''), TYPE
    ).value('.', 'NVARCHAR(MAX)');
    
   SELECT @Cmd = 'CREATE TABLE ' + @SchemaName + '.' + @TableName + '(' + STUFF(@Cols,1,1,'') + ')';
   
   EXEC (@Cmd);
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_FilterByApiKey]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_FilterByApiKey] (@SchemaName TSTRING,
    @ApiKey TSTRING)
RETURNS TABLE
AS
RETURN SELECT   DSP.StoredProcedureId, DSP.StoredProcedureName
         FROM   dsp.StoredProcedure_List(@SchemaName) AS DSP
        WHERE   DSP.StoredProcedureKey = @ApiKey;

GO
PRINT N'Creating [err].[LockFailedId]'
GO

CREATE FUNCTION [err].[LockFailedId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55013;  
END
GO
PRINT N'Creating [err].[ThrowLockFailed]'
GO

CREATE PROCEDURE [err].[ThrowLockFailed] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.LockFailedId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[ObjectType_Role]'
GO
CREATE FUNCTION [dspAuth].[ObjectType_Role]()
 RETURNS INT WITH SCHEMABINDING
 AS 
 BEGIN
     RETURN 3;
 END











GO
PRINT N'Creating [dspAuth].[Role_Create]'
GO
CREATE PROCEDURE [dspAuth].[Role_Create]
    @AuditUserId BIGINT, @OwnerSecurityDescriptorId BIGINT, @RoleName TSTRING, @IsSystem BIT = 0, @RoleTypeId INT, @RoleId INT = NULL OUT
AS
BEGIN
    SET @RoleId = NULL;
    SET @IsSystem = ISNULL(@IsSystem, 0);     
	
    DECLARE @TranCount INT = @@TRANCOUNT;
    IF (@TranCount = 0)
        BEGIN TRANSACTION;
    BEGIN TRY
        -- Insert
        INSERT  dspAuth.Role (RoleName, OwnerSecurityDescriptorId, RoleTypeId, ModifiedByUserId, IsSystem)
        VALUES (@RoleName, @OwnerSecurityDescriptorId, @RoleTypeId, @AuditUserId, @IsSystem);
        SET @RoleId = SCOPE_IDENTITY();

        -- Validate inserted record
        EXEC dsp.Validate_CheckNotNull @ProcId = @@PROCID, @ArgumentName = 'RoleId', @ArgumentValue = @RoleId;

        -- Create SecurityDescriptor for Role
        DECLARE @SecurityDescriptorId BIGINT;
        DECLARE @ObjectType_Role INT = dspAuth.ObjectType_Role();
        EXEC dspAuth.SecurityDescriptor_Create @ObjectId = @RoleId, @ObjectTypeId = @ObjectType_Role;

        IF (@TranCount = 0) COMMIT;
    END TRY
    BEGIN CATCH
        IF (@TranCount = 0)
            ROLLBACK TRANSACTION;
        THROW;
    END CATCH;
END;




















GO
PRINT N'Creating [dspAuth].[Role_Delete]'
GO
CREATE  PROCEDURE [dspAuth].[Role_Delete]
	@AuditUserId INT, @RoleId INT
AS
BEGIN
	-- Checking if there is a role with RoleId: @RoleId
	EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Checking if there is a role with RoleId: {0}', @Param0 = @RoleId;
	DECLARE @ActualRoleId INT;
	SELECT	@ActualRoleId = R.RoleId
	FROM dspAuth.Role AS R
	WHERE	R.RoleId = @RoleId;

	IF (@ActualRoleId IS NULL) --
		EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = N'There is no Role with RoleId: {0}', @Param0 = @RoleId;

	DECLARE @TranCount INT = @@TRANCOUNT;
	IF (@TranCount = 0)
		BEGIN TRANSACTION;
	BEGIN TRY
		-- Updating Role before deleting it
		EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Updating Role before deleting it';
		UPDATE	dspAuth.Role
		SET ModifiedByUserId = @AuditUserId
		WHERE	RoleId = @RoleId;

		-- Deleting with RoleId: @RoleId
		EXEC dsp.Log_Trace @ProcId = @@PROCID, @Message = N'Deleting with RoleId: {0}', @Param0 = @RoleId;
		DELETE dspAuth.Role
		WHERE	RoleId = @RoleId;

		IF (@TranCount = 0) COMMIT;
	END TRY
	BEGIN CATCH
		IF (@TranCount = 0)
			ROLLBACK TRANSACTION;
		THROW;
	END CATCH;
END;


GO
PRINT N'Creating [tSQLt].[Private_ValidateFakeTableParameters]'
GO
CREATE PROCEDURE [tSQLt].[Private_ValidateFakeTableParameters]
  @SchemaName NVARCHAR(MAX),
  @OrigTableName NVARCHAR(MAX),
  @OrigSchemaName NVARCHAR(MAX)
AS
BEGIN
   IF @SchemaName IS NULL
   BEGIN
        DECLARE @FullName NVARCHAR(MAX); SET @FullName = @OrigTableName + COALESCE('.' + @OrigSchemaName, '');
        
        RAISERROR ('FakeTable could not resolve the object name, ''%s''. (When calling tSQLt.FakeTable, avoid the use of the @SchemaName parameter, as it is deprecated.)', 
                   16, 10, @FullName);
   END;
END;
GO
PRINT N'Creating [tSQLt].[Private_ResolveFakeTableNamesForBackwardCompatibility]'
GO
CREATE FUNCTION [tSQLt].[Private_ResolveFakeTableNamesForBackwardCompatibility] 
 (@TableName NVARCHAR(MAX), @SchemaName NVARCHAR(MAX))
RETURNS TABLE AS 
RETURN
  SELECT QUOTENAME(OBJECT_SCHEMA_NAME(object_id)) AS CleanSchemaName,
         QUOTENAME(OBJECT_NAME(object_id)) AS CleanTableName
     FROM (SELECT CASE
                    WHEN @SchemaName IS NULL THEN OBJECT_ID(@TableName)
                    ELSE COALESCE(OBJECT_ID(@SchemaName + '.' + @TableName),OBJECT_ID(@TableName + '.' + @SchemaName)) 
                  END object_id
          ) ids;
GO
PRINT N'Creating [tSQLt].[Private_MarkFakeTable]'
GO
CREATE PROCEDURE [tSQLt].[Private_MarkFakeTable]
  @SchemaName NVARCHAR(MAX),
  @TableName NVARCHAR(MAX),
  @NewNameOfOriginalTable NVARCHAR(4000)
AS
BEGIN
   DECLARE @UnquotedSchemaName NVARCHAR(MAX);SET @UnquotedSchemaName = OBJECT_SCHEMA_NAME(OBJECT_ID(@SchemaName+'.'+@TableName));
   DECLARE @UnquotedTableName NVARCHAR(MAX);SET @UnquotedTableName = OBJECT_NAME(OBJECT_ID(@SchemaName+'.'+@TableName));

   EXEC sys.sp_addextendedproperty 
      @name = N'tSQLt.FakeTable_OrgTableName', 
      @value = @NewNameOfOriginalTable, 
      @level0type = N'SCHEMA', @level0name = @UnquotedSchemaName, 
      @level1type = N'TABLE',  @level1name = @UnquotedTableName;
END;
GO
PRINT N'Creating [tSQLt].[FakeTable]'
GO
CREATE PROCEDURE [tSQLt].[FakeTable]
    @TableName NVARCHAR(MAX),
    @SchemaName NVARCHAR(MAX) = NULL, --parameter preserved for backward compatibility. Do not use. Will be removed soon.
    @Identity BIT = NULL,
    @ComputedColumns BIT = NULL,
    @Defaults BIT = NULL
AS
BEGIN
   DECLARE @OrigSchemaName NVARCHAR(MAX);
   DECLARE @OrigTableName NVARCHAR(MAX);
   DECLARE @NewNameOfOriginalTable NVARCHAR(4000);
   DECLARE @OrigTableFullName NVARCHAR(MAX); SET @OrigTableFullName = NULL;
   
   SELECT @OrigSchemaName = @SchemaName,
          @OrigTableName = @TableName
   
   IF(@OrigTableName NOT IN (PARSENAME(@OrigTableName,1),QUOTENAME(PARSENAME(@OrigTableName,1)))
      AND @OrigSchemaName IS NOT NULL)
   BEGIN
     RAISERROR('When @TableName is a multi-part identifier, @SchemaName must be NULL!',16,10);
   END

   SELECT @SchemaName = CleanSchemaName,
          @TableName = CleanTableName
     FROM tSQLt.Private_ResolveFakeTableNamesForBackwardCompatibility(@TableName, @SchemaName);
   
   EXEC tSQLt.Private_ValidateFakeTableParameters @SchemaName,@OrigTableName,@OrigSchemaName;

   EXEC tSQLt.Private_RenameObjectToUniqueName @SchemaName, @TableName, @NewNameOfOriginalTable OUTPUT;

   SELECT @OrigTableFullName = S.base_object_name
     FROM sys.synonyms AS S 
    WHERE S.object_id = OBJECT_ID(@SchemaName + '.' + @NewNameOfOriginalTable);

   IF(@OrigTableFullName IS NOT NULL)
   BEGIN
     IF(COALESCE(OBJECT_ID(@OrigTableFullName,'U'),OBJECT_ID(@OrigTableFullName,'V')) IS NULL)
     BEGIN
       RAISERROR('Cannot fake synonym %s.%s as it is pointing to %s, which is not a table or view!',16,10,@SchemaName,@TableName,@OrigTableFullName);
     END;
   END;
   ELSE
   BEGIN
     SET @OrigTableFullName = @SchemaName + '.' + @NewNameOfOriginalTable;
   END;

   EXEC tSQLt.Private_CreateFakeOfTable @SchemaName, @TableName, @OrigTableFullName, @Identity, @ComputedColumns, @Defaults;

   EXEC tSQLt.Private_MarkFakeTable @SchemaName, @TableName, @NewNameOfOriginalTable;
END
GO
PRINT N'Creating [err].[MaintenanceId]'
GO

CREATE FUNCTION [err].[MaintenanceId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55027;  
END
GO
PRINT N'Creating [err].[ThrowMaintenance]'
GO

CREATE PROCEDURE [err].[ThrowMaintenance] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.MaintenanceId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[Role_GetProps]'
GO
CREATE PROCEDURE [dspAuth].[Role_GetProps]
    @RoleId INT, @OwnerSecurityDescriptorId BIGINT = NULL OUT, @RoleName TSTRING = NULL OUT, @RoleTypeId INT = NULL OUT
AS
BEGIN
    SELECT  @RoleName = R.RoleName, @OwnerSecurityDescriptorId = R.OwnerSecurityDescriptorId, @RoleTypeId = R.RoleTypeId
      FROM  dspAuth.Role AS R
     WHERE  R.RoleId = @RoleId;

    IF (@OwnerSecurityDescriptorId IS NULL) --
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = 'RoleId: {0}', @Param0 = @RoleId;
END;
GO
PRINT N'Creating [dspAuth].[Role_RemoveUser]'
GO
CREATE PROCEDURE [dspAuth].[Role_RemoveUser]
    @RoleId INT, @UserId INT
AS
BEGIN
    -- Throw Exception if there is no record corresponding to User and Role
    IF NOT EXISTS (   SELECT    1
                        FROM    dspAuth.RoleUser AS RM
                       WHERE RM.UserId = @UserId AND RM.RoleId = @RoleId)
        EXEC dsperr.ThrowAccessDeniedOrObjectNotExists @ProcId = @@PROCID, @Message = N'there is no user:{0} in Role: {1}', @Param0 = @UserId, @Param1 = @RoleId;

    -- Get RoleType
    DECLARE @RoleTypeId INT;
    EXEC dspAuth.Role_GetProps @RoleId = @RoleId, @RoleTypeId = @RoleTypeId OUTPUT;
	
    -- delete record
    DELETE  dspAuth.RoleUser
     WHERE  UserId = @UserId AND RoleId = @RoleId;
END;
GO
PRINT N'Creating [dsp].[StoredProcedure_NewVersion]'
GO
CREATE FUNCTION [dsp].[StoredProcedure_NewVersion] (@SchemaName TSTRING,
    @StoredProcedureName TSTRING,
    @StoredProcedureVersion INT)
RETURNS TABLE
AS
RETURN (   SELECT   TOP 1 AVD.AppVersionDetailId, --
               AVD.AppVersionId, --
               AVD.StoredProcedureName, --
               AVD.StoredProcedurePhysicalName, --
               AVD.SchemaName, --
               AVD.StoredProcedureVersionNumber, --
               AVD.ExpirationTime --
             FROM   dsp.AppVersionDetail AS AVD
            WHERE   AVD.SchemaName = @SchemaName --
               AND  AVD.StoredProcedureName = @StoredProcedureName --
               AND  AVD.StoredProcedureVersionNumber >= @StoredProcedureVersion
			   ORDER BY AVD.StoredProcedureVersionNumber);

GO
PRINT N'Creating [err].[MaintenanceReadOnlyId]'
GO

CREATE FUNCTION [err].[MaintenanceReadOnlyId]()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 55028;  
END
GO
PRINT N'Creating [err].[ThrowMaintenanceReadOnly]'
GO

CREATE PROCEDURE [err].[ThrowMaintenanceReadOnly] @ProcId INT, @Message TSTRING = NULL, @Param0 TSTRING = '<notset>', @Param1 TSTRING = '<notset>', @Param2 TSTRING = '<notset>', @Param3 TSTRING = '<notset>'
AS
BEGIN
    DECLARE @ExceptionId INT = err.MaintenanceReadOnlyId();
    EXEC dsp.ThrowAppException @ProcId = @ProcId, @ExceptionId = @ExceptionId, @Message = @Message, @Param0 = @Param0, @Param1 = @Param1,
        @Param2 = @Param2, @Param3 = @Param3;
END
GO
PRINT N'Creating [dspAuth].[Role_SetProps]'
GO
CREATE PROCEDURE [dspAuth].[Role_SetProps]
    @AuditUserId INT, @RoleId INT, @RoleName TSTRING = '<notset>'
AS
BEGIN
    -- Fetch Old Data
    DECLARE @OldRoleName TSTRING;
    SELECT  @OldRoleName = R.RoleName
      FROM  dspAuth.Role AS R
     WHERE  R.RoleId = @RoleId;

    -- Detect if there are any changes
    DECLARE @IsUserUpdated BIT = 0;
    EXEC dsp.SetIfChanged_String @ProcId = @@PROCID, @PropName = 'RoleName', @IsUpdated = @IsUserUpdated OUT, @OldValue = @OldRoleName OUT,
        @NewValue = @RoleName;

    -- Update table Role if neccassary
    IF (@IsUserUpdated = 1)
        UPDATE  dspAuth.Role
           SET  RoleName = @OldRoleName, ModifiedByUserId = @AuditUserId
         WHERE  RoleId = @RoleId;
END;



GO
PRINT N'Creating [dspstr].[String1]'
GO

				CREATE FUNCTION [dspstr].[String1]() 
				RETURNS TSTRING
				AS 
				BEGIN
					RETURN dsp.StringTable_Value('String1');
				END
						
GO
PRINT N'Creating [dbo].[FTest]'
GO
CREATE   FUNCTION [dbo].[FTest](@I INT)
RETURNS INT
AS
BEGIN
RETURN 1
END
GO
PRINT N'Creating [dsp].[DateTime_DatePart]'
GO
CREATE   FUNCTION [dsp].[DateTime_DatePart] (@DatePart CHAR(1),
    @Date VARCHAR(10))
RETURNS INT
AS
BEGIN
    -- SQL Prompt Formatting Off
    RETURN (   SELECT   Q.StrValue
                 FROM   (   SELECT  ROW_NUMBER() OVER (ORDER BY (SELECT   1)) AS Id, SS.value AS StrValue
                              FROM  STRING_SPLIT(@Date, '-') AS SS) Q
                WHERE   Q.Id = (CASE LOWER(@DatePart)
                                    WHEN 'y' THEN 1
                                    WHEN 'm' THEN 2
                                    WHEN 'd' THEN 3 
									ELSE 0
                                END));
END;
GO
PRINT N'Creating [dsp].[DateTime_EndOfDayTime]'
GO
CREATE FUNCTION [dsp].[DateTime_EndOfDayTime] (
	@Time DATETIME)
RETURNS DATETIME
AS
BEGIN
	DECLARE @NextDay DATETIME = DATEADD(DAY, 1, CAST(CAST(@Time AS DATE) AS DATETIME));
	SET @Time = DATEADD(MILLISECOND, -10, @NextDay);

	RETURN @Time;
END;

GO
PRINT N'Creating [dsp].[DateTime_FisrtNextDayOfWeek]'
GO
CREATE	FUNCTION [dsp].[DateTime_FisrtNextDayOfWeek] (@NextDay INT)
RETURNS DATETIME
AS
BEGIN
	-- Mon:0, Tue:1, Wed:2, Thr:3, Fri:4, Sat:5, Sun:6
	DECLARE @CalculatedTime DATETIME = DATEADD(DAY, (DATEDIFF(DAY, @NextDay, GETDATE()) / 7) * 7 + 7, @NextDay);
	RETURN @CalculatedTime;
END;



GO
PRINT N'Creating [dsp].[DateTime_FromUnixTimeStamp]'
GO
CREATE FUNCTION [dsp].[DateTime_FromUnixTimeStamp] (
@UnixTime BIGINT
)
RETURNS datetime
AS
BEGIN

  RETURN DATEADD(S,@UnixTime,'1970-01-01')

END
GO
PRINT N'Creating [dsp].[DateTime_HasTimePart]'
GO
create FUNCTION [dsp].[DateTime_HasTimePart] (@Time DATETIME)
RETURNS BIT
AS
BEGIN
	RETURN IIF(@Time = CAST(@Time AS DATE), 0, 1);
END;


GO
PRINT N'Creating [dsp].[DateTime_StartOfDayTime]'
GO
CREATE FUNCTION [dsp].[DateTime_StartOfDayTime] (@Time DATETIME)
RETURNS DATETIME
AS
BEGIN
	DECLARE @PreviousDay DATETIME = CAST(CAST(@Time AS DATE) AS DATETIME);

	RETURN @PreviousDay;
END;




GO
PRINT N'Creating [dsp].[DateTime_ToUnixTimeStamp]'
GO
CREATE FUNCTION [dsp].[DateTime_ToUnixTimeStamp] (@time DATETIME)
RETURNS INTEGER
AS
BEGIN
    DECLARE @diff BIGINT 
    IF @time >= '20380119' 
    BEGIN 
        SET @diff = CONVERT(BIGINT, DATEDIFF(S, '19700101', '20380119')) 
            + CONVERT(BIGINT, DATEDIFF(S, '20380119', @time)) 
    END 
    ELSE 
        SET @diff = DATEDIFF(S, '19700101', @time) 
    RETURN @diff 
END;

GO
PRINT N'Creating [dsp].[GetTemporalTablesList]'
GO
CREATE   FUNCTION [dsp].[GetTemporalTablesList]()
RETURNS TABLE
RETURN SELECT --
            SCHEMA_NAME(t.schema_id) AS temporal_table_schema, --
           t.name AS temporal_table_name, --
           SCHEMA_NAME(h.schema_id) AS history_table_schema, --
           h.name AS history_table_name, --
           (CASE
                WHEN t.history_retention_period = -1
                    THEN 'INFINITE' ELSE CAST(t.history_retention_period AS VARCHAR) + ' ' + t.history_retention_period_unit_desc + 'S'
            END) AS retention_period
         FROM   sys.tables t
                LEFT OUTER JOIN sys.tables h ON t.history_table_id = h.object_id
        WHERE   t.temporal_type = 2;
GO
PRINT N'Creating [dsp].[Int_Min]'
GO
CREATE FUNCTION [dsp].[Int_Min] (@Value1 INT,
    @Value2 INT)
RETURNS TABLE
RETURN (   SELECT   MIN(value.v) MinValue
             FROM   (VALUES (@Value1), (@Value2)) AS value (v) );

GO
PRINT N'Creating [dspconst].[RequestIntervalType_DayOfWeek]'
GO
CREATE FUNCTION [dspconst].[RequestIntervalType_DayOfWeek] ()
RETURNS TINYINT
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[RequestIntervalType_Day]'
GO
CREATE FUNCTION [dspconst].[RequestIntervalType_Day] ()
RETURNS TINYINT
AS
BEGIN
    RETURN 3;
END;
GO
PRINT N'Creating [dspconst].[RequestIntervalType_Hour]'
GO
CREATE FUNCTION [dspconst].[RequestIntervalType_Hour] ()
RETURNS TINYINT
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[RequestIntervalType_Minute]'
GO
CREATE FUNCTION [dspconst].[RequestIntervalType_Minute] ()
RETURNS TINYINT
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [tSQLt].[F_Num]'
GO
CREATE FUNCTION [tSQLt].[F_Num](
       @N INT
)
RETURNS TABLE 
AS 
RETURN WITH C0(c) AS (SELECT 1 UNION ALL SELECT 1),
            C1(c) AS (SELECT 1 FROM C0 AS A CROSS JOIN C0 AS B),
            C2(c) AS (SELECT 1 FROM C1 AS A CROSS JOIN C1 AS B),
            C3(c) AS (SELECT 1 FROM C2 AS A CROSS JOIN C2 AS B),
            C4(c) AS (SELECT 1 FROM C3 AS A CROSS JOIN C3 AS B),
            C5(c) AS (SELECT 1 FROM C4 AS A CROSS JOIN C4 AS B),
            C6(c) AS (SELECT 1 FROM C5 AS A CROSS JOIN C5 AS B)
       SELECT TOP(CASE WHEN @N>0 THEN @N ELSE 0 END) ROW_NUMBER() OVER (ORDER BY c) no
         FROM C6;
GO
PRINT N'Creating [tSQLt].[Private_GetCleanSchemaName]'
GO
/*******************************************************************************************/
/*******************************************************************************************/
/*******************************************************************************************/
CREATE FUNCTION [tSQLt].[Private_GetCleanSchemaName](@SchemaName NVARCHAR(MAX), @ObjectName NVARCHAR(MAX))
RETURNS NVARCHAR(MAX)
AS
BEGIN
    RETURN (SELECT SCHEMA_NAME(schema_id) 
              FROM sys.objects 
             WHERE object_id = CASE WHEN ISNULL(@SchemaName,'') in ('','[]')
                                    THEN OBJECT_ID(@ObjectName)
                                    ELSE OBJECT_ID(@SchemaName + '.' + @ObjectName)
                                END);
END;
GO
PRINT N'Creating [tSQLt].[Private_GetConstraintType]'
GO
CREATE FUNCTION [tSQLt].[Private_GetConstraintType](@TableObjectId INT, @ConstraintName NVARCHAR(MAX))
RETURNS TABLE
AS
RETURN
  SELECT object_id,type,type_desc
    FROM sys.objects 
   WHERE object_id = OBJECT_ID(SCHEMA_NAME(schema_id)+'.'+@ConstraintName)
     AND parent_object_id = @TableObjectId;
GO
PRINT N'Creating [tSQLt].[Private_GetOriginalTableName]'
GO
/*******************************************************************************************/
/*******************************************************************************************/
/*******************************************************************************************/
CREATE FUNCTION [tSQLt].[Private_GetOriginalTableName](@SchemaName NVARCHAR(MAX), @TableName NVARCHAR(MAX)) --DELETE!!!
RETURNS NVARCHAR(MAX)
AS
BEGIN
  RETURN (SELECT CAST(value AS NVARCHAR(4000))
    FROM sys.extended_properties
   WHERE class_desc = 'OBJECT_OR_COLUMN'
     AND major_id = OBJECT_ID(@SchemaName + '.' + @TableName)
     AND minor_id = 0
     AND name = 'tSQLt.FakeTable_OrgTableName');
END;
GO
PRINT N'Creating [dsp].[AuthUserHistory]'
GO
CREATE TABLE [dsp].[AuthUserHistory]
(
[AuthUserId] [int] NULL,
[UserId] [int] NOT NULL,
[StartTime] [datetime2] NOT NULL,
[EndTime] [datetime2] NOT NULL,
[VersioningStartTime] [datetime2] NOT NULL,
[VersioningEndTime] [datetime2] NOT NULL
)
GO
PRINT N'Creating index [ix_AuthUserHistory] on [dsp].[AuthUserHistory]'
GO
CREATE CLUSTERED INDEX [ix_AuthUserHistory] ON [dsp].[AuthUserHistory] ([VersioningEndTime], [VersioningStartTime])
GO
PRINT N'Creating [dsp].[AuthUser]'
GO
CREATE TABLE [dsp].[AuthUser]
(
[AuthUserId] [int] NULL,
[UserId] [int] NOT NULL,
[StartTime] [datetime2] NOT NULL CONSTRAINT [DF__AuthUser__StartT__42F26B57] DEFAULT (getdate()),
[EndTime] [datetime2] NOT NULL CONSTRAINT [DF__AuthUser__EndTim__43E68F90] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0))),
[VersioningStartTime] [datetime2] NOT NULL CONSTRAINT [DF__AuthUser__Versio__0A6EE669] DEFAULT (getdate()),
[VersioningEndTime] [datetime2] NOT NULL CONSTRAINT [DF__AuthUser__Versio__0B630AA2] DEFAULT (CONVERT([datetime2],'9999-12-31 23:59:59.9999999',(0)))
)
GO
PRINT N'Creating primary key [PK_AuthUser] on [dsp].[AuthUser]'
GO
ALTER TABLE [dsp].[AuthUser] ADD CONSTRAINT [PK_AuthUser] PRIMARY KEY CLUSTERED  ([UserId])
GO
PRINT N'Creating [tSQLt].[Private_ExpectException]'
GO
CREATE TABLE [tSQLt].[Private_ExpectException]
(
[i] [int] NULL
)
GO
PRINT N'Creating [DatabaseVersioning].[vw_UserDefinedTables]'
GO
CREATE VIEW [DatabaseVersioning].[vw_UserDefinedTables]
AS
SELECT  T.object_id AS ObjectId, S.name AS SchemaName, T.name AS TableName
  FROM  sys.tables T
        INNER JOIN sys.schemas S ON S.schema_id = T.schema_id
 WHERE  LOWER(S.name) NOT LIKE N'tsqlt%' AND LOWER(T.name) NOT LIKE '%history';
GO
PRINT N'Creating [dspAuth].[ObjectType_System]'
GO
CREATE FUNCTION [dspAuth].[ObjectType_System]()
 RETURNS INT WITH SCHEMABINDING
 AS 
 BEGIN
     RETURN 1;
 END

GO
PRINT N'Creating [dsp].[Const_MaintenanceMode_Block]'
GO
CREATE FUNCTION [dsp].[Const_MaintenanceMode_Block] ()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 2;
END;


GO
PRINT N'Creating [dsp].[Const_MaintenanceMode_None]'
GO
CREATE FUNCTION [dsp].[Const_MaintenanceMode_None] ()
RETURNS INT WITH SCHEMABINDING
AS
BEGIN
	RETURN 0;
END;


GO
PRINT N'Creating [dsp].[Const_MaintenanceMode_Readonly]'
GO
CREATE FUNCTION [dsp].[Const_MaintenanceMode_Readonly] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;



GO
PRINT N'Creating [dsp].[DateTime_ConvertUTCLocal]'
GO
CREATE   FUNCTION [dsp].[DateTime_ConvertUTCLocal] (@UTCDate DATETIME2)
RETURNS DATETIME
WITH SCHEMABINDING
AS
BEGIN

    RETURN DATEADD(MINUTE, DATEDIFF(MINUTE, GETUTCDATE(), GETDATE()), @UTCDate);

END;

GO
PRINT N'Creating [dsp].[DateTime_HasBetween]'
GO
CREATE FUNCTION [dsp].[DateTime_HasBetween] (@TimeToCheck DATETIME,
    @FromTime DATETIME,
    @ToTime DATETIME)
RETURNS BIT
WITH SCHEMABINDING
AS
BEGIN
    DECLARE @HasBelong BIT = 0;

    IF (@TimeToCheck IS NULL) --
        RETURN 0;

    SET @FromTime = CONCAT(DATEPART(YEAR, @TimeToCheck), '-', DATEPART(MONTH, @FromTime), '-', DATEPART(DAY, @FromTime));
    SET @ToTime = CONCAT(DATEPART(YEAR, @TimeToCheck), '-', DATEPART(MONTH, @ToTime), '-', DATEPART(DAY, @ToTime));

    IF (@TimeToCheck >= @FromTime AND   @TimeToCheck < @ToTime)
        SET @HasBelong = 1;

    RETURN @HasBelong;
END;


GO
PRINT N'Creating [dsp].[DateTime_RemoveSecond]'
GO
CREATE FUNCTION [dsp].[DateTime_RemoveSecond] (@DateTime DATETIME)
RETURNS DATETIME
WITH SCHEMABINDING
AS
BEGIN
	DECLARE @Date DATETIME = CAST(@DateTime AS DATE)	
	DECLARE @Hour INT = DATEPART(HOUR, @DateTime)
	DECLARE @Minute INT = DATEPART(MINUTE, @DateTime)

    DECLARE @Result DATETIME = DATEADD(MINUTE, @Minute, @Date)
	SET @Result = DATEADD(HOUR, @Hour, @Result)

	RETURN @Result
END
GO
PRINT N'Creating [dsp].[Int_Max]'
GO
CREATE FUNCTION [dsp].[Int_Max] (@Value1 INT,
    @Value2 INT)
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    DECLARE @MaxValue INT;

    SELECT  @MaxValue = MAX(value.v)
      FROM  (VALUES (@Value1), (@Value2)) AS value (v);

    RETURN @MaxValue;
END;

GO
PRINT N'Creating [dspconst].[RequestProcessStatus_DisableBySetting]'
GO
CREATE FUNCTION [dspconst].[RequestProcessStatus_DisableBySetting] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 4;
END;
GO
PRINT N'Creating [dspconst].[RequestProcessStatus_Fail]'
GO
CREATE FUNCTION [dspconst].[RequestProcessStatus_Fail] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 5;
END;
GO
PRINT N'Creating [dspconst].[RequestProcessStatus_InProgress]'
GO
CREATE FUNCTION [dspconst].[RequestProcessStatus_InProgress] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 2;
END;
GO
PRINT N'Creating [dspconst].[RequestProcessStatus_NotProcess]'
GO
CREATE FUNCTION [dspconst].[RequestProcessStatus_NotProcess] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;

GO
PRINT N'Creating [dspconst].[RequestProcessStatus_Success]'
GO
CREATE FUNCTION [dspconst].[RequestProcessStatus_Success] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 3;
END;

GO
PRINT N'Creating [dspconst].[RequestType_Test]'
GO
CREATE   FUNCTION [dspconst].[RequestType_Test] ()
RETURNS INT
WITH SCHEMABINDING
AS
BEGIN
    RETURN 1;
END;
GO
PRINT N'Creating [DatabaseVersioning].[TableProcess_Refresh]'
GO
CREATE PROCEDURE [DatabaseVersioning].[TableProcess_Refresh]
AS
BEGIN
   
   -- Obviously database versioning feaure must checked all necessary requiments



   -- Get source structure 

   -- Get current db structure

   RETURN

    
END
GO
PRINT N'Creating [tSQLt].[AssertResultSetsHaveSameMetaData]'
GO
SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS OFF
GO
CREATE PROCEDURE [tSQLt].[AssertResultSetsHaveSameMetaData] (@expectedCommand [nvarchar] (max), @actualCommand [nvarchar] (max))
WITH EXECUTE AS CALLER
AS EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.StoredProcedures].[AssertResultSetsHaveSameMetaData]
GO
PRINT N'Creating [tSQLt].[CaptureOutput]'
GO
CREATE PROCEDURE [tSQLt].[CaptureOutput] (@command [nvarchar] (max))
WITH EXECUTE AS CALLER
AS EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.StoredProcedures].[CaptureOutput]
GO
PRINT N'Creating [tSQLt].[ExpectException]'
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE PROCEDURE [tSQLt].[ExpectException]
@ExpectedMessage NVARCHAR(MAX) = NULL,
@ExpectedSeverity INT = NULL,
@ExpectedState INT = NULL,
@Message NVARCHAR(MAX) = NULL,
@ExpectedMessagePattern NVARCHAR(MAX) = NULL,
@ExpectedErrorNumber INT = NULL
AS
BEGIN
 IF(EXISTS(SELECT 1 FROM #ExpectException WHERE ExpectException = 1))
 BEGIN
   DELETE #ExpectException;
   RAISERROR('Each test can only contain one call to tSQLt.ExpectException.',16,10);
 END;
 
 INSERT INTO #ExpectException(ExpectException, ExpectedMessage, ExpectedSeverity, ExpectedState, ExpectedMessagePattern, ExpectedErrorNumber, FailMessage)
 VALUES(1, @ExpectedMessage, @ExpectedSeverity, @ExpectedState, @ExpectedMessagePattern, @ExpectedErrorNumber, @Message);
END;
GO
PRINT N'Creating [tSQLt].[ExpectNoException]'
GO
CREATE PROCEDURE [tSQLt].[ExpectNoException]
  @Message NVARCHAR(MAX) = NULL
AS
BEGIN
 IF(EXISTS(SELECT 1 FROM #ExpectException WHERE ExpectException = 0))
 BEGIN
   DELETE #ExpectException;
   RAISERROR('Each test can only contain one call to tSQLt.ExpectNoException.',16,10);
 END;
 IF(EXISTS(SELECT 1 FROM #ExpectException WHERE ExpectException = 1))
 BEGIN
   DELETE #ExpectException;
   RAISERROR('tSQLt.ExpectNoException cannot follow tSQLt.ExpectException inside a single test.',16,10);
 END;
 
 INSERT INTO #ExpectException(ExpectException, FailMessage)
 VALUES(0, @Message);
END;
GO
PRINT N'Creating [tSQLt].[NewConnection]'
GO
SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS OFF
GO
CREATE PROCEDURE [tSQLt].[NewConnection] (@command [nvarchar] (max))
WITH EXECUTE AS CALLER
AS EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.StoredProcedures].[NewConnection]
GO
PRINT N'Creating [tSQLt].[NullTestResultFormatter]'
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE PROCEDURE [tSQLt].[NullTestResultFormatter]
AS
BEGIN
  RETURN 0;
END;
GO
PRINT N'Creating [tSQLt].[Private_RemoveSchemaBoundReferences]'
GO
CREATE PROCEDURE [tSQLt].[Private_RemoveSchemaBoundReferences]
  @object_id INT
AS
BEGIN
  DECLARE @cmd NVARCHAR(MAX);
  SELECT @cmd = 
  (
    SELECT 
      'EXEC tSQLt.Private_RemoveSchemaBoundReferences @object_id = '+STR(SED.referencing_id)+';'+
      'EXEC tSQLt.Private_RemoveSchemaBinding @object_id = '+STR(SED.referencing_id)+';'
      FROM
      (
        SELECT DISTINCT SEDI.referencing_id,SEDI.referenced_id 
          FROM sys.sql_expression_dependencies AS SEDI
         WHERE SEDI.is_schema_bound_reference = 1
      ) AS SED 
     WHERE SED.referenced_id = @object_id
       FOR XML PATH(''),TYPE
  ).value('.','NVARCHAR(MAX)');
  EXEC(@cmd);
END;
GO
PRINT N'Creating [tSQLt].[RemoveExternalAccessKey]'
GO
CREATE PROCEDURE [tSQLt].[RemoveExternalAccessKey]
AS
BEGIN
  IF(NOT EXISTS(SELECT * FROM sys.fn_my_permissions(NULL,'server') AS FMP WHERE FMP.permission_name = 'CONTROL SERVER'))
  BEGIN
    RAISERROR('Only principals with CONTROL SERVER permission can execute this procedure.',16,10);
    RETURN -1;
  END;

  DECLARE @master_sys_sp_executesql NVARCHAR(MAX); SET @master_sys_sp_executesql = 'master.sys.sp_executesql';

  IF SUSER_ID('tSQLtExternalAccessKey') IS NOT NULL DROP LOGIN tSQLtExternalAccessKey;
  EXEC @master_sys_sp_executesql N'IF ASYMKEY_ID(''tSQLtExternalAccessKey'') IS NOT NULL DROP ASYMMETRIC KEY tSQLtExternalAccessKey;';
  EXEC @master_sys_sp_executesql N'IF EXISTS(SELECT * FROM sys.assemblies WHERE name = ''tSQLtExternalAccessKey'') DROP ASSEMBLY tSQLtExternalAccessKey;';
END;
GO
PRINT N'Creating [tSQLt].[ResultSetFilter]'
GO
SET QUOTED_IDENTIFIER OFF
GO
SET ANSI_NULLS OFF
GO
CREATE PROCEDURE [tSQLt].[ResultSetFilter] (@ResultsetNo [int], @Command [nvarchar] (max))
WITH EXECUTE AS CALLER
AS EXTERNAL NAME [tSQLtCLR].[tSQLtCLR.StoredProcedures].[ResultSetFilter]
GO
PRINT N'Creating [tSQLt].[RunTest]'
GO
SET QUOTED_IDENTIFIER ON
GO
SET ANSI_NULLS ON
GO
CREATE PROCEDURE [tSQLt].[RunTest]
   @TestName NVARCHAR(MAX)
AS
BEGIN
  RAISERROR('tSQLt.RunTest has been retired. Please use tSQLt.Run instead.', 16, 10);
END;
GO
PRINT N'Creating [tSQLt].[SetTestResultFormatter]'
GO
CREATE PROCEDURE [tSQLt].[SetTestResultFormatter]
    @Formatter NVARCHAR(4000)
AS
BEGIN
    IF EXISTS (SELECT 1 FROM sys.extended_properties WHERE [name] = N'tSQLt.ResultsFormatter')
    BEGIN
        EXEC sp_dropextendedproperty @name = N'tSQLt.ResultsFormatter',
                                    @level0type = 'SCHEMA',
                                    @level0name = 'tSQLt',
                                    @level1type = 'PROCEDURE',
                                    @level1name = 'Private_OutputTestResults';
    END;

    EXEC sp_addextendedproperty @name = N'tSQLt.ResultsFormatter', 
                                @value = @Formatter,
                                @level0type = 'SCHEMA',
                                @level0name = 'tSQLt',
                                @level1type = 'PROCEDURE',
                                @level1name = 'Private_OutputTestResults';
END;
GO
PRINT N'Creating [tSQLt].[StubRecord]'
GO
CREATE PROCEDURE [tSQLt].[StubRecord](@SnTableName AS NVARCHAR(MAX), @BintObjId AS BIGINT)  
AS   
BEGIN  

    RAISERROR('Warning, tSQLt.StubRecord is not currently supported. Use at your own risk!', 0, 1) WITH NOWAIT;

    DECLARE @VcInsertStmt NVARCHAR(MAX),  
            @VcInsertValues NVARCHAR(MAX);  
    DECLARE @SnColumnName NVARCHAR(MAX); 
    DECLARE @SintDataType SMALLINT; 
    DECLARE @NvcFKCmd NVARCHAR(MAX);  
    DECLARE @VcFKVal NVARCHAR(MAX); 
  
    SET @VcInsertStmt = 'INSERT INTO ' + @SnTableName + ' ('  
      
    DECLARE curColumns CURSOR  
        LOCAL FAST_FORWARD  
    FOR  
    SELECT syscolumns.name,  
           syscolumns.xtype,  
           cmd.cmd  
    FROM syscolumns  
        LEFT OUTER JOIN dbo.sysconstraints ON syscolumns.id = sysconstraints.id  
                                      AND syscolumns.colid = sysconstraints.colid  
                                      AND sysconstraints.status = 1    -- Primary key constraints only  
        LEFT OUTER JOIN (select fkeyid id,fkey colid,N'select @V=cast(min('+syscolumns.name+') as NVARCHAR) from '+sysobjects.name cmd  
                        from sysforeignkeys   
                        join sysobjects on sysobjects.id=sysforeignkeys.rkeyid  
                        join syscolumns on sysobjects.id=syscolumns.id and syscolumns.colid=rkey) cmd  
            on cmd.id=syscolumns.id and cmd.colid=syscolumns.colid  
    WHERE syscolumns.id = OBJECT_ID(@SnTableName)  
      AND (syscolumns.isnullable = 0 )  
    ORDER BY ISNULL(sysconstraints.status, 9999), -- Order Primary Key constraints first  
             syscolumns.colorder  
  
    OPEN curColumns  
  
    FETCH NEXT FROM curColumns  
    INTO @SnColumnName, @SintDataType, @NvcFKCmd  
  
    -- Treat the first column retrieved differently, no commas need to be added  
    -- and it is the ObjId column  
    IF @@FETCH_STATUS = 0  
    BEGIN  
        SET @VcInsertStmt = @VcInsertStmt + @SnColumnName  
        SELECT @VcInsertValues = ')VALUES(' + ISNULL(CAST(@BintObjId AS nvarchar), 'NULL')  
  
        FETCH NEXT FROM curColumns  
        INTO @SnColumnName, @SintDataType, @NvcFKCmd  
    END  
    ELSE  
    BEGIN  
        -- No columns retrieved, we need to insert into any first column  
        SELECT @VcInsertStmt = @VcInsertStmt + syscolumns.name  
        FROM syscolumns  
        WHERE syscolumns.id = OBJECT_ID(@SnTableName)  
          AND syscolumns.colorder = 1  
  
        SELECT @VcInsertValues = ')VALUES(' + ISNULL(CAST(@BintObjId AS nvarchar), 'NULL')  
  
    END  
  
    WHILE @@FETCH_STATUS = 0  
    BEGIN  
        SET @VcInsertStmt = @VcInsertStmt + ',' + @SnColumnName  
        SET @VcFKVal=',0'  
        if @NvcFKCmd is not null  
        BEGIN  
            set @VcFKVal=null  
            exec sp_executesql @NvcFKCmd,N'@V NVARCHAR(MAX) output',@VcFKVal output  
            set @VcFKVal=isnull(','''+@VcFKVal+'''',',NULL')  
        END  
        SET @VcInsertValues = @VcInsertValues + @VcFKVal  
  
        FETCH NEXT FROM curColumns  
        INTO @SnColumnName, @SintDataType, @NvcFKCmd  
    END  
      
    CLOSE curColumns  
    DEALLOCATE curColumns  
  
    SET @VcInsertStmt = @VcInsertStmt + @VcInsertValues + ')'  
  
    IF EXISTS (SELECT 1   
               FROM syscolumns  
               WHERE status = 128   
                 AND id = OBJECT_ID(@SnTableName))  
    BEGIN  
        SET @VcInsertStmt = 'SET IDENTITY_INSERT ' + @SnTableName + ' ON ' + CHAR(10) +   
                             @VcInsertStmt + CHAR(10) +   
                             'SET IDENTITY_INSERT ' + @SnTableName + ' OFF '  
    END  
  
    EXEC (@VcInsertStmt)    -- Execute the actual INSERT statement  
  
END
GO
PRINT N'Adding constraints to [dsp].[Setting]'
GO
ALTER TABLE [dsp].[Setting] ADD CONSTRAINT [CK_Setting_MaintenaceMode] CHECK (([MaintenanceMode]=(2) OR [MaintenanceMode]=(1) OR [MaintenanceMode]=(0)))
GO
PRINT N'Adding foreign keys to [dsp].[SystemTable]'
GO
ALTER TABLE [dsp].[SystemTable] ADD CONSTRAINT [FK_SystemTable_TemporalType] FOREIGN KEY ([TemporalTypeId]) REFERENCES [DatabaseVersioning].[TemporalType] ([TemporalTypeId])
GO
PRINT N'Adding foreign keys to [dbo].[Logs]'
GO
ALTER TABLE [dbo].[Logs] ADD CONSTRAINT [FK_Logs_Applicatoins_ApplicationId] FOREIGN KEY ([ApplicationId]) REFERENCES [dbo].[Application] ([ApplicationId])
GO
PRINT N'Adding foreign keys to [dbo].[AuthUser]'
GO
ALTER TABLE [dbo].[AuthUser] ADD CONSTRAINT [FK_AuthUser_Users_CreatedByUserId] FOREIGN KEY ([CreatedByUserId]) REFERENCES [dbo].[Users] ([UserId])
GO
ALTER TABLE [dbo].[AuthUser] ADD CONSTRAINT [FK_AuthUser_Users_ModifiedByUserId] FOREIGN KEY ([ModifiedByUserId]) REFERENCES [dbo].[Users] ([UserId])
GO
PRINT N'Adding foreign keys to [dspAuth].[SecurityDescriptor]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptor] ADD CONSTRAINT [FK_SecurityDescriptor_ObjectType_ObjectTypeId] FOREIGN KEY ([ObjectTypeId]) REFERENCES [dspAuth].[ObjectType] ([ObjectTypeId])
GO
PRINT N'Adding foreign keys to [dspAuth].[PermissionGroupPermission]'
GO
ALTER TABLE [dspAuth].[PermissionGroupPermission] ADD CONSTRAINT [FK_PermissionGroupPermission_PermissionGroupId] FOREIGN KEY ([PermissionGroupId]) REFERENCES [dspAuth].[PermissionGroup] ([PermissionGroupId]) ON DELETE CASCADE
GO
ALTER TABLE [dspAuth].[PermissionGroupPermission] ADD CONSTRAINT [FK_PermissionGroupPermission_Permission_PermissionId] FOREIGN KEY ([PermissionId]) REFERENCES [dspAuth].[Permission] ([PermissionId]) ON DELETE CASCADE
GO
PRINT N'Adding foreign keys to [dspAuth].[SecurityDescriptorRolePermission]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorRolePermission] ADD CONSTRAINT [FK_SecurityDescriptorRolePermission_PermissionGroup_PermissionGroupId] FOREIGN KEY ([PermissionGroupId]) REFERENCES [dspAuth].[PermissionGroup] ([PermissionGroupId])
GO
ALTER TABLE [dspAuth].[SecurityDescriptorRolePermission] ADD CONSTRAINT [FK_SecurityDescriptorRolePermission_Role_RoleId] FOREIGN KEY ([RoleId]) REFERENCES [dspAuth].[Role] ([RoleId]) ON DELETE CASCADE ON UPDATE CASCADE
GO
ALTER TABLE [dspAuth].[SecurityDescriptorRolePermission] ADD CONSTRAINT [FK_SecurityDescriptorRolePermission_SecurityDescriptor_SecurityDescriptorId] FOREIGN KEY ([SecurityDescriptorId]) REFERENCES [dspAuth].[SecurityDescriptor] ([SecurityDescriptorId])
GO
PRINT N'Adding foreign keys to [dspAuth].[SecurityDescriptorUserPermission]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorUserPermission] ADD CONSTRAINT [FK_SecurityDescriptorUserPermission_PermissionGroup_PermissionGroupId] FOREIGN KEY ([PermissionGroupId]) REFERENCES [dspAuth].[PermissionGroup] ([PermissionGroupId])
GO
PRINT N'Adding foreign keys to [dspAuth].[Role]'
GO
ALTER TABLE [dspAuth].[Role] ADD CONSTRAINT [FK_Role_OwnerSecurityDescriptorId_SecurityDescriptor] FOREIGN KEY ([OwnerSecurityDescriptorId]) REFERENCES [dspAuth].[SecurityDescriptor] ([SecurityDescriptorId])
GO
ALTER TABLE [dspAuth].[Role] ADD CONSTRAINT [FK_Role_OwnerSecurityDescriptorId_SecurityDescriptorId] FOREIGN KEY ([OwnerSecurityDescriptorId]) REFERENCES [dspAuth].[SecurityDescriptor] ([SecurityDescriptorId])
GO
PRINT N'Adding foreign keys to [dspAuth].[SecurityDescriptorParent]'
GO
ALTER TABLE [dspAuth].[SecurityDescriptorParent] ADD CONSTRAINT [FK_SecurityDescriptorInheritance_SecurityDescriptor_SecurityDescriptorId] FOREIGN KEY ([SecurityDescriptorId]) REFERENCES [dspAuth].[SecurityDescriptor] ([SecurityDescriptorId]) ON DELETE CASCADE
GO
ALTER TABLE [dspAuth].[SecurityDescriptorParent] ADD CONSTRAINT [FK_SecurityDescriptorInheritance_SecurityDescriptor_ParentSecurityDescriptorId] FOREIGN KEY ([ParentSecurityDescriptorId]) REFERENCES [dspAuth].[SecurityDescriptor] ([SecurityDescriptorId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[InboxMessage]'
GO
ALTER TABLE [dspInboxMessage].[InboxMessage] ADD CONSTRAINT [FK_InboxProcessedMessage_ProcessState] FOREIGN KEY ([InboxMessageProcessStateId]) REFERENCES [dspInboxMessage].[InboxMessageProcessState] ([InboxMessageProcessStateId])
GO
ALTER TABLE [dspInboxMessage].[InboxMessage] ADD CONSTRAINT [FK_InboxProcessedMessage_MessagePattern1] FOREIGN KEY ([MessagePatternId]) REFERENCES [dspInboxMessage].[MessagePattern] ([MessagePatternId])
GO
ALTER TABLE [dspInboxMessage].[InboxMessage] ADD CONSTRAINT [FK_InboxMessage_ProviderInfo] FOREIGN KEY ([ProviderInfoId]) REFERENCES [dspInboxMessage].[ProviderInfo] ([ProviderInfoId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[MessagePattern]'
GO
ALTER TABLE [dspInboxMessage].[MessagePattern] ADD CONSTRAINT [FK_MessagePattern_MessagePatternSeprator] FOREIGN KEY ([MessagePatternSepratorId]) REFERENCES [dspInboxMessage].[MessagePatternSeprator] ([MessagePatternSepratorId])
GO
ALTER TABLE [dspInboxMessage].[MessagePattern] ADD CONSTRAINT [FK_MessagePattern_MessagePatternState] FOREIGN KEY ([MessagePatternStateId]) REFERENCES [dspInboxMessage].[MessagePatternState] ([MessagePatternStateId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[MessagePatternStep]'
GO
ALTER TABLE [dspInboxMessage].[MessagePatternStep] ADD CONSTRAINT [FK_MessagePatternSteps_MessagePatternStepType] FOREIGN KEY ([MessagePatternStepTypeId]) REFERENCES [dspInboxMessage].[MessagePatternStepType] ([MessagePatternStepTypeId])
GO
ALTER TABLE [dspInboxMessage].[MessagePatternStep] ADD CONSTRAINT [FK_MessagePatternSteps_MessagePattern] FOREIGN KEY ([MessagePatternId]) REFERENCES [dspInboxMessage].[MessagePattern] ([MessagePatternId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[ProviderInfo]'
GO
ALTER TABLE [dspInboxMessage].[ProviderInfo] ADD CONSTRAINT [FK_ProviderInfo_Provider] FOREIGN KEY ([ProviderId]) REFERENCES [dspInboxMessage].[Provider] ([ProviderId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[Provider]'
GO
ALTER TABLE [dspInboxMessage].[Provider] ADD CONSTRAINT [FK_Provider_ProviderType] FOREIGN KEY ([ProviderTypeId]) REFERENCES [dspInboxMessage].[ProviderType] ([ProviderTypeId])
GO
PRINT N'Adding foreign keys to [dspInboxMessage].[WaitForReplyMessage]'
GO
ALTER TABLE [dspInboxMessage].[WaitForReplyMessage] ADD CONSTRAINT [FK_WaitForReplyMessage_WaitForReplyMessageState] FOREIGN KEY ([WaitForReplyMessageStateId]) REFERENCES [dspInboxMessage].[WaitForReplyMessageState] ([WaitForReplyMessageStateId])
GO
PRINT N'Adding foreign keys to [dsp].[AppVersionDetail]'
GO
ALTER TABLE [dsp].[AppVersionDetail] ADD CONSTRAINT [FK_AppVersionDetail_AppVersion_AppVersionId] FOREIGN KEY ([AppVersionId]) REFERENCES [dsp].[AppVersion] ([AppVersionId])
GO
PRINT N'Adding foreign keys to [dsp].[Exception]'
GO
ALTER TABLE [dsp].[Exception] ADD CONSTRAINT [FK_Exception_StringTable_StringId] FOREIGN KEY ([StringId]) REFERENCES [dsp].[StringTable] ([StringId])
GO
PRINT N'Adding foreign keys to [dsp].[LogFilterSetting]'
GO
ALTER TABLE [dsp].[LogFilterSetting] ADD CONSTRAINT [FK__LogFilter__UserN__1D13DFA0] FOREIGN KEY ([UserName]) REFERENCES [dsp].[LogUser] ([UserName])
GO
PRINT N'Creating extended properties'
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'148', 'SCHEMA', N'DatabaseVersioning', 'TABLE', N'TemporalType', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'DatabaseVersioning', 'TABLE', N'TemporalType', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'125', 'SCHEMA', N'dspAuth', 'TABLE', N'ObjectType', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'ObjectType', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'138', 'SCHEMA', N'dspAuth', 'TABLE', N'PermissionGroupPermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'PermissionGroupPermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'128', 'SCHEMA', N'dspAuth', 'TABLE', N'PermissionGroup', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'PermissionGroup', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'127', 'SCHEMA', N'dspAuth', 'TABLE', N'Permission', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'Permission', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'146', 'SCHEMA', N'dspAuth', 'TABLE', N'RoleUser', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'RoleUser', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'144', 'SCHEMA', N'dspAuth', 'TABLE', N'Role', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'Role', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'139', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorParent', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorParent', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'140', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorRolePermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorRolePermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'145', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorUserPermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptorUserPermission', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'136', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptor', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dspAuth', 'TABLE', N'SecurityDescriptor', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'118', 'SCHEMA', N'dsp', 'TABLE', N'AppVersionDetail', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'AppVersionDetail', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'117', 'SCHEMA', N'dsp', 'TABLE', N'AppVersion', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'3', 'SCHEMA', N'dsp', 'TABLE', N'AppVersion', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'2', 'SCHEMA', N'dsp', 'TABLE', N'AuthUser', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'129', 'SCHEMA', N'dsp', 'TABLE', N'Exception', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'Exception', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'123', 'SCHEMA', N'dsp', 'TABLE', N'LogFilterSetting', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'LogFilterSetting', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'124', 'SCHEMA', N'dsp', 'TABLE', N'LogUser', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'LogUser', NULL, NULL
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'143', 'SCHEMA', N'dsp', 'TABLE', N'Setting', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'Setting', NULL, NULL
GO
EXEC sp_addextendedproperty N'MS_Description', N'Midware uses this UserId if it is set otherwise the midware use SystemUserId', 'SCHEMA', N'dsp', 'TABLE', N'Setting', 'COLUMN', N'AppUserId'
GO
EXEC sp_addextendedproperty N'DatabaseVersioningPriorityLevel', N'137', 'SCHEMA', N'dsp', 'TABLE', N'StringTable', NULL, NULL
GO
EXEC sp_addextendedproperty N'TemporalTypeId', N'1', 'SCHEMA', N'dsp', 'TABLE', N'StringTable', NULL, NULL
GO
EXEC sp_addextendedproperty N'MS_Description', N'same as object_id', 'SCHEMA', N'dsp', 'TABLE', N'SystemTable', 'COLUMN', N'SystemTableId'
GO
DECLARE @xp int
SELECT @xp=1
EXEC sp_addextendedproperty N'tSQLt.TestClass', @xp, 'SCHEMA', N'SQLCop', NULL, NULL, NULL, NULL
GO
EXEC sp_addextendedproperty N'InvokerApi', N'1', 'SCHEMA', N'api', NULL, NULL, NULL, NULL
GO
DECLARE @xp int
SELECT @xp=1
EXEC sp_addextendedproperty N'tSQLt.TestClass', @xp, 'SCHEMA', N'tClass', NULL, NULL, NULL, NULL
GO
DECLARE @xp int
SELECT @xp=1
EXEC sp_addextendedproperty N'tSQLt.TestClass', @xp, 'SCHEMA', N'tCodeQuality', NULL, NULL, NULL, NULL
GO
DECLARE @xp int
SELECT @xp=2
EXEC sp_addextendedproperty N'TemporalTypeId', @xp, NULL, NULL, NULL, NULL, NULL, NULL
GO
PRINT N'Altering permissions on SCHEMA:: [api]'
GO
GRANT EXECUTE ON SCHEMA:: [api] TO [ApiCallers]
GO
